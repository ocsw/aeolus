#
# actually send a syslog message; factored out here so logger
# is only called in one place, for maintainability
#
# $1 = message
# $2 = priority (facility.level or numeric)
#      (optional; use "" if not passing priority but passing a tag)
# $3 = tag (optional)
#
# "local" vars: slcmd, message
# utilities: logger, printf, sed, [
#
do_syslog () {
  # see SECURITY NOTE, below, about this code
  slcmd="logger -i"
  [ "$2" != "" ] && slcmd="$slcmd -p \"$2\""
  [ "$3" != "" ] && slcmd="$slcmd -t \"$3\""

# ETAETA: but ' still breaks words in "...

# ETA: no, just needs ' around arg to eval.  strangely, this code also
# produces this:
# Feb 27 01:14:38 aeolus zephyr[5682]: asdf#012"#012afff
# whereas with ', we get:
# Feb 27 01:15:59 aeolus zephyr[5689]: asdf " afff

  # when we pass in the text of commands, they will probably contain
  # sub-quoted parts, which will cause errors in the eval unless we
  # protect them (because this function contains another evaluation,
  # relative to our other uses of the string)
#  message=$(printf "%s\n" $1 | sed -e 's/^"/\\"/' -e 's/\([^\]\)"/\1\\"/g')
#  slcmd="$slcmd \"$message\""
set -vxx
#  eval "$slcmd"
printf "%s\n" "$1"
  eval '$slcmd $1'
}
do_syslog "asdf \"
afff"
exit;
