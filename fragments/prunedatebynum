#
# prune dated files by number and date
#
# $1: full path up to the date, not including any trailing separator
# $2: separator before the date
# $3: suffix after the date, including any leading separator
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# note: "current" file must exist before calling this function, so that
# it can be counted
#
# also, because we can't make any assumptions about the format of the date
# string, this function can be over-broad in the files it looks at;
# make sure there are no files that match $prefix$sep*$suffix* except for
# the desired ones
#
# "local" vars: prefix, sep, suffix, numf, daysf, kept, OLDIFS, filename
# global vars: IFS, newline
#
prunedatefiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

#  # prune by number
#  if [ "$numf" != "0" ]; then
#    kept="0";
#
#    OLDIFS="$IFS"
#    IFS="$newline"
#
#    # parsing ls isn't terribly safe, but if we restrict the values of the
#    # settings and change IFS, it might be ok, and it's pretty much the
#    # only way to sort by date without using something like Perl...
#    #
#    #***
#    # NO: this isn't going to work because ls uses ? for non-printing
#    # characters (aside from all the other issues)
#    #***
#    IFS="$newline" ls -t "$prefix$sep"*"$suffix"* 2>/dev/null \
#    | while read -r filename; do
#      # check more precisely
#      #
#      # do some contortions to avoid needing egrep
#      if printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix$" > /dev/null 2>&1 \
#         && \
#         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.lz$" > /dev/null 2>&1 \
#         && \
#         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.gz$" > /dev/null 2>&1 \
#         && \
#         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.bz$" > /dev/null 2>&1 \
#         && \
#         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.bz2$" > /dev/null 2>&1; then
#        continue
#      fi
#
#      # skip, then delete
#      if [ "$kept" -lt "$numf" ]; then
#        # expr is more portable than $(())
#        kept=$(expr "$kept" + 1)
#      else
#        # -r for dirs
#        rm -rf "$filename"
#      fi
#    done
#
#    IFS="$OLDIFS"
#  fi  # if [ "$numf" != "0" ]

  # prune by date
  if [ "$daysf" != "0" ]; then
    for filename in "$prefix$sep"*"$suffix"*; do
      # if nothing is found, the actual glob will be used for $filename
      if [ "$filename" = "$prefix$sep*$suffix*" ]; then
        break
      fi

      # check more precisely
      #
      # do some contortions to avoid needing egrep
      if printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.lz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.gz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.bz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$prefix$sep.*$suffix\.bz2$" > /dev/null 2>&1; then
        continue
      fi

      # delete
      #
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    done
  fi
}
