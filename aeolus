#!/bin/bash

#######################################################################
# Aeolus
# a portable, super-configurable database dump and rsync backup script
# by Daniel Malament
# see license() for license info
#######################################################################

# see usage() and the usage and sample config files for usage notes

# exit values:
#
#   0   = no error (e.g., runevery hasn't expired, or backup was completed
#         without errors)
#
#   10  = problem with the script invocation, the config file, or a setting
#         (also used in command modes like 'disable' as a generic error
#         value)
#   11  = previous lockfile still exists (possibly because backups were
#         manually disabled)
#
#   20  = error opening SSH tunnel
#
#   30  = error getting DBMS replication status
#   31  = error getting DB list
#
#   40  = DB name contains a problematic character
#   41  = DB dumpfile already exists
#   42  = error dumping DB
#   43  = error compressing DB dump
#
#   50  = rsync error
#
#   240 = bad variable name or subscript key
#   241 = error finding a delimiter for a string
#   250 = internal error; should never happen
#
# if there are multiple errors, the first one to occur is used

# modification notes:
#
# if the exit values above are changed, update the *_exitval variables,
# below
#
# lockfile dir is used for the following files:
#   $lfalertssilenced, $scriptdisabled, $timetemp, $logfifo,
#   ${DBMSes}-$replstatus, ${DBMSes}-$alldbs
# all files should be in printstatus()
#
# any change to the setting variables (additions, deletions, name changes,
# type changes, etc.) must be reflected in the following, as appropriate:
# the sample config file, $configsettings, configsettingtype(), the default
# settings section, switch*(), applydefaults(), and validconf()
#
# all external commands used should be listed in $externalcmds and the usage
# notes (including those used in library functions)
#
# adding a DBMS:
#   add vars to the sample config file, modeling after MySQL (but split up
#     [dbms]_dump*options if necessary)
#   add vars to the relevant variables/functions (see above)
#   add to dbdump*cmd(), checkdbmsrepl(), getdblist()
#   add to the database functions in the library
#   add to dbmslist
#   add to usage notes on setup and portability
#
# see notes in the hardcoded variables section for other things that should
# be kept in sync (e.g., the name of the script and $scriptname, the values
# of the defaults and the comments in the sample config file, etc.)

# TODO:
# globbing in dblist?
#
# better handling of long errors?
# i18n?
# setup modes?
# emulate mkdir -p?
# allow char devs / fifos in cases where we currently test for -f?
#  (but could cause problems with, e.g., rm...)
# on_*err -> mysql_*, rsync_*, etc.? (incl. splitting tunerr)
# add on_rsyncerr/warn?  startup_warn?
# phone-home check for newer version?
#   or auto-update?? (e.g., with 2x md5 and global lock)
#
# do more to protect against leading - in settings?


################
# version check
################

#
# if we're not running a high enough version of bash, we shouldn't even try
# to parse the code below
#
# NOTE: despite the use of some bash-specific features, the code has been
# written to be as portable as possible wherever those features are not
# needed
#

# we can't use arithmetical tests because BASH_VERSINFO[1] wasn't always
# purely numeric
case "$BASH_VERSION" in
  ''|1.*|2.*|3.0.*)
    cat <<-EOF 1>&2

	Error: This script requires bash version 3.1 or later.

	EOF
    exit 10  # startup_exitval
    ;;
esac


######################
# pull in the library
######################

# preparatory massaging:
# we need to know if this was set on the command line or not
skip_on_tunerr="yes"

# source the library
if [ "$AEOLUSLIB" != "" ]; then
  # silly, but [ -e ] isn't portable, and neither is !
  if ls -d "$AEOLUSLIB" > /dev/null 2>&1; then
    :  # do nothing
  else
    cat <<-EOF 1>&2

	Error: specified Aeolus library path does not exist.
	(AEOLUSLIB='$AEOLUSLIB')

	EOF
    exit 10  # startup_exitval
  fi

  if [ ! -f "$AEOLUSLIB" ]; then
    cat <<-EOF 1>&2

	Error: specified Aeolus library path is not a file, or a link to one.
	(AEOLUSLIB='$AEOLUSLIB')

	EOF
    exit 10  # startup_exitval
  fi

  if [ ! -r "$AEOLUSLIB" ]; then
    cat <<-EOF 1>&2

	Error: specified Aeolus library path is not readable.
	(AEOLUSLIB='$AEOLUSLIB')

	EOF
    exit 10  # startup_exitval
  fi

  . "$AEOLUSLIB"
else  # AEOLUSLIB not set
  for libdir in "/usr/local/lib" "/usr/lib" "~/bin" \
        "$(dirname "$0" 2>/dev/null)"; do
    libpath="${libdir}/aeolus-lib.sh"

    # check for "" in case there is no dirname util; [ -e ] isn't portable
    if [ "$libdir" != "" ] && ls -d "$libpath" > /dev/null 2>&1; then
      if [ ! -f "$libpath" ]; then
        cat <<-EOF 1>&2

	Error: Aeolus library path was found, but it's not a file, or a link to one.
	(path: '$libpath')

	EOF
        exit 10  # startup_exitval
      fi

      if [ ! -r "$libpath" ]; then
        cat <<-EOF 1>&2

	Error: Aeolus library path was found, but the file is not readable.
	(path: '$libpath')

	EOF
        exit 10  # startup_exitval
      fi

      . "$libpath"
      break
    fi
  done
fi

if [ "$aeolus_lib_sourced" != "yes" ]; then
    cat <<-EOF 1>&2

	Error: Aeolus library not found.

	EOF
  exit 10  # startup_exitval
fi


############
# debugging
############

#
# turn on debugging
#
# note: this function must be idempotent
#
# library vars: (newline)
#
do_debug () {
  # see http://bashdb.sourceforge.net/bashdb.html#Interactive-Line-Tracing-Session
  #PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]} - [${SHLVL},${BASH_SUBSHELL}, $?]$newline'
  set -vx
}

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
#
# however, this only applies if debugging is turned on on the command line;
# see also below
#
# (note: setting isn't called 'debug' to avoid possible collisions)
#
if [ "$debugme" = "yes" ]; then
  do_debug
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# name of the script, as reported by usage(), etc.
# change this if you rename the script file
scriptname="aeolus"

# external commands used (potentially)
#
# commands that are always builtins, such as 'set' and 'wait', can be
# omitted (and in some cases, we would have used them already by the time
# we try to test for them)
#
externalcmds="
  rsync
  ssh
  nc
  mysql
  mysqldump
  psql
  pg_dump
  pg_dumpall
  gzip
  pigz
  bzip2
  lzip
  xz
  date
  hostname
  logger
  mailx
  grep
  awk
  gawk
  sed
  tr
  expr
  cat
  tee
  ls
  find
  touch
  mv
  rm
  mkdir
  mkfifo
  sleep
"

# default path to the config file, if one isn't specified
defaultconfigfile="/etc/aeolus/aeolus.conf"

# path to sample config file with full descriptions of settings
sampleconfigfile="/etc/aeolus/CONFIG.SAMPLE"

# names of all config file settings, in logical order
# includes arrays and functions; see configsettingtype()
configsettings="
  usepath
  useumask
  timecomptype
  debugme
  on_tunerr
  on_dbreplerr
  on_dblisterr
  on_dbnameerr
  on_dbduplerr
  on_dbdumperr
  on_dbziperr
  runevery
  startedfile
  lockfile
  ifrunning
  alertfile
  suppressemail
  mailto
  subject
  outputlog
  outputlog_layout
  outputlog_sep
  outputlog_date
  numlogs
  dayslogs
  usesyslog
  syslogstat
  syslogerr
  syslogtag
  quiet
  statuslog
  rsync_sshuser
  rsync_sshhost
  rsync_sshkeyfile
  rsync_sshport
  rsync_localhost
  rsync_localport
  rsync_remotehost
  rsync_remoteport
  rsync_sshoptions
  rsync_sshtimeout
  do_rsync
  rsync_mode
  rsync_source
  rsync_dest
  rsync_port
  rsync_pwfile
  rsync_filterfile
  rsync_options
  rsync_add
  mysql_dodump
  mysql_usetunnel
  mysql_sshuser
  mysql_sshhost
  mysql_sshkeyfile
  mysql_sshport
  mysql_localhost
  mysql_localport
  mysql_remotehost
  mysql_remoteport
  mysql_sshoptions
  mysql_sshtimeout
  mysql_user
  mysql_pwfile
  mysql_protocol
  mysql_host
  mysql_port
  mysql_socketfile
  mysql_replstatus
  mysql_dbmode
  mysql_dblist
  mysql_splitdbs
  mysql_options
  mysql_dumpoptions
  mysql_usealtopts
  mysql_altopts
  mysql_dumpdir
  mysql_layout
  mysql_fileprefix
  mysql_filesuffix
  mysql_subdirprefix
  mysql_filedirsep
  mysql_filedirdate
  mysql_numfiles
  mysql_daysfiles
  mysql_zipmode
  mysql_zipoptions
  mysql_preserve
  mysql_useaftereach
  mysql_aftereach
  postgres_dodump
  postgres_usetunnel
  postgres_sshuser
  postgres_sshhost
  postgres_sshkeyfile
  postgres_sshport
  postgres_localhost
  postgres_localport
  postgres_remotehost
  postgres_remoteport
  postgres_sshoptions
  postgres_sshtimeout
  postgres_user
  postgres_pwfile
  postgres_host
  postgres_port
  postgres_connectdb
  postgres_dbmode
  postgres_dblist
  postgres_splitdbs
  postgres_options
  postgres_dumponeoptions
  postgres_dumpalloptions
  postgres_usealtopts
  postgres_altopts
  postgres_dumpdir
  postgres_layout
  postgres_fileprefix
  postgres_filesuffix
  postgres_subdirprefix
  postgres_filedirsep
  postgres_filedirdate
  postgres_numfiles
  postgres_daysfiles
  postgres_zipmode
  postgres_zipoptions
  postgres_preserve
  postgres_useaftereach
  postgres_aftereach
"

# names of nonexistent settings which the user might accidentally try to set;
# in some cases these might cause problems
# includes arrays and functions; see configsettingtype()
# see also warnbogusconf() in the library
bogusconfig="
  mysql_connectdb
  mysql_dumponeoptions
  mysql_dumpmultoptions
  mysql_dumpalloptions
  postgres_protocol
  postgres_socketfile
  postgres_replstatus
  postgres_dumpoptions
  postgres_dumpmultoptions
"

#
# which settings are arrays or functions?
#
# (this is the only reasonable way I have come up with to handle this,
# without requiring bash4 for associative arrays)
#
# $1 is the name of a config setting or bogus setting
# (see configsettings and bogusconfig)
#
# prints "scalar", "array", or "function"
#
configsettingtype () {
  # broken up for readability
  case "$1" in
    # rsync
    rsync_sshoptions|rsync_source|rsync_options|rsync_add)
      echo "array"
      ;;

    # MySQL
    mysql_sshoptions|mysql_dblist|mysql_options|mysql_dumpoptions)
      echo "array"
      ;;
    mysql_dumponeoptions|mysql_dumpmultoptions|mysql_dumpalloptions)
      echo "array"
      ;;
    mysql_zipoptions)
      echo "array"
      ;;
    mysql_altopts|mysql_aftereach)
      echo "function"
      ;;

    # PostgreSQL
    postgres_sshoptions|postgres_dblist|postgres_options|postgres_dumpoptions)
      echo "array"
      ;;
    postgres_dumponeoptions|postgres_dumpmultoptions|postgres_dumpalloptions)
      echo "array"
      ;;
    postgres_zipoptions)
      echo "array"
      ;;
    postgres_altopts|postgres_aftereach)
      echo "function"
      ;;

    # default
    *)
      echo "scalar"
  esac
}

#
# default settings
#
# change comments in sample config file if you change these
#

# default settings: housekeeping
timecomptype_default="find"
debugme_default="no"
on_tunerr_default="phase"
on_dbreplerr_default="phase"
on_dblisterr_default="phase"
on_dbnameerr_default="db"
on_dbduplerr_default="db"
on_dbdumperr_default="db"
on_dbziperr_default="db"

# default settings: checks and logging
runevery_default="0"
startedfile_default="/var/run/aeolus/started"
lockfile_default="/var/run/aeolus/lock"
ifrunning_default="120"  # 2 hours
#alertfile_default="$lockfile.alert"  # set it later, after lockfile
suppressemail_default="no"
if command -v hostname > /dev/null 2>&1; then
  mailto_default="root@$(hostname)"
  subject_default="Aeolus alert on $(hostname)"
else
  mailto_default="root@localhost"
  subject_default="Aeolus alert"
fi
outputlog_default="/var/log/aeolus-output.log"  # only if unset
outputlog_layout_default="number"
outputlog_sep_default="."  # only if unset
outputlog_date_default="+%Y%m%d"  # only if unset
numlogs_default="0"
dayslogs_default="7"
usesyslog_default="yes"
quiet_default="no"
statuslog_default="/var/log/aeolus.log"  # only if unset

# default settings: SSH tunnels (all)
rsync_localhost_default="localhost"
rsync_localport_default="8873"
rsync_remotehost_default="localhost"
rsync_remoteport_default="873"
mysql_localhost_default="127.0.0.1"
mysql_localport_default="4306"
mysql_remotehost_default="localhost"
mysql_remoteport_default="3306"
postgres_localhost_default="localhost"
postgres_localport_default="6432"
postgres_remotehost_default="localhost"
postgres_remoteport_default="5432"
sshtimeout_default="15"  # applies to all SSH tunnels

# default settings: rsync
do_rsync_default="no"
rsync_mode_default="tunnel"
rsync_pwfile_default="/etc/aeolus/rsync.pw"  # only if unset

# default settings: DBMSes (all; see also below)
dbms_dodump_default="no"
dbms_usetunnel_default="no"
dbms_dumpdir_default="."
dbms_layout_default="date"
dbms_filesuffix_default=".sql"  # only if unset
dbms_filedirsep_default="-"  # only if unset
dbms_filedirdate_default="+%Y%m%d"  # only if unset
dbms_numfiles_default="0"
dbms_daysfiles_default="7"
dbms_zipmode_default="gzip"
dbms_preserve_default="data"
dbms_useaftereach_default="no"

# default settings: MySQL (see also above)
mysql_pwfile_default="/etc/aeolus/mysql.pw"  # only if unset
mysql_dbmode_default="all"
mysql_splitdbs_default="no"
mysql_dumpoptions_default=(--opt -Q -R -c)  # only if unset
mysql_usealtopts_default="yes"
mysql_fileprefix_default="mysqldump"  # only if unset
mysql_subdirprefix_default="mysqldump"  # only if unset

# default settings: PostgreSQL (see also above)
postgres_pwfile_default="/etc/aeolus/postgres.pw"  # only if unset
postgres_connectdb_default="postgres"
postgres_dbmode_default="all"
postgres_splitdbs_default="no"
postgres_dumponeoptions_default=(-c)  # only if unset
postgres_dumpalloptions_default=(-c)  # only if unset
postgres_usealtopts_default="no"
postgres_fileprefix_default="postgresdump"  # only if unset
postgres_subdirprefix_default="postgresdump"  # only if unset

# settings that have no default, and can't be blank
# (but may be ignored, depending on other settings)
#
# [tun]_sshhost
# rsync_source
# rsync_dest
# [dbms]_dblist

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
#
# removing a DBMS from this list will effectively disable it
dbmslist="mysql postgres"

# names of tempfiles stored in the lockfile directory
lfalertssilenced="lfalertssilenced"
scriptdisabled="scriptdisabled"
timetemp="timetemp"
logfifo="logfifo"
replstatus="replstatus"  # gets [DBMS]- prepended
alldbs="alldbs"  # gets [DBMS]- prepended

# extension to use for temporary dumpfiles
dumptmp=".tmp"

# exit values; see top of script for details
# (when modifying: keep the numbers in sync with the notes at the top
# and the exit values for the bash check and the library sourcing, and take
# http://tldp.org/LDP/abs/html/exitcodes.html into account)
no_error_exitval="0"
startup_exitval="10"
lockfile_exitval="11"
sshtunnel_exitval="20"
getdbrepl_exitval="30"
getdblist_exitval="31"
dbname_exitval="40"
dumpexists_exitval="41"
dbdump_exitval="42"
dbzip_exitval="43"
rsync_exitval="50"
badvarname_exitval="240"
nodelim_exitval="241"
internal_exitval="250"


###########################
# default config functions
###########################

#
# these are functions associated with config settings, and defined by the
# user; they can be:
# - defined and exported from the invoking shell, in which case we don't
#   redefine them
# - undefined, in which case these defaults will apply
# - defined in the config file, in which case those definitions will
#   override these
#

#
# for mysql_usealtopts
#
# $1 = the name of a database
#
# returns 1 (false) if mysql_dumpoptions should be used
# otherwise, returns 0 (true) and sets altopts array
#
# global vars: altopts
# config settings: mysql_dumpoptions
# library functions: funcisnotdefined(), copyarray()
# bashisms: array+=() [v3.1]
#
if funcisnotdefined "mysql_altopts"; then
  mysql_altopts () {
    case "$1" in
      information_schema|performance_schema)
        copyarray "mysql_dumpoptions" "altopts" exact  # incl regular opts
        altopts+=(--skip-lock-tables)
        return 0
        ;;
      mysql)
        copyarray "mysql_dumpoptions" "altopts" exact  # incl regular opts
        altopts+=(--skip-extended-insert)
        return 0
        ;;
    esac

    return 1
  }
fi


#################################
# helper functions: housekeeping
#################################

#
# cleanup function, to be called by do_exit()
#
#   * closes any open SSH tunnel
#   * removes the lockfile, unless the scriptdisabled semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: tunpid_prefix, scriptdisabled
# config settings: lockfile
# library functions: closesshtunnel()
# utilities: rm, [
# files: $lockfile, $lockfile/$scriptdisabled
#
do_exit_cleanup () {
  # closesshtunnel() can be run after the tunnel was already closed,
  # but should not be run if it was never started
  if [ "$tunpid_prefix" != "" ]; then
    closesshtunnel
  fi

  if [ ! -f "$lockfile/$scriptdisabled" ]; then
    rm -r "$lockfile"
  fi
  # otherwise, a disable command must have been run while we were
  # doing this backup; leave the lockfile dir alone, so future backups
  # will be disabled
}


#######################################
# helper functions: logging and alerts
#######################################

#
# print diagnostics, for sendalert()
#
# must not be called until after printstatus() is defined
#
# library functions: printconfig()
# utilities: cat
#
sendalert_body () {
  cat <<-EOF


	$(printconfig)


	$(printstatus all)
	EOF
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g., "rsync" or a member of
# $dbmslist)
#
# $2 is a description of the tunnel's purpose (e.g. "mysql dumps" or
# "rsync backups"); this is used in status and error messages
#
# (in the notes below, [tun] = the value of $1)
#
# note: the [tun]_* settings may still be used in addition to or instead of
# the tun_* globals; keep them in sync while in use
#
# [tun]_sshoptions must be an indexed, non-sparse array
#
# global vars: tun_prefix, tun_descr, tun_sshuser, tun_sshhost,
#              tun_sshkeyfile, tun_sshport, tun_localhost, tun_localport,
#              tun_remotehost, tun_remoteport, tun_sshoptions,
#              tun_sshtimeout
# config settings: [tun]_sshuser, [tun]_sshhost, [tun]_sshkeyfile,
#                  [tun]_sshport, [tun]_localhost, [tun]_localport,
#                  [tun]_remotehost, [tun]_remoteport, [tun]_sshoptions,
#                  [tun]_sshtimeout
# library functions: copyvar(), copyarray()
#
switchtunnel () {
  tun_prefix="$1"
  tun_descr="$2"
  copyvar "${1}_sshuser" "tun_sshuser" exact
  copyvar "${1}_sshhost" "tun_sshhost" exact
  copyvar "${1}_sshkeyfile" "tun_sshkeyfile" exact
  copyvar "${1}_sshport" "tun_sshport" exact
  copyvar "${1}_localhost" "tun_localhost" exact
  copyvar "${1}_localport" "tun_localport" exact
  copyvar "${1}_remotehost" "tun_remotehost" exact
  copyvar "${1}_remoteport" "tun_remoteport" exact
  copyarray "${1}_sshoptions" "tun_sshoptions" exact
  copyvar "${1}_sshtimeout" "tun_sshtimeout" exact
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# (in the notes below, [dbms] = the value of $1)
#
# note: the [dbms]_* settings may still be used in addition to or instead of
# the dbms_* globals; keep them in sync while in use
#
# [dbms]_dblist, [dbms]_options, [dbms]_dumpoptions, [dbms]_dumponeoptions,
# [dbms]_dumpmultoptions, [dbms]_dumpalloptions, and [dbms]_zipoptions must
# be indexed, non-sparse arrays
#
# global vars: [dbms]_datestring, dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socketfile,
#              dbms_connectdb, dbms_replstatus, dbms_dbmode, dbms_dblist,
#              dbms_splitdbs, dbms_options, dbms_dumpoptions,
#              dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_usealtopts, dbms_dumpdir,
#              dbms_layout, dbms_fileprefix, dbms_filesuffix,
#              dbms_subdirprefix, dbms_filedirsep, dbms_filedirdate,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dbms_useaftereach, dbms_datestring
# config settings: [dbms]_dodump, [dbms]_usetunnel, [dbms]_user,
#                  [dbms]_pwfile, [dbms]_protocol, [dbms]_host, [dbms]_port,
#                  [dbms]_socketfile, [dbms]_connectdb, [dbms]_replstatus,
#                  [dbms]_dbmode, [dbms]_dblist, [dbms]_splitdbs,
#                  [dbms]_options, [dbms]_dumpoptions, [dbms]_dumponeoptions,
#                  [dbms]_dumpmultoptions, [dbms]_dumpalloptions,
#                  [dbms]_usealtopts, [dbms]_dumpdir, [dbms]_layout,
#                  [dbms]_fileprefix, [dbms]_filesuffix,
#                  [dbms]_subdirprefix, [dbms]_filedirsep,
#                  [dbms]_filedirdate, [dbms]_numfiles, [dbms]_daysfiles,
#                  [dbms]_zipmode, [dbms]_zipoptions, [dbms]_preserve,
#                  [dbms]_useaftereach
# library functions: copyvar(), copyarray()
#
switchdbms () {
  dbms_prefix="$1"
  copyvar "${1}_dodump" "dbms_dodump" exact
  copyvar "${1}_usetunnel" "dbms_usetunnel" exact
  copyvar "${1}_user" "dbms_user" exact
  copyvar "${1}_pwfile" "dbms_pwfile" exact
  copyvar "${1}_protocol" "dbms_protocol" exact
  copyvar "${1}_host" "dbms_host" exact
  copyvar "${1}_port" "dbms_port" exact
  copyvar "${1}_socketfile" "dbms_socketfile" exact
  copyvar "${1}_connectdb" "dbms_connectdb" exact
  copyvar "${1}_replstatus" "dbms_replstatus" exact
  copyvar "${1}_dbmode" "dbms_dbmode" exact
  copyarray "${1}_dblist" "dbms_dblist" exact
  copyvar "${1}_splitdbs" "dbms_splitdbs" exact
  copyarray "${1}_options" "dbms_options" exact
  copyarray "${1}_dumpoptions" "dbms_dumpoptions" exact
  copyarray "${1}_dumponeoptions" "dbms_dumponeoptions" exact
  copyarray "${1}_dumpmultoptions" "dbms_dumpmultoptions" exact
  copyarray "${1}_dumpalloptions" "dbms_dumpalloptions" exact
  copyvar "${1}_usealtopts" "dbms_usealtopts" exact
  copyvar "${1}_dumpdir" "dbms_dumpdir" exact
  copyvar "${1}_layout" "dbms_layout" exact
  copyvar "${1}_fileprefix" "dbms_fileprefix" exact
  copyvar "${1}_filesuffix" "dbms_filesuffix" exact
  copyvar "${1}_subdirprefix" "dbms_subdirprefix" exact
  copyvar "${1}_filedirsep" "dbms_filedirsep" exact
  copyvar "${1}_filedirdate" "dbms_filedirdate" exact
  copyvar "${1}_numfiles" "dbms_numfiles" exact
  copyvar "${1}_daysfiles" "dbms_daysfiles" exact
  copyvar "${1}_zipmode" "dbms_zipmode" exact
  copyarray "${1}_zipoptions" "dbms_zipoptions" exact
  copyvar "${1}_preserve" "dbms_preserve" exact
  copyvar "${1}_useaftereach" "dbms_useaftereach" exact
  # internal, not from config
  copyvar "${1}_datestring" "dbms_datestring"
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# global vars: scriptname, defaultconfigfile
# utilities: cat
#
usage () {
  # not necessarily reliable/consistent, switched to static global
  # (see hardcoded vars)
  #scriptname=$(printf "%s\n" "$0" | sed 's|^.*/||')

  cat <<EOF 1>&2

Usage:

  [ setting="value" ] $scriptname [ -f /path/to/config/file | -n ] [ mode ]

  Multiple settings can be added to the command line, separated by spaces;
  command-line settings override the config file.  Array settings may have
  to be supplied by creating a wrapper script that sets them, then sources
  (not runs) this script.  There is no way to override a config-file-
  supplied array setting with an empty array, but ("") may suffice in some
  cases.  Function settings can be overridden from the command line by
  sourcing (not running) the script after defining them, or a wrapper can be
  used as with array settings.

  The location of the Aeolus library can be specified/overriden by setting
  AEOLUSLIB.

Options:

  -f /path/to/config/file: supply the path to the config file
  -n: use no config file
  The last-supplied of -f and -n will be used.
  If neither option is supplied, "$defaultconfigfile" will be tried.

Modes:

  Modes can have a leading '--'; e.g., '--help' (omit the quotes).
  If multiple modes are given, the last one is used.

  Available modes and their effects:

  "help" or "usage": this message is printed

  "license": a license message is printed

  "config" or "settings": the current config settings are printed

  "status": the current status, including timestamps, is printed
  "statusall": temp files mainly relevant for debugging are also included

  "silence": alerts about the lockfile existing are silenced until
  either they are unsilenced, or the lockfile is no longer present

  "unsilence": alerts about the lockfile existing are re-enabled

  "stop" or "disable": backups are disabled until "start" or "enable"
  is used

  "start" or "enable": backups are re-enabled

  "clearlock" or "unlock": the lockfile is forcibly removed; only use this
  if you're sure a backup isn't currently running!

  "create": a config file template is printed (all settings, in logical
  order, commented out so that the default values will be used unless
  otherwise specified); if -f is also given, the config file is output to
  the supplied path, but only if the file does not already exist

  "systemtest": diagnostics are printed about the system's support for
  the script (i.e., what utilities are present in the current PATH)

EOF
}

#
# print a license message to stderr
#
# utilities: cat
#
license () {
  cat <<EOF 1>&2

Copyright 2011 Daniel Malament.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
}

#
# print the current status, including file timestamps, etc.
#
# if $1 is "all", include timestamps for temp files that are only really
# relevant for debugging
#
# doesn't print surrounding blank lines; add them if necessary in context
#
# "local" vars: dbms
# global vars: lfalertssilenced, scriptdisabled, timetemp, logfifo, alldbs,
#              dbmslist
# config settings: startedfile, lockfile, alertfile
# library functions: getfilemetadata()
# utilities: cat, echo, [
# files: $startedfile, $alertfile, $lockfile, $lockfile/$lfalertssilenced,
#        $lockfile/$scriptdisabled, $lockfile/$timetemp, $lockfile/$logfifo,
#        $lockfile/${DBMSes}-$alldbs
#
printstatus () {
  cat <<-EOF
	-------
	Status:
	-------

	EOF

  if [ ! -f "$startedfile" ]; then  # -e isn't portable
    echo "no last-started file; this backup appears to have never been run"
  fi
  if [ -d "$lockfile" ]; then
    echo "lockfile directory exists; a backup may be in progress"
  else
    echo "no lockfile directory found; backups enabled but not in progress"
  fi
  if [ -f "$alertfile" ]; then
    echo "alertfile exists; a running backup prevented a new one from starting"
  fi
  if [ -f "$lockfile/$lfalertssilenced" ]; then
    echo "lockfile alerts have been silenced"
  fi
  if [ -f "$lockfile/$scriptdisabled" ]; then
    echo "backups have been disabled (but the last one may still be running)"
  fi

  cat <<-EOF


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	$(getfilemetadata "$startedfile")

	lockfile:
	$(getfilemetadata "$lockfile")

	alertfile:
	$(getfilemetadata "$alertfile")

	lfalertssilenced:
	$(getfilemetadata "$lockfile/$lfalertssilenced")

	scriptdisabled:
	$(getfilemetadata "$lockfile/$scriptdisabled")
	EOF

  if [ "$1" = "all" ]; then
    cat <<-EOF

	[temp files below this line, mainly relevant for debugging]

	timetemp:
	$(getfilemetadata "$lockfile/$timetemp")

	logfifo:
	$(getfilemetadata "$lockfile/$logfifo")
	EOF

    for dbms in $dbmslist; do
      cat <<-EOF

	${dbms}-replstatus:
	$(getfilemetadata "$lockfile/${dbms}-replstatus")

	${dbms}-alldbs:
	$(getfilemetadata "$lockfile/${dbms}-$alldbs")
	EOF
    done
  fi
}

#
# apply default settings where applicable
#
# see hardcoded variables section for rules
# (e.g. default only if unset, late checking)
#
# global vars: (setting _defaults)
# config settings: (most of them)
# library functions: arrayisunset(), copyarray()
# utilities: [
#
applydefaults () {
  # housekeeping
  [ "$timecomptype" = "" ] && timecomptype="$timecomptype_default"
  [ "$debugme" = "" ] && debugme="$debugme_default"
  [ "$on_tunerr" = "" ] && on_tunerr="$on_tunerr_default"
  [ "$on_dbreplerr" = "" ] && on_dbreplerr="$on_dbreplerr_default"
  [ "$on_dblisterr" = "" ] && on_dblisterr="$on_dblisterr_default"
  [ "$on_dbnameerr" = "" ] && on_dbnameerr="$on_dbnameerr_default"
  [ "$on_dbduplerr" = "" ] && on_dbduplerr="$on_dbduplerr_default"
  [ "$on_dbdumperr" = "" ] && on_dbdumperr="$on_dbdumperr_default"
  [ "$on_dbziperr" = "" ] && on_dbziperr="$on_dbziperr_default"

  # checks and logging
  [ "$runevery" = "" ] && runevery="$runevery_default"
  [ "$startedfile" = "" ] && startedfile="$startedfile_default"
  [ "$lockfile" = "" ] && lockfile="$lockfile_default"
  [ "$ifrunning" = "" ] && ifrunning="$ifrunning_default"
  [ "$alertfile" = "" ] && alertfile="$lockfile.alert"  # late-binding default
  [ "$suppressemail" = "" ] && suppressemail="$suppressemail_default"
  [ "$mailto" = "" ] && mailto="$mailto_default"
  [ "$subject" = "" ] && subject="$subject_default"
  [ "${outputlog+X}" = "" ] && outputlog="$outputlog_default"
  [ "$outputlog_layout" = "" ] && outputlog_layout="$outputlog_layout_default"
  [ "${outputlog_sep+X}" = "" ] && outputlog_sep="$outputlog_sep_default"
  [ "${outputlog_date+X}" = "" ] && outputlog_date="$outputlog_date_default"
  [ "$numlogs" = "" ] && numlogs="$numlogs_default"
  [ "$dayslogs" = "" ] && dayslogs="$dayslogs_default"
  [ "$usesyslog" = "" ] && usesyslog="$usesyslog_default"
  [ "$quiet" = "" ] && quiet="$quiet_default"
  [ "${statuslog+X}" = "" ] && statuslog="$statuslog_default"

  # SSH tunnels (individual and global defaults)
  [ "$rsync_localhost" = "" ] && rsync_localhost="$rsync_localhost_default"
  [ "$rsync_localport" = "" ] && rsync_localport="$rsync_localport_default"
  [ "$rsync_remotehost" = "" ] && rsync_remotehost="$rsync_remotehost_default"
  [ "$rsync_remoteport" = "" ] && rsync_remoteport="$rsync_remoteport_default"
  [ "$mysql_localhost" = "" ] && mysql_localhost="$mysql_localhost_default"
  [ "$mysql_localport" = "" ] && mysql_localport="$mysql_localport_default"
  [ "$mysql_remotehost" = "" ] && mysql_remotehost="$mysql_remotehost_default"
  [ "$mysql_remoteport" = "" ] && mysql_remoteport="$mysql_remoteport_default"
  [ "$postgres_localhost" = "" ] && postgres_localhost="$postgres_localhost_default"
  [ "$postgres_localport" = "" ] && postgres_localport="$postgres_localport_default"
  [ "$postgres_remotehost" = "" ] && postgres_remotehost="$postgres_remotehost_default"
  [ "$postgres_remoteport" = "" ] && postgres_remoteport="$postgres_remoteport_default"
  # global
  [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="$sshtimeout_default"
  [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="$sshtimeout_default"
  [ "$postgres_sshtimeout" = "" ] && postgres_sshtimeout="$sshtimeout_default"

  # rsync
  [ "$do_rsync" = "" ] && do_rsync="$do_rsync_default"
  [ "$rsync_mode" = "" ] && rsync_mode="$rsync_mode_default"
  [ "${rsync_pwfile+X}" = "" ] && rsync_pwfile="$rsync_pwfile_default"

  # DBMSes (global defaults; see also below)
  [ "$mysql_dodump" = "" ] && mysql_dodump="$dbms_dodump_default"
  [ "$mysql_usetunnel" = "" ] && mysql_usetunnel="$dbms_usetunnel_default"
  [ "$mysql_dumpdir" = "" ] && mysql_dumpdir="$dbms_dumpdir_default"
  [ "$mysql_layout" = "" ] && mysql_layout="$dbms_layout_default"
  [ "${mysql_filesuffix+X}" = "" ] && mysql_filesuffix="$dbms_filesuffix_default"
  [ "${mysql_filedirsep+X}" = "" ] && mysql_filedirsep="$dbms_filedirsep_default"
  [ "${mysql_filedirdate+X}" = "" ] && mysql_filedirdate="$dbms_filedirdate_default"
  [ "$mysql_numfiles" = "" ] && mysql_numfiles="$dbms_numfiles_default"
  [ "$mysql_daysfiles" = "" ] && mysql_daysfiles="$dbms_daysfiles_default"
  [ "$mysql_zipmode" = "" ] && mysql_zipmode="$dbms_zipmode_default"
  [ "$mysql_preserve" = "" ] && mysql_preserve="$dbms_preserve_default"
  [ "$mysql_useaftereach" = "" ] && mysql_useaftereach="$dbms_useaftereach_default"
  [ "$postgres_dodump" = "" ] && postgres_dodump="$dbms_dodump_default"
  [ "$postgres_usetunnel" = "" ] && postgres_usetunnel="$dbms_usetunnel_default"
  [ "$postgres_dumpdir" = "" ] && postgres_dumpdir="$dbms_dumpdir_default"
  [ "$postgres_layout" = "" ] && postgres_layout="$dbms_layout_default"
  [ "${postgres_filesuffix+X}" = "" ] && postgres_filesuffix="$dbms_filesuffix_default"
  [ "${postgres_filedirsep+X}" = "" ] && postgres_filedirsep="$dbms_filedirsep_default"
  [ "${postgres_filedirdate+X}" = "" ] && postgres_filedirdate="$dbms_filedirdate_default"
  [ "$postgres_numfiles" = "" ] && postgres_numfiles="$dbms_numfiles_default"
  [ "$postgres_daysfiles" = "" ] && postgres_daysfiles="$dbms_daysfiles_default"
  [ "$postgres_zipmode" = "" ] && postgres_zipmode="$dbms_zipmode_default"
  [ "$postgres_preserve" = "" ] && postgres_preserve="$dbms_preserve_default"
  [ "$postgres_useaftereach" = "" ] && postgres_useaftereach="$dbms_useaftereach_default"

  # DBMSes (individual defaults; see also above)
  # MySQL
  [ "${mysql_pwfile+X}" = "" ] && mysql_pwfile="$mysql_pwfile_default"
  [ "$mysql_dbmode" = "" ] && mysql_dbmode="$mysql_dbmode_default"
  [ "$mysql_splitdbs" = "" ] && mysql_splitdbs="$mysql_splitdbs_default"
  arrayisunset "mysql_dumpoptions" && \
      copyarray "mysql_dumpoptions_default" "mysql_dumpoptions"
  [ "$mysql_usealtopts" = "" ] && mysql_usealtopts="$mysql_usealtopts_default"
  [ "${mysql_fileprefix+X}" = "" ] && mysql_fileprefix="$mysql_fileprefix_default"
  [ "${mysql_subdirprefix+X}" = "" ] && mysql_subdirprefix="$mysql_subdirprefix_default"
  # PostgreSQL
  [ "${postgres_pwfile+X}" = "" ] && postgres_pwfile="$postgres_pwfile_default"
  [ "$postgres_connectdb" = "" ] && postgres_connectdb="$postgres_connectdb_default"
  [ "$postgres_dbmode" = "" ] && postgres_dbmode="$postgres_dbmode_default"
  [ "$postgres_splitdbs" = "" ] && postgres_splitdbs="$postgres_splitdbs_default"
  arrayisunset "postgres_dumponeoptions" && \
      copyarray "postgres_dumponeoptions_default" "postgres_dumponeoptions"
  arrayisunset "postgres_dumpalloptions" && \
      copyarray "postgres_dumpalloptions_default" "postgres_dumpalloptions"
  [ "$postgres_usealtopts" = "" ] && postgres_usealtopts="$postgres_usealtopts_default"
  [ "${postgres_fileprefix+X}" = "" ] && postgres_fileprefix="$postgres_fileprefix_default"
  [ "${postgres_subdirprefix+X}" = "" ] && postgres_subdirprefix="$postgres_subdirprefix_default"
}

#
# validate the configuration settings
#
# adjusts/blanks some settings based on others; e.g.:
# - host/port -> localhost/localport when using tunnels
# - ignore socketfile when using TCP
#
# also un-sparses arrays to be on the safe side
#
# (in the notes below, [dbms] = all of the members of $dbmslist)
#
# "local" vars: dbms
# global vars: dbmslist, dbms_*, some of tun_*
# config settings: (most of them)
# library functions: validnoblank(), validnoblankarr(), validnotbothblank(),
#                    validnum(), validnochar(), validlist(), validrwxdir(),
#                    validcreate(), validreadfile(), validrwfile(),
#                    validfunction(), copyvar(), unsparsearray()
# utilities: [
# files: $startedfile, $lockfile, $alertfile, $outputlog, $statuslog,
#        $rsync_sshkeyfile, $rsync_pwfile, $rsync_filterfile,
#        $[dbms]_sshkeyfile, $[dbms]_socketfile, $[dbms]_pwfile,
#        $[dbms]_dumpdir
# bashisms: printf -v [v3.1]
#
validconf () {
  # housekeeping
  #
  # note: umask could be symbolic, not going to try to parse it
  validlist "timecomptype" "find" "date-r" "date-d" "awk" "gawk"
  validlist "debugme" "yes" "no"
  validlist "on_tunerr" "phase" "exit"
  validlist "on_dbreplerr" "phase" "exit"
  validlist "on_dblisterr" "phase" "exit"
  validlist "on_dbnameerr" "db" "phase" "exit"
  validlist "on_dbduplerr" "ignore" "warn" "db" "phase" "exit"
  validlist "on_dbdumperr" "db" "phase" "exit"
  validlist "on_dbziperr" "db" "phase" "exit"

  # checks and logging
  validnum "runevery"
  validcreate "startedfile" "file"
  validcreate "lockfile" "dir"
  validnum "ifrunning"
  validcreate "alertfile" "file"
  validlist "suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    validnoblank "mailto"
    validnoblank "subject"
  fi
  if [ "$outputlog" != "" ]; then
    validcreate "outputlog" "file" "rotate"
    validlist "outputlog_layout" "append" "number" "date"
    validnochar "outputlog_sep" "/"
    validnochar "outputlog_date" "/"
    if [ "$outputlog_layout" != "append" ]; then
      validnum "numlogs"
      validnum "dayslogs"
    fi
    if [ "$outputlog_layout" = "date" ] && [ "$numlogs" != "0" ]; then
      sendalert "warning: outputlog_layout=date; ignoring non-0 numlogs" log
      setexitval "$startup_exitval"
    fi
  fi
  validlist "usesyslog" "yes" "no"
  validlist "quiet" "yes" "no"
  [ "$statuslog" != "" ] && validcreate "statuslog" "file"

  # rsync, including SSH tunnel
  validlist "do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    validlist "rsync_mode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsync_mode" = "tunnel" ]; then
      validnoblank "rsync_sshhost"
      validnoblank "rsync_localhost"
      validnum "rsync_localport" 1 65535
      validnoblank "rsync_remotehost"
      validnum "rsync_remoteport" 1 65535
      validnum "rsync_sshtimeout" 1
      # use the local port for rsync_port
      rsync_port="$rsync_localport"
    fi
    if [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "nodaemon" ]; then
      [ "$rsync_sshkeyfile" != "" ] && validreadfile "rsync_sshkeyfile"
      [ "$rsync_sshport" != "" ] && validnum "rsync_sshport" 1 65535
      unsparsearray "rsync_sshoptions"
    fi
    validnoblankarr "rsync_source"
    unsparsearray "rsync_source"
    validnoblank "rsync_dest"
    if [ "$rsync_mode" = "direct" ]; then
      [ "$rsync_port" != "" ] && validnum "rsync_port" 1 65535
    fi
    { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
        [ "$rsync_pwfile" != "" ] && validreadfile "rsync_pwfile"
    [ "$rsync_filterfile" != "" ] && validreadfile "rsync_filterfile"
    unsparsearray "rsync_options"
    unsparsearray "rsync_add"
  fi

  # DBMS dumps, including SSH tunnels
  for dbms in $dbmslist; do
    switchdbms "$dbms"
    switchtunnel "$dbms" "$dbms dumps"

    # note: lines like
    #   validlist "${dbms}_dodump" "yes" "no"
    # are passing, e.g., "mysql_dodump",
    # but lines like
    #   if [ "$dbms_dodump" = "yes" ]; then
    # are referencing the dbms_dodump variable...

    # mirror all changes to the ${dbms}_ vars in the dbms_ vars, in case
    # we need them further down (and on principle); same with tun_

    validlist "${dbms}_dodump" "yes" "no"
    if [ "$dbms_dodump" = "yes" ]; then
      # account for differences between DBMSs, e.g.:
      #   -= settings that aren't available for all DBMSes
      #   -= settings that work differently for different DBMSes
      #   -= stuff that would complicate the tests below
      case "$dbms" in
        mysql)
          [ "$mysql_replstatus" != "" ] && validnum "mysql_replstatus"
          ;;

        postgres)
          # this can be blank and still work in _some_ cases, but we're
          # just going to require it
          validnoblank "postgres_connectdb"

          # PostgreSQL can't dump multiple DBs at once
          [ "$postgres_splitdbs" = "no" ] && [ "$postgres_dbmode" != "all" ] && \
              throwstartuperr "Error: postgres_splitdbs may only be 'no' if postgres_dbmode is 'all'; exiting."
          ;;
      esac

      validlist "${dbms}_usetunnel" "yes" "no"
      if [ "$dbms_usetunnel" = "yes" ]; then
        validnoblank "${dbms}_sshhost"
        [ "$tun_sshkeyfile" != "" ] && validreadfile "${dbms}_sshkeyfile"
        [ "$tun_sshport" != "" ] && validnum "${dbms}_sshport" 1 65535
        validnoblank "${dbms}_localhost"
        validnum "${dbms}_localport" 1 65535
        validnoblank "${dbms}_remotehost"
        validnum "${dbms}_remoteport" 1 65535
        validnum "${dbms}_sshtimeout" 1
        unsparsearray "${dbms}_sshoptions"
        unsparsearray "tun_sshoptions"
        # adjust/ignore these
        printf -v "${dbms}_host" "%s" "$tun_localhost"
        dbms_host="$tun_localhost"
        copyvar "${dbms}_localport" "${dbms}_port"
        copyvar "${dbms}_localport" "dbms_port"
        printf -v "${dbms}_socketfile" "%s" ""
        dbms_socketfile=""
      else
        if [ "$dbms_host" != "" ]; then  # nothing to validate, but...
          # ignore socketfile
          printf -v "${dbms}_socketfile" "%s" ""
          dbms_socketfile=""
        fi
        if [ "$dbms_port" != "" ]; then
          validnum "${dbms}_port" 1 65535
          # ignore socketfile
          printf -v "${dbms}_socketfile" "%s" ""
          dbms_socketfile=""
        fi
        [ "$dbms_socketfile" != "" ] && validrwfile "${dbms}_socketfile"
      fi  # if [ "$dbms_usetunnel" = "yes" ]
      [ "$dbms_pwfile" != "" ] && validreadfile "${dbms}_pwfile"
      validlist "${dbms}_dbmode" "all" "include" "exclude"
      unsparsearray "${dbms}_dblist"
      unsparsearray "dbms_dblist"
      validlist "${dbms}_splitdbs" "yes" "no"
      unsparsearray "${dbms}_options"
      unsparsearray "dbms_options"
      unsparsearray "${dbms}_dumpoptions"
      unsparsearray "dbms_dumpoptions"
      unsparsearray "${dbms}_dumponeoptions"
      unsparsearray "dbms_dumponeoptions"
      unsparsearray "${dbms}_dumpmultoptions"
      unsparsearray "dbms_dumpmultoptions"
      unsparsearray "${dbms}_dumpalloptions"
      unsparsearray "dbms_dumpalloptions"
      validlist "${dbms}_usealtopts" "yes" "no"
      [ "$dbms_usealtopts" = "yes" ] && validfunction "${dbms}_altopts"
      validrwxdir "${dbms}_dumpdir"
      validlist "${dbms}_layout" "single" "number" "date" "singledir" \
                "numberdir" "datedir"
      [ "$dbms_splitdbs" = "no" ] && [ "$dbms_layout" != "date" ] && \
          validnotbothblank "${dbms}_fileprefix" "${dbms}_filesuffix"
      validnochar "${dbms}_fileprefix" "/"
      validnochar "${dbms}_fileprefix" "$newline"
      validnochar "${dbms}_filesuffix" "/"
      validnochar "${dbms}_filesuffix" "$newline"
      { [ "$dbms_layout" = "singledir" ] || [ "$dbms_layout" = "numberdir" ]; } && \
          validnoblank "${dbms}_subdirprefix"
      validnochar "${dbms}_subdirprefix" "/"
      validnochar "${dbms}_subdirprefix" "$newline"
      validnochar "${dbms}_filedirsep" "/"
      validnochar "${dbms}_filedirsep" "$newline"
      validnochar "${dbms}_filedirdate" "/"
      validnochar "${dbms}_filedirdate" "$newline"
      if [ "$dbms_layout" != "single" ] && [ "$dbms_layout" != "singledir" ]; then
        validnum "${dbms}_numfiles"
        validnum "${dbms}_daysfiles"
      fi
      if { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; } && \
         [ "$dbms_numfiles" != "0" ]; then
        sendalert "warning: ${dbms}_layout=$dbms_layout; ignoring non-0 ${dbms}_numfiles" log
        setexitval "$startup_exitval"
      fi
      validlist "${dbms}_zipmode" "none" "gzip" "pigz" "bzip2" "lzip" "xz"
      unsparsearray "${dbms}_zipoptions"
      unsparsearray "dbms_zipoptions"
      validlist "${dbms}_preserve" "data" "space"
      validlist "${dbms}_useaftereach" "yes" "no"
      [ "$dbms_useaftereach" = "yes" ] && validfunction "${dbms}_aftereach"
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist
}


###########################
# core functions: DB dumps
###########################

#
# run a command to dump a single database to stdout
#
# (may not be possible with all DBMSes; see also dbdumpmultcmd(),
# dbdumpallcmd())
#
# $1 is the name of the database to dump
#
# dbms_prefix must be one of the accepted values (see dbmslist),
# but not all of them will necessarily work; see the code
#
# when using an SSH tunnel, set host to localhost (or 127.0.0.1/::1/etc.
# as necessary) and port to the local port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# altopts and [dbms]_dumpoptions/[dbms]_dumponeoptions/etc. must be indexed,
# non-sparse arrays
#
# "local" vars: opts_l
# global vars: dbms_prefix, altopts
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile, [dbms]_splitdbs,
#                  [dbms]_dumpoptions/[dbms]_dumponeoptions/etc. (depending
#                  on the DBMS), [dbms]_usealtopts
# config functions: [dbms]_altopts()
# library functions: copyarray()
# utilities: mysqldump, pg_dump, [
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumponecmd () {
  case "$dbms_prefix" in
    mysql)
      if [ "$mysql_splitdbs" = "yes" ] && \
         [ "$mysql_usealtopts" = "yes" ] && mysql_altopts "$1"; then
        copyarray "altopts" "opts_l" exact
      else
        copyarray "mysql_dumpoptions" "opts_l" exact
      fi

      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${opts_l+"${opts_l[@]}"} \
        "$1"
      ;;
    postgres)
      if [ "$postgres_splitdbs" = "yes" ] && \
         [ "$postgres_usealtopts" = "yes" ] && postgres_altopts "$1"; then
        copyarray "altopts" "opts_l" exact
      else
        copyarray "postgres_dumponeoptions" "opts_l" exact
      fi

      PGPASSFILE=${postgres_pwfile:+"$postgres_pwfile"} \
      pg_dump \
        ${postgres_user:+-U "$postgres_user"} \
        ${postgres_host:+-h "$postgres_host"} \
        ${postgres_port:+-p "$postgres_port"} \
        ${opts_l+"${opts_l[@]}"} \
        "$1"
      ;;
  esac
}

#
# run a command to dump multiple databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpallcmd())
#
# the names of the databases to dump must be in the dbnames array
#
# dbms_prefix must be one of the accepted values (see dbmslist),
# but not all of them will necessarily work; see the code
#
# when using an SSH tunnel, set host to localhost (or 127.0.0.1/::1/etc.
# as necessary) and port to the local port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# dbnames and [dbms]_dumpoptions/[dbms]_dumpmultoptions/etc. must be indexed,
# non-sparse arrays
#
# global vars: dbnames, dbms_prefix, internal_exitval
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile,
#                  [dbms]_dumpoptions/[dbms]_dumpmultoptions/etc. (depending
#                  on the DBMS)
# library vars: newline
# library functions: sendalert(), do_exit()
# utilities: mysqldump
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumpmultcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${mysql_dumpoptions+"${mysql_dumpoptions[@]}"} \
        -B "${dbnames[@]}"
      ;;
    postgres)
      sendalert "Internal Error: PostgreSQL cannot dump multiple DBs at once; exiting${newline}-> THERE IS A BUG IN THE SCRIPT! <-" log
      do_exit "$internal_exitval"
      ;;
  esac
}

#
# run a command to dump all databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpmultcmd())
#
# dbms_prefix must be one of the accepted values (see dbmslist),
# but not all of them will necessarily work; see the code
#
# when using an SSH tunnel, set host to localhost (or 127.0.0.1/::1/etc.
# as necessary) and port to the local port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# [dbms]_dumpoptions/[dbms]_dumpalloptions/etc. must be indexed, non-sparse
# arrays
#
# global vars: dbms_prefix
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile,
#                  [dbms]_dumpoptions/[dbms]_dumpalloptions/etc. (depending
#                  on the DBMS)
# utilities: mysqldump, pg_dumpall
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumpallcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${mysql_dumpoptions+"${mysql_dumpoptions[@]}"} \
        -A
      ;;
    postgres)
      PGPASSFILE=${postgres_pwfile:+"$postgres_pwfile"} \
      pg_dumpall \
        ${postgres_user:+-U "$postgres_user"} \
        ${postgres_host:+-h "$postgres_host"} \
        ${postgres_port:+-p "$postgres_port"} \
        ${postgres_dumpalloptions+"${postgres_dumpalloptions[@]}"}
      ;;
  esac
}

#
# check if the DBMS is lagging too far in replication
#
# can be used to not dump old data, or to let the DBMS catch up before
# performing dumps which might make it even further behind
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# dbms_prefix must be one of the accepted values (see dbmslist),
# but not all of them will necessarily work; see the code
#
# "local" vars: replexit, replval
# global vars: dbms_prefix, dbms_replstatus, replstatus, dbrepl_exitval,
#              internal_exitval
# config settings: lockfile, on_dbreplerr
# library vars: newline
# library functions: dbcmd(), logstatusquiet(), logstatus(), sendalert(),
#                    do_exit(), setexitval()
# utilities: rm, grep, sed, printf, [
# files: $lockfile/${dbms_prefix}-$replstatus
# FDs: 3
#
checkdbmsrepl () {
  # remove any existing file, to prevent both confusion and noclobber-type
  # issues
  rm -f "$lockfile/${dbms_prefix}-$replstatus"

  # do we need to check?
  case "$dbms_prefix" in
    mysql)
      if [ "$dbms_replstatus" = "" ]; then
        logstatus "${dbms_prefix}_replstatus is null; not checking replication status"
        return 0
      fi
      ;;
    postgres)
      # don't know how to do this yet, may not be possible
      return 0
      ;;
  esac

  # log that we're running the command
  logstatusquiet "running $dbms_prefix replication-status command"
  printf "%s\n" "running $dbms_prefix replication-status command" >&3

  # run the command
  case "$dbms_prefix" in
    mysql)
      # note no -BN
      dbcmd 'SHOW SLAVE STATUS\G' > "$lockfile/${dbms_prefix}-$replstatus" 2>&3
      replexit="$?"
      ;;
    postgres)
      :  # do nothing; not reached
      ;;
  esac

  # check status
  if [ "$replexit" != "0" ]; then
    case "$on_dbreplerr" in
      exit)
        sendalert "could not get the replication status of the $dbms_prefix DBMS (status code $replexit); exiting" log
        do_exit "$getdbrepl_exitval"
        ;;
      phase)
        sendalert "could not get the replication status of the $dbms_prefix DBMS (status code $replexit);${newline}skipping $dbms_prefix dumps" log
        setexitval "$getdbrepl_exitval"
        return 1  # skip to the next phase
        ;;
    esac
  else
    logstatus "obtained the replication status of the $dbms_prefix DBMS"
  fi

  # extract the actual information
  case "$dbms_prefix" in
    mysql)
      replval=$(grep "Seconds_Behind_Master" \
                "$lockfile/${dbms_prefix}-$replstatus" | sed 's/.*: //')

      # is it even acting as a replication slave?
      # -> slave configured but down?
      if [ "$replval" = "NULL" ]; then
        sendalert "warning: $dbms_prefix DBMS is configured as a replication slave but is not${newline}actually replicating, and ${dbms_prefix}_replstatus is set;${newline}continuing with $dbms_prefix dumps" log
        return 0
      fi

      # -> not configured as a slave?
      #
      # use extra [0-9] to avoid having to use egrep
      if printf "%s\n" "$replval" | \
           grep -v '^[0-9][0-9]*$' >/dev/null 2>&1; then
        sendalert "warning: $dbms_prefix DBMS is not acting as a replication slave, but ${dbms_prefix}_replstatus is set;${newline}continuing with $dbms_prefix dumps" log
        return 0
      fi

      # check against threshold
      if [ "$replval" -gt "$dbms_replstatus" ]; then
        case "$on_dbreplerr" in
          exit)
            logstatus "$dbms_prefix Seconds_Behind_Master ($replval) is greater than ${dbms_prefix}_replstatus ($dbms_replstatus); exiting"
            do_exit "$no_error_exitval"
            ;;
          phase)
            logstatus "$dbms_prefix Seconds_Behind_Master ($replval) is greater than ${dbms_prefix}_replstatus ($dbms_replstatus);${newline}skipping $dbms_prefix dumps"
            return 1  # skip to the next phase
            ;;
        esac
      else
        logstatus "$dbms_prefix Seconds_Behind_Master ($replval) is less than or equal to ${dbms_prefix}_replstatus ($dbms_replstatus); continuing"
      fi
      ;;

    postgres)
      :  # do nothing; not reached
      ;;
  esac

  return 0
}

#
# get the list of all DBs if necessary
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# dbms_prefix must be one of the accepted values (see dbmslist)
#
# "local" vars: listexit
# global vars: dbms_prefix, dbms_dbmode, dbms_splitdbs, alldbs,
#              getdblist_exitval
# config settings: lockfile, on_dblisterr
# library vars: newline
# library functions: dblistcmd(), logstatusquiet(), logstatus(), sendalert(),
#                    do_exit(), setexitval()
# utilities: rm, printf, [
# files: $lockfile/${dbms_prefix}-$alldbs
# FDs: 3
#
getdblist () {
  # remove any existing file, to prevent both confusion and noclobber-type
  # issues
  rm -f "$lockfile/${dbms_prefix}-$alldbs"

  # do we need the list?
  case "$dbms_prefix" in
    # use dbms_ vars in case we need to lump DBMSes together
    mysql|postgres)
      if { [ "$dbms_dbmode" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
         || \
         [ "$dbms_dbmode" = "exclude" ]; then
        :  # avoid non-portable 'if !'
      else
        return 0
      fi
      ;;
  esac

  # log that we're running the command
  logstatusquiet "running $dbms_prefix get-DB-list command"
  printf "%s\n" "running $dbms_prefix get-DB-list command" >&3

  # run the command
  dblistcmd > "$lockfile/${dbms_prefix}-$alldbs" 2>&3
  listexit="$?"

  # check status
  if [ "$listexit" != "0" ]; then
    case "$on_dblisterr" in
      exit)
        sendalert "could not get the list of $dbms_prefix databases (status code $listexit); exiting" log
        do_exit "$getdblist_exitval"
        ;;
      phase)
        sendalert "could not get the list of $dbms_prefix databases (status code $listexit);${newline}skipping $dbms_prefix dumps" log
        setexitval "$getdblist_exitval"
        return 1  # skip to the next phase
        ;;
    esac
  else
    logstatus "obtained the list of $dbms_prefix databases"
  fi

  return 0
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary (including rotation)
#
# this populates two sets of path variables: one for the dump, with a place
# for the DB name, and one for the rotation/pruning, with a place for the
# number/date (and a place for the DB name, if $dbms_layout is not a "dir"
# option)
#
# note that for "number"/"numberdir" layouts, dumpprefix and dumpsuffix omit
# the number, because the most recent version is unnumbered
#
# mkdir -p isn't portable, so subdirectories must be directly under the
# dumpdir (until/unless we emulate it...)
#
# global vars: dumpprefix, dumpsuffix, rotateprefix, rotatesep,
#              rotatesuffix, dbms_splitdbs, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_datestring
# utilities: mkdir, [
#
getdumppaths () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
      else
        rotatesep="$dbms_filedirsep"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
        dumpsuffix="$dbms_datestring$dbms_filesuffix"
      else
        rotatesep="$dbms_filedirsep"
        dumpsuffix="$dbms_filedirsep$dbms_datestring$dbms_filesuffix"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    singledir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    numberdir)
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
      rotatesep="$dbms_filedirsep"
      rotatesuffix=""

      # rotate the subdirectories because the last one would be in the way
      rotatenumfiles "$rotateprefix" "$rotatesep" "$rotatesuffix"

      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      ;;
    datedir)
      if [ "$dbms_subdirprefix" = "" ]; then
        [ ! -d "$dbms_dumpdir/$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/"
        rotatesep=""
      else
        [ ! -d "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep"
        dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
        rotatesep="$dbms_filedirsep"
      fi
      dumpsuffix="$dbms_filesuffix"
      rotatesuffix=""
      ;;
  esac
}

#
# do a single DB dump pass, including file rotation, etc.
# (one pass = one dump command, but may be more than one DB)
#
# $1 is "one", "mult", or "all" (how many DBs to dump; see dbdumponecmd(),
# dbdumpmultcmd(), dbdumpallcmd())
#
# if $1 is "one", $2 is the name of the database to dump
# if $1 is "mult", the names of the databases to dump must be in the dbnames
# array
#
# returns 1 to mean "skip to the next phase of the backup",
# 2 to mean "we have skipped this dump",
# else 0
#
# see getdumppaths() for info about dumpprefix/dumpsuffix
#
# dbnames and dbms_zipoptions must be indexed, non-sparse arrays
#
# "local" vars: dumptype, dbname, fileexists, dumpexit, zipexit
# global vars: dbnames, dumptmp, dumpprefix, dumpsuffix, rotateprefix,
#              rotatesep, rotatesuffix, dbms_prefix, dbms_layout,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dumpexists_exitval, dbdump_exitval,
#              dbzip_exitval
# config settings: on_duplerr, on_dbdumperr, on_dbziperr
# library vars: newline
# library functions: rotatenumfiles(), prunefiles(), existsfilezip(),
#                    removefilezip(), dbdumponecmd(), dbdumpmultcmd(),
#                    dbdumpallcmd(), sendalert(), logstatus(),
#                    logstatusquiet(), do_exit(), setexitval()
# utilities: (allowed values of $dbms_zipmode), rm, mv, date, printf, [
# FDs: 3
# bashisms: arrays
#
do_dbdump () {
  dumptype="$1"
  dbname="$2"  # will be null unless $1 is "one"

  # check for problematic characters in the DB name,
  # if it's going to be part of a filename
  #
  # /  causes problems with the dump (interpreted as directory delim)
  # \n causes problems with rotation in number mode; we'll disallow it
  #    in general to be on the safe side
  #
  if [ "$dumptype" = "one" ] && \
     [ "$(printf "%sX\n" "$dbname" | tr -d '/\n')" != "${dbname}X" ]; then
    case "$on_dbnameerr" in
      exit)
        sendalert "$dbms_prefix database name '$dbname' contains a problematic character; exiting" log
        do_exit "$dbname_exitval"
        ;;
      phase)
        sendalert "$dbms_prefix database name '$dbname' contains a problematic character;${newline}skipping $dbms_prefix dumps" log
        setexitval "$dbname_exitval"
        return 1  # skip to the next phase
        ;;
      db)
        sendalert "$dbms_prefix database name '$dbname' contains a problematic character;${newline}skipping this database" log
        setexitval "$dbname_exitval"
        return 2  # skip to the next DB
        ;;
    esac
  fi

  # rotate if we need to, to make way for the new dump
  [ "$dbms_layout" = number ] && \
    rotatenumfiles "$rotateprefix$dbname" "$rotatesep" "$rotatesuffix"

  # are we (still) about to overwrite an existing dump?
  fileexists="no"
  if [ "$dbms_layout" != "single" ] \
     && \
     [ "$dbms_layout" != "singledir" ] \
     && \
     existsfilezip "$dumpprefix$dbname$dumpsuffix" "$dbms_zipmode"; then
    fileexists="yes"
  fi

  if [ "$fileexists" = "yes" ]; then
    case "$on_dbduplerr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists; exiting" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; exiting" log
        fi
        do_exit "$dumpexists_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists;${newline}skipping $dbms_prefix dumps" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists;${newline}skipping $dbms_prefix dumps" log
        fi
        setexitval "$dumpexists_exitval"
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists;${newline}skipping this database" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists;${newline}skipping this dump" log
        fi
        setexitval "$dumpexists_exitval"
        return 2  # skip to the next DB
        ;;
      warn)
        if [ "$dbname" != "" ]; then
          sendalert "warning: dumpfile for $dbms_prefix database '$dbname' already exists; overwriting" log
        else
          sendalert "warning: dumpfile for $dbms_prefix database(s) already exists; overwriting" log
        fi
        setexitval "$dumpexists_exitval"
        ;;
      ignore)
        :  # do nothing
        ;;
    esac
  fi

  # clean up ("space" preservation mode; see below)
  if [ "$dbms_preserve" = "space" ]; then
    # prune old dumpfiles (non-"dir" layouts)
    case "$dbms_layout" in
      number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac

    # remove any current dumpfile that's in the way, including zips
    # ("single"/"singledir", or from, e.g., rerunning the backup)
    removefilezip "$dumpprefix$dbname$dumpsuffix" "$dbms_zipmode"
  fi

  # if we're dumping a single database, log the name
  if [ "$dbname" != "" ]; then
    logstatus "dumping $dbms_prefix database '$dbname'"
  fi

  # log that we're running the command
  if [ "$dbname" != "" ]; then
    logstatusquiet "running $dbms_prefix dump command for database '$dbname'"
    printf "%s\n" "running $dbms_prefix dump command for database '$dbname'" >&3
  else
    logstatusquiet "running $dbms_prefix dump command"
    printf "%s\n" "running $dbms_prefix dump command" >&3
  fi

  # starting timestamp
  printf "%s\n" "$dbms_prefix dump started $(date)" >&3

  # run the command
  case "$dbms_preserve" in
    data)
      rm -f "$dumpprefix$dbname$dumpsuffix$dumptmp"  # safer for >
      case "$dumptype" in
        one)
          dbdumponecmd "$dbname" > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
          ;;
        mult)
          # uses dbnames array
          dbdumpmultcmd > "$dumpprefix$dumpsuffix$dumptmp" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dumpsuffix$dumptmp" 2>&3
          ;;
      esac
      ;;
    space)
      case "$dumptype" in
        one)
          dbdumponecmd "$dbname" > "$dumpprefix$dbname$dumpsuffix" 2>&3
          ;;
        mult)
          # uses dbnames array
          dbdumpmultcmd > "$dumpprefix$dumpsuffix" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dumpsuffix" 2>&3
          ;;
      esac
      ;;
  esac
  dumpexit="$?"

  # check status
  if [ "$dumpexit" != "0" ]; then
    case "$on_dbdumperr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname' (status code $dumpexit); exiting" log
        else
          sendalert "error dumping $dbms_prefix database(s) (status code $dumpexit); exiting" log
        fi
        do_exit "$dbdump_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname' (status code $dumpexit);${newline}skipping $dbms_prefix dumps" log
        else
          sendalert "error dumping $dbms_prefix database(s) (status code $dumpexit);${newline}skipping $dbms_prefix dumps" log
        fi
        setexitval "$dbdump_exitval"
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname' (status code $dumpexit);${newline}skipping this database" log
        else
          sendalert "error dumping $dbms_prefix database(s) (status code $dumpexit);${newline}skipping this dump" log
        fi
        setexitval "$dbdump_exitval"
        return 2  # skip to the next DB
        ;;
    esac
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped $dbms_prefix database '$dbname'"
    else
      logstatus "successfully dumped $dbms_prefix database(s)"
    fi
  fi

  # ending timestamp
  printf "%s\n" "$dbms_prefix dump finished $(date)" >&3

  # clean up ("data" preservation mode; see above)
  if [ "$dbms_preserve" = "data" ]; then
    # remove current dumpfile (including zips),
    # and move the temp file into place
    #
    # only really need the zip part of this, since we use mv -f
    removefilezip "$dumpprefix$dbname$dumpsuffix" "$dbms_zipmode"
    mv -f "$dumpprefix$dbname$dumpsuffix$dumptmp" \
          "$dumpprefix$dbname$dumpsuffix"

    # prune old dumpfiles (non-"dir" layouts")
    case "$dbms_layout" in
      number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac
  fi

  # zip current dumpfile
  #
  # wait until after pruning; we use less total space during the backup
  # process, and don't sacrifice any data preservation gain
  if [ "$dbms_zipmode" != "none" ]; then
    # first print size before zip; hard to do portably, so just print
    # all the metadata
    logstatus "file size (and other metadata) before compression:${newline}$(getfilemetadata "$dumpprefix$dbname$dumpsuffix")"

    # starting timestamp
    printf "%s\n" "$dbms_zipmode started $(date)" >&3

    # do the zip
    "$dbms_zipmode" "${dbms_zipoptions[@]}" \
                    "$dumpprefix$dbname$dumpsuffix" >&3 2>&1
    zipexit="$?"

    # check status
    if [ "$zipexit" != "0" ]; then
      case "$on_dbziperr" in
        exit)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname' (status code $dumpexit); exiting" log
          else
            sendalert "error compressing $dbms_prefix database(s) (status code $dumpexit); exiting" log
          fi
          do_exit "$dbzip_exitval"
          ;;
        phase)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname' (status code $dumpexit);${newline}skipping $dbms_prefix dumps" log
          else
            sendalert "error compressing $dbms_prefix database(s) (status code $dumpexit);${newline}skipping $dbms_prefix dumps" log
          fi
          setexitval "$dbzip_exitval"
          return 1  # skip to the next phase
          ;;
        db)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname' (status code $dumpexit);${newline}skipping this database" log
          else
            sendalert "error compressing $dbms_prefix database(s) (status code $dumpexit);${newline}skipping this dump" log
          fi
          setexitval "$dbzip_exitval"
          return 2  # skip to the next DB
          ;;
      esac
    else
      if [ "$dbname" != "" ]; then
        logstatus "successfully compressed $dbms_prefix database '$dbname'"
      else
        logstatus "successfully compressed $dbms_prefix database(s)"
      fi
    fi
    # ending timestamp
    printf "%s\n" "$dbms_zipmode finished $(date)" >&3
  fi

  return 0
}

#
# wrapper around do_dbdump, to handle aftereach functions
#
# (yes, another layer of wrappers - it was easier, and easier to read, than
# modifying all the exits from do_dbdump())
#
# has the same parameters and return values as do_dbdump()
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# "local" vars: dodumpexit
# global vars: dbms_prefix, dbms_useaftereach
# config functions: [dbms]_aftereach()
# library functions: logstatus()
# utilities: [
#
do_dbdump_wrapper () {
  do_dbdump "$1" "$2"
  dodumpexit="$?"

  if [ "$dbms_useaftereach" = "yes" ]; then
    logstatus "running user-supplied ${dbms_prefix}_aftereach() function"
    "${dbms_prefix}_aftereach" "$2" "$dodumpexit"
    logstatus "${dbms_prefix}_aftereach() complete"
  fi

  return "$dodumpexit"
}

#
# handle the different modes of DB dumps
# (split/unsplit, all/include/exclude)
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# dbms_dblist must be an indexed, non-sparse array
#
# "local" vars: OLDIFS, dbname_esc, dbname, exclude
# global vars: IFS, dbnames, dbms_prefix, dbms_dbmode, dbms_dblist,
#              dbms_splitdbs, alldbs
# config settings: lockfile
# library functions: copyarray(), dbunescape()
# utilities: [
# files: $lockfile/${dbms_prefix}-$alldbs
# bashisms: arrays, array+=() [v3.1]
#
do_dbdumploop () {
  OLDIFS="$IFS"

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbmode" in
      all)
        do_dbdump_wrapper "all"

        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      include)
        copyarray "dbms_dblist" "dbnames" exact

        do_dbdump_wrapper "mult"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      exclude)
        dbnames=()
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/${dbms_prefix}-$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          for exclude in "${dbms_dblist[@]}"; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done

          dbnames+=("$dbname")
          IFS=""
        done < "$lockfile/${dbms_prefix}-$alldbs"
        IFS="$OLDIFS"

        do_dbdump_wrapper "mult"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
    esac  # case "$dbms_dbmode"
  else  # dbms_splitdbs="yes"
    case "$dbms_dbmode" in
      all)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/${dbms_prefix}-$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          do_dbdump_wrapper "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase

          IFS=""
        done < "$lockfile/${dbms_prefix}-$alldbs"
        IFS="$OLDIFS"
        ;;
      include)
        for dbname in "${dbms_dblist[@]}"; do
          do_dbdump_wrapper "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
        done
        ;;
      exclude)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/${dbms_prefix}-$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          for exclude in "${dbms_dblist[@]}"; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done

          do_dbdump_wrapper "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase

          IFS=""
        done < "$lockfile/${dbms_prefix}-$alldbs"
        IFS="$OLDIFS"
       ;;
    esac  # case "$dbms_dbmode"
  fi  # if [ "$dbms_splitdbs" = "no" ]

  return 0
}


##########################################
# command line and configuration settings
##########################################

configfile=""
noconfigfile="no"
mode=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    -f)
      shift
      if [ "$#" = "0" ]; then
        throwusageerr "Error: -f requires a config-file path; exiting."
      else
        configfile="$1"
        noconfigfile="no"
        shift
      fi
      ;;
    -n)
      noconfigfile="yes"
      configfile=""
      shift
      ;;
    *)
      #mode="${1#--}"
      # slower but more portable
      mode=$(printf "%s\n" "$1" | sed 's/^--//')
      shift
      ;;
  esac
done

validlist "mode" "" "help" "usage" "license" "config" "settings" \
          "status" "statusall" "silence" "unsilence" "stop" "disable" \
          "start" "enable" "clearlock" "unlock" "create" "systemtest"

# first deal with the modes that don't require sourcing the config file
# or dealing with settings
case "$mode" in
  help|usage)
    # print the usage message
    usage
    do_exit "$no_error_exitval"
    ;;
  license)
    # print the license message
    license
    do_exit "$no_error_exitval"
    ;;
  create)
    # print or create a blank config file
    createblankconfig "# see $sampleconfigfile for details"
    if [ "$?" = "1" ]; then
      throwusageerr "Error: specified config file already exists; exiting."
    else
      do_exit "$no_error_exitval"
    fi
    ;;
esac

# process command-line settings and the config file
do_config

# debug mode?
# (in case it was turned on in the config file, but not on the command line;
# see above)
if [ "$debugme" = "yes" ]; then
  do_debug
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$mode" in
  config|settings)
    # print the current config settings
    echo
    printconfig
    echo
    do_exit "$no_error_exitval"
    ;;
  status|statusall)
    # print the current status
    echo
    if [ "$mode" = "statusall" ]; then  # include temp files
      printstatus all
    else
      printstatus
    fi
    echo
    do_exit "$no_error_exitval"
    ;;
  silence)
    # silence lockfile-exists alerts
    silencelfalerts
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    unsilencelfalerts
    ;;
  stop|disable)
    # disable backups
    disablescript "a" "backup" "backups"
    ;;
  start|enable)
    # re-enable backups
    enablescript "a" "backup" "backups"
    ;;
  clearlock|unlock)
    # remove lockfile dir
    clearlock "a" "backup"
    ;;
  systemtest)
    # check for external utilities in the PATH
    checkextcmds
    do_exit "$no_error_exitval"
    ;;
esac

# log config file, current working directory, and setting variables supplied
# on the command line
logclconfig


################
# status checks
################

checkstatus "backup" "backups"


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for the current DB-dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      dbms_datestring=$(date "$dbms_filedirdate")
    else
      dbms_datestring=$(date)
    fi
    printf -v "${dbms}_datestring" "%s" "$dbms_datestring"
  fi
done

# output log datestring is included in startoutputlog(), called below


###################
# start output log
###################

startoutputlog  # includes getting output log datestring


################
# begin working
################

# log starting messages and timestamp, and touch $startedfile
do_start "backup"

# are we supposed to actually do anything?
do_something="no"  # set this to yes later if we do something


###########
# DB dumps
###########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_dbms () {
  if [ "$dbms_usetunnel" = "yes" ]; then
    closesshtunnel
  fi
}

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    do_something="yes"

    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms" "$dbms dumps"
      opensshtunnel
      [ "$?" = "1" ] && { skip_dbms; continue; }  # skip to the next phase
    fi

    # check the DBMS replication status if necessary
    checkdbmsrepl
    [ "$?" = "1" ] && { skip_dbms; continue; }  # skip to the next phase

    # get the list of all DBs if necessary
    getdblist
    [ "$?" = "1" ] && { skip_dbms; continue; }  # skip to the next phase

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary (including rotation)
    getdumppaths

    # prune old files ("dir" layouts, "space" preservation mode; see below)
    if [ "$dbms_preserve" = "space" ]; then
      case "$dbms_layout" in
        numberdir|datedir)
          prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                     "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
          ;;
      esac
    fi

    # do the actual dump(s)
    do_dbdumploop
    [ "$?" = "1" ] && { skip_dbms; continue; }  # skip to the next phase

    # prune old files ("dir" layouts, "data" preservation mode; see above)
    if [ "$dbms_preserve" = "data" ]; then
      case "$dbms_layout" in
        numberdir|datedir)
          prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                     "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
          ;;
      esac
    fi

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_rsync () {
  # close the SSH tunnel
  if [ "$rsync_mode" = "tunnel" ]; then
    closesshtunnel
  fi
}

while true; do  # only here to allow us to easily skip to the next phase
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    logstatus "starting rsync backup sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync" "rsync backup"
      opensshtunnel
      [ "$?" = "1" ] && { skip_rsync; break; }  # skip to the next phase
    fi

    # log that we're running the command
    logstatusquiet "running rsync command"
    printf "%s\n" "running rsync command" >&3

    # starting timestamp
    printf "%s\n" "rsync started $(date)" >&3

    # run the command
    rsynccmd >&3 2>&1
    rsyncexit="$?"

    # check status
    case "$rsyncexit" in
      0)
        logstatus "rsync completed without errors"
        ;;
      24|25)
        sendalert "warning: rsync finished with errors (status code $rsyncexit); please check the log" log
        setexitval "$rsync_exitval"
        ;;
      *)
        sendalert "error running rsync (status code $rsyncexit)" log
        setexitval "$rsync_exitval"
    esac

    # ending timestamp
    printf "%s\n" "rsync finished $(date)" >&3

    # close the SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      closesshtunnel
    fi

    logstatus "rsync backup sequence completed"
  fi

  break  # don't actually loop
done


###############
# done working
###############

# did we actually do anything?
if [ "$do_something" = "no" ]; then  # everything was turned off
  logstatus "nothing to do, because no actions are turned on"
fi

# log finished messages and timestamp
do_finish "backup"


##################
# stop output log
##################

stopoutputlog


###########
# clean up
###########

do_exit "$no_error_exitval"
