#!/bin/sh

#######################################################################
# Aeolus
# a portable, super-configurable database dump and rsync backup script
# by Daniel Malament
# see license() for license info
#######################################################################

# see usage() and the usage and sample config files for usage notes

# exit values:
#   0  = no error (e.g., runevery hasn't expired, or backup was completed
#        without errors)
#   1  = problem with the script invocation, the config file, or a setting
#        (also used in command modes like 'disable' as a generic error value)
#   2  = previous lockfile still exists (possibly because backups were
#        manually disabled)
#   3  = error finding a delimiter for a string
#   4  = error opening SSH tunnel
#   5  = error getting DB list
#   6  = problem with contents of DB list (e.g., unsafe characters)
#   7  = DB dumpfile already exists
#   8  = error dumping DB
#   9  = error compressing DB dump
#   10 = rsync error
# if there are multiple errors, the first one to occur is used

# modification notes:
#
# if the ext values above are changed, update the *_exitval variables, below
#
# lockfile dir is used for the following files:
#   $silencealerts, $disable, $timetemp, $logfifo, $alldbs, $alldbstmp
# all files should be in printstatus()
#
# any change to the setting variables (additions, deletions, name changes,
# type changes, etc.) must be reflected in: the sample config file,
# $configsettings, the default settings section, some of switch*()
# [possibly], applydefaults() [probably], and validconf()
#
# all commands used should be listed in $externalcmds and the usage notes
#
# adding a DBMS:
#   add vars to the sample config file, modeling after MySQL (but split up
#     *_dump*options if necessary)
#   add vars to the relevant variables/functions (see above)
#   add to dblistcmd(), dbdump*cmd(), needdblist()
#   add to dbmslist
#   add to usage notes on installation and portability
#
# see notes in the hardcoded variables section for other things that should
# be kept in sync (e.g., the name of the script and $scriptname, the values
# of the defaults and the comments in the sample config file, etc.)

# TODO:
# prune dated files by number
#
# better handling of long errors?
# i18n?
# setup modes?
# emulate mkdir -p?
# pathological cases in getparentdir()?
# squeeze // in parentdir() output?
# strange test problems in validcreate()?
# actually parse vars on cl, in config file?
# queue sendalert()s for non-fatal messages (e.g., skipping many DB dumps)?
# globbing in dblist?

# do more to protect against leading - in settings?

# to test:
# mysql
# ssh key with ports
# all do_exit (val, clean)
# dblist in file
# alt opts
# better command-line option handling, e.g., wrt "-" for no config file
# create clean conf
# cl length limit - incl. $configsettings
# what if re-run? - incl. if zip
# stop on errors?
# when skipping to next phase, have to do cleanup/logging
# pigz
# echo -> printf
# config, status, systemtest modes, and mail alerts
# validnochar
# esc, seddelim funcs and uses
# sed \t



. /root/backup/aeolus-lib.sh




############
# debugging
############

#
# turn on debugging
#
do_debug () {
  set -vx
}

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
#
# however, this only applies if debugging is turned on on the command line;
# see also below
if [ "$debugme" = "yes" ]; then
  do_debug
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# name of the script, as reported by usage(), etc.
# change this if you rename the script file
scriptname="aeolus"

# external commands used (potentially)
#
# some things can probably be omitted, like 'set' and 'command';
# they should always be builtins, and anyway, by the time we try to
# test them...
#
externalcmds="
  rsync
  ssh
  nc
  mysql
  mysqldump
  gzip
  pigz
  bzip2
  lzip
  date
  hostname
  logger
  mailx
  grep
  awk
  gawk
  sed
  tr
  [
  expr
  echo
  printf
  cat
  tee
  ls
  find
  diff
  cmp
  touch
  mv
  rm
  mkdir
  mkfifo
  pwd
  kill
  sleep
"

# default path to the config file, if one isn't specified
# change usage notes if you change this
defaultconfigfile="/etc/aeolus/aeolus.conf"

# names of all config file settings
configsettings="
  usepath
  useumask
  timecomptype
  filecomptype
  debugme
  on_ssherr
  on_dblisterr
  on_dbcharerr
  on_dbduplerr
  on_dumperr
  on_ziperr
  runevery
  startedfile
  ifrunning
  lockfile
  suppressemail
  mailto
  subject
  alertfile
  outputlog
  outputlog_layout
  outputlog_sep
  outputlog_date
  numlogs
  dayslogs
  usesyslog
  syslogstat
  syslogerr
  syslogtag
  quiet
  statuslog
  rsync_sshuser
  rsync_sshhost
  rsync_sshkeyfile
  rsync_sshport
  rsync_localport
  rsync_remoteport
  rsync_sshoptions
  rsync_sshtimeout
  do_rsync
  rsync_mode
  rsync_source
  rsync_dest
  rsync_port
  rsync_pwfile
  rsync_filterfile
  rsync_options
  rsync_add
  mysql_dodump
  mysql_usetunnel
  mysql_sshuser
  mysql_sshhost
  mysql_sshkeyfile
  mysql_sshport
  mysql_localport
  mysql_remoteport
  mysql_sshoptions
  mysql_sshtimeout
  mysql_user
  mysql_pwfile
  mysql_protocol
  mysql_host
  mysql_port
  mysql_socket
  mysql_dbmode
  mysql_dbs
  mysql_splitdbs
  mysql_clientoptions
  mysql_dumpoptions
  mysql_altmode
  mysql_alts
  mysql_dumpdir
  mysql_layout
  mysql_fileprefix
  mysql_filesuffix
  mysql_subdirprefix
  mysql_filedirsep
  mysql_filedirdate
  mysql_numfiles
  mysql_daysfiles
  mysql_zipmode
  mysql_zipoptions
  mysql_preserve
"

#
# default settings
#
# change comments in sample config file if you change these
#

# default settings: housekeeping
timecomptype_default="find"
filecomptype_default="cmp"
debugme_default="no"
on_ssherr_default="phase"
on_dblisterr_default="phase"
on_dbcharerr_default="phase"
on_dbduplerr_default="db"
on_dumperr_default="db"
on_ziperr_default="db"

# default settings: checks and logging
runevery_default="0"
startedfile_default="/var/run/aeolus/started"
ifrunning_default="120"  # 2 hours
lockfile_default="/var/run/aeolus/lock"
suppressemail_default="no"
if command -v hostname > /dev/null 2>&1; then
  mailto_default="root@$(hostname)"
  subject_default="Aeolus alert on $(hostname)"
else
  mailto_default="root@localhost"
  subject_default="Aeolus alert"
fi
#alertfile_default="$lockfile.alert"  # set it later, after lockfile
outputlog_default="/var/log/aeolus-output.log"  # only if unset
outputlog_layout_default="number"
outputlog_sep_default="."  # only if unset
outputlog_date_default="+%Y%m%d"  # only if unset
numlogs_default="0"
dayslogs_default="7"
usesyslog_default="yes"
quiet_default="no"
statuslog_default="/var/log/aeolus.log"  # only if unset

# default settings: SSH tunnels (all)
rsync_localport_default="8873"
rsync_remoteport_default="873"
mysql_localport_default="4306"
mysql_remoteport_default="3306"
sshtimeout_default="15"  # applies to all SSH tunnels

# default settings: rsync
do_rsync_default="no"
rsync_mode_default="tunnel"
rsync_pwfile_default="/etc/aeolus/rsync.pw"  # only if unset

# default settings: DBMSes (all; see also below)
dbms_dodump_default="no"
dbms_usetunnel_default="no"
dbms_dumpdir_default="."
dbms_layout_default="date"
dbms_filesuffix_default=".sql"  # only if unset
dbms_filedirsep_default="-"  # only if unset
dbms_filedirdate_default="+%Y%m%d"  # only if unset
dbms_numfiles_default="0"
dbms_daysfiles_default="7"
dbms_zipmode_default="gzip"
dbms_preserve_default="data"

# default settings: MySQL (see also above)
mysql_pwfile_default="/etc/aeolus/mysql.pw"  # only if unset
mysql_dbmode_default="all"
mysql_splitdbs_default="no"
mysql_dumpoptions_default="--opt -Q -R -c"  # only if unset
mysql_altmode_default="none"
mysql_fileprefix_default="mysqldump"  # only if unset
mysql_subdirprefix_default="mysqldump"  # only if unset

# settings that have no default, and can't be blank
# (but may be ignored, depending on other settings)
#
# *_sshhost
# rsync_source
# rsync_dest
# *_dbs
# *_alts (if in "file" mode)

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
#
# removing a DBMS from this list will effectively disable it
dbmslist="mysql"

# names of tempfiles stored in the lockfile directory
disable="disable"
silencealerts="silencealerts"
timetemp="timetemp"
logfifo="logfifo"
alldbs="alldbs"
alldbstmp="alldbs.tmp"

# extension to use for temporary dumpfiles
dumptmp=".tmp"

# exit values; see top of script for details
# (and keep numbers in sync when modifying)
no_error_exitval="0"
startup_exitval="1"
lockfile_exitval="2"
nodelim_exitval="3"
sshtunnel_exitval="4"
getdblist_exitval="5"
dblistchar_exitval="6"
dumpexists_exitval="7"
dbdump_exitval="8"
dbzip_exitval="9"
rsync_exitval="10"


#################################
# helper functions: housekeeping
#################################

#
# cleanup function, to be called by do_exit()
#
#   * closes any open SSH tunnel
#   * removes the lockfile, unless the disable semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: sshpid, lockfile, disable
# library funcs: closesshtunnel()
# utilities: rm, [
# files: lockfile, disable
#
do_exit_cleanup () {
  if [ "$sshpid" != "" ]; then
    closesshtunnel
  fi

  if [ ! -f "$lockfile/$disable" ]; then
    rm -r "$lockfile"
  fi
  # otherwise, a disable command must have been run while we were
  # doing this backup; leave the lockfile dir alone, so future backups
  # will be disabled
}


#######################################
# helper functions: logging and alerts
#######################################

#
# print diagnostics, for sendalert()
#
# must not be called until after printstatus() is defined
#
# library funcs: printconfig()
# utilities: cat
#
sendalert_body () {
  cat <<-EOF


	$(printconfig)


	$(printstatus all)
	EOF
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g., "rsync" or a member of
# $dbmslist)
#
# global vars: tun_prefix, tun_sshuser, tun_sshhost, tun_sshkeyfile,
#              tun_sshport, tun_localport, tun_remoteport, tun_sshoptions,
#              tun_sshtimeout
# config settings: *_sshuser, *_sshhost, *_sshkeyfile, *_sshport,
#                  *_localport, *_remoteport, *_sshoptions, *_sshtimeout
#
switchtunnel () {
  tun_prefix="$1"
  eval "tun_sshuser=\"\$$(printf "%s" "$1")_sshuser\""
  eval "tun_sshhost=\"\$$(printf "%s" "$1")_sshhost\""
  eval "tun_sshkeyfile=\"\$$(printf "%s" "$1")_sshkeyfile\""
  eval "tun_sshport=\"\$$(printf "%s" "$1")_sshport\""
  eval "tun_localport=\"\$$(printf "%s" "$1")_localport\""
  eval "tun_remoteport=\"\$$(printf "%s" "$1")_remoteport\""
  eval "tun_sshoptions=\"\$$(printf "%s" "$1")_sshoptions\""
  eval "tun_sshtimeout=\"\$$(printf "%s" "$1")_sshtimeout\""
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# global vars: *_datestring, dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socket,
#              dbms_dbmode, dbms_dbs, dbms_splitdbs, dbms_clientoptions,
#              dbms_dumpoptions, dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_altmode, dbms_alts, dbms_dumpdir,
#              dbms_layout, dbms_fileprefix, dbms_filesuffix,
#              dbms_subdirprefix, dbms_filedirsep, dbms_filedirdate,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dbms_datestring
# config settings: *_dodump, *_usetunnel, *_user, *_pwfile, *_protocol,
#                  *_host, *_port, *_socket, *_dbmode, *_dbs, *_splitdbs,
#                  *_clientoptions, *_dumpoptions, *_dumponeoptions,
#                  *_dumpmultoptions, *_dumpalloptions, *_altmode, *_alts,
#                  *_dumpdir, *_layout, *_fileprefix, *_subdirprefix,
#                  *_filedirsep, *_filedirdate, *_numfiles, *_daysfiles,
#                  *_zipmode, *_zipoptions, *_preserve
#
switchdbms () {
  dbms_prefix="$1"
  eval "dbms_dodump=\"\$$(printf "%s" "$1")_dodump\""
  eval "dbms_usetunnel=\"\$$(printf "%s" "$1")_usetunnel\""
  eval "dbms_user=\"\$$(printf "%s" "$1")_user\""
  eval "dbms_pwfile=\"\$$(printf "%s" "$1")_pwfile\""
  eval "dbms_protocol=\"\$$(printf "%s" "$1")_protocol\""
  eval "dbms_host=\"\$$(printf "%s" "$1")_host\""
  eval "dbms_port=\"\$$(printf "%s" "$1")_port\""
  eval "dbms_socket=\"\$$(printf "%s" "$1")_socket\""
  eval "dbms_dbmode=\"\$$(printf "%s" "$1")_dbmode\""
  eval "dbms_dbs=\"\$$(printf "%s" "$1")_dbs\""
  eval "dbms_splitdbs=\"\$$(printf "%s" "$1")_splitdbs\""
  eval "dbms_clientoptions=\"\$$(printf "%s" "$1")_clientoptions\""
  eval "dbms_dumpoptions=\"\$$(printf "%s" "$1")_dumpoptions\""
  eval "dbms_dumponeoptions=\"\$$(printf "%s" "$1")_dumponeoptions\""
  eval "dbms_dumpmultoptions=\"\$$(printf "%s" "$1")_dumpmultoptions\""
  eval "dbms_dumpalloptions=\"\$$(printf "%s" "$1")_dumpalloptions\""
  eval "dbms_altmode=\"\$$(printf "%s" "$1")_altmode\""
  eval "dbms_alts=\"\$$(printf "%s" "$1")_alts\""
  eval "dbms_dumpdir=\"\$$(printf "%s" "$1")_dumpdir\""
  eval "dbms_layout=\"\$$(printf "%s" "$1")_layout\""
  eval "dbms_fileprefix=\"\$$(printf "%s" "$1")_fileprefix\""
  eval "dbms_filesuffix=\"\$$(printf "%s" "$1")_filesuffix\""
  eval "dbms_subdirprefix=\"\$$(printf "%s" "$1")_subdirprefix\""
  eval "dbms_filedirsep=\"\$$(printf "%s" "$1")_filedirsep\""
  eval "dbms_filedirdate=\"\$$(printf "%s" "$1")_filedirdate\""
  eval "dbms_numfiles=\"\$$(printf "%s" "$1")_numfiles\""
  eval "dbms_daysfiles=\"\$$(printf "%s" "$1")_daysfiles\""
  eval "dbms_zipmode=\"\$$(printf "%s" "$1")_zipmode\""
  eval "dbms_zipoptions=\"\$$(printf "%s" "$1")_zipoptions\""
  eval "dbms_preserve=\"\$$(printf "%s" "$1")_preserve\""
  # internal, not from config
  eval "dbms_datestring=\"\$$(printf "%s" "$1")_datestring\""
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# global vars: scriptname, defaultconfigfile
# utilities: cat
#
usage () {
  # not necessarily reliable/consistent, switched to static global
  # (see hardcoded vars)
  #scriptname=$(printf "%s\n" "$0" | sed 's|^.*/||')

  cat <<EOF 1>&2

Usage:

  [ setting="value" ] $scriptname [ -f /path/to/config/file | -n ] [ mode ]

  Multiple settings can be added to the command line, separated by spaces;
  command-line settings override the config file.

Options:

  -f /path/to/config/file: supply the path to the config file
  -n: use no config file
  The last-supplied of -f and -n will be used.
  If neither option is supplied, "$defaultconfigfile" will be tried.

Modes:

  Modes can have a leading '--'; e.g., '--help' (omit the quotes).
  If multiple modes are given, the last one is used.

  Available modes and their effects:

  "help" or "usage": this message is printed

  "license": a license message is printed

  "config" or "settings": the current config settings are printed

  "status": the current status, including timestamps, is printed
  "statusall": temp files mainly relevant for debugging are also included

  "silence": alerts about the lockfile existing are silenced until
  either they are unsilenced, or the lockfile is no longer present

  "unsilence": alerts about the lockfile existing are re-enabled

  "stop" or "disable": backups are disabled until "start" or "enable"
  is used

  "start" or "enable": backups are re-enabled

  "clearlock" or "unlock": the lockfile is forcibly removed; only use this
  if you're sure a backup isn't currently running!

  "create": a config file template is printed (all settings, in logical
  order, commented out so that the default values will be used unless
  otherwise specified); if -f is also given, the config file is output to
  the supplied path, but only if the file does not already exist

  "systemtest": diagnostics are printed about the system's support for
  the script (i.e., what utilities are present in the current PATH)

EOF
}

#
# print a license message to stderr
#
# utilities: cat
#
license () {
  cat <<EOF 1>&2

Copyright 2011 Daniel Malament.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
}

#
# print the current status, including file timestamps, etc.
#
# if $1 is "all", include timestamps for temp files that are only really
# relevant for debugging
#
# doesn't print surrounding blank lines; add them if necessary in context
#
# global vars: silencealerts, disable, timetemp, logfifo, alldbs, alldbstmp
# config settings: startedfile, alertfile, lockfile
# library funcs: getfilemetadata()
# utilities: cat, echo, [
# files: startedfile, alertfile, lockfile, silencealerts, disable, timetemp,
#        logfifo, alldbs, alldbstmp
#
printstatus () {
  cat <<-EOF
	-------
	Status:
	-------

	EOF

  if [ ! -f "$startedfile" ]; then  # -e isn't portable
    echo "no last-started file; this backup appears to have never been run"
  fi
  if [ -d "$lockfile" ]; then
    echo "lockfile directory exists; a backup may be in progress"
  else
    echo "no lockfile directory found; backups enabled but not in progress"
  fi
  if [ -f "$alertfile" ]; then
    echo "alertfile exists; running backup prevented new one from starting"
  fi
  if [ -f "$lockfile/$silencealerts" ]; then
    echo "lockfile alerts have been silenced"
  fi
  if [ -f "$lockfile/$disable" ]; then
    echo "backups have been disabled (but the last one may still be running)"
  fi

  cat <<-EOF


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	$(getfilemetadata "$startedfile")

	lockfile:
	$(getfilemetadata "$lockfile")

	alertfile:
	$(getfilemetadata "$alertfile")

	silencealerts:
	$(getfilemetadata "$lockfile/$silencealerts")

	disable:
	$(getfilemetadata "$lockfile/$disable")
	EOF

  if [ "$1" = "all" ]; then
    cat <<-EOF

	[temp files below this line, mainly relevant for debugging]

	timetemp:
	$(getfilemetadata "$lockfile/$timetemp")

	logfifo:
	$(getfilemetadata "$lockfile/$logfifo")

	alldbs:
	$(getfilemetadata "$lockfile/$alldbs")

	alldbstmp:
	$(getfilemetadata "$lockfile/$alldbstmp")
	EOF
  fi
}

#
# apply default settings where applicable
#
# global vars: (setting _defaults)
# config settings: (most of them)
# utilities: [
#
applydefaults () {
  # housekeeping
  [ "$timecomptype" = "" ] && timecomptype="$timecomptype_default"
  [ "$filecomptype" = "" ] && filecomptype="$filecomptype_default"
  [ "$debugme" = "" ] && debugme="$debugme_default"
  [ "$on_ssherr" = "" ] && on_ssherr="$on_ssherr_default"
  [ "$on_dblisterr" = "" ] && on_dblisterr="$on_dblisterr_default"
  [ "$on_dbcharerr" = "" ] && on_dbcharerr="$on_dbcharerr_default"
  [ "$on_dbduplerr" = "" ] && on_dbduplerr="$on_dbduplerr_default"
  [ "$on_dumperr" = "" ] && on_dumperr="$on_dumperr_default"
  [ "$on_ziperr" = "" ] && on_ziperr="$on_ziperr_default"

  # checks and logging
  [ "$runevery" = "" ] && runevery="$runevery_default"
  [ "$startedfile" = "" ] && startedfile="$startedfile_default"
  [ "$ifrunning" = "" ] && ifrunning="$ifrunning_default"
  [ "$lockfile" = "" ] && lockfile="$lockfile_default"
  [ "$suppressemail" = "" ] && suppressemail="$suppressemail_default"
  [ "$mailto" = "" ] && mailto="$mailto_default"
  [ "$subject" = "" ] && subject="$subject_default"
  [ "$alertfile" = "" ] && alertfile="$lockfile.alert"  # late-binding default
  [ "${outputlog+X}" = "" ] && outputlog="$outputlog_default"
  [ "$outputlog_layout" = "" ] && outputlog_layout="$outputlog_layout_default"
  [ "${outputlog_sep+X}" = "" ] && outputlog_sep="$outputlog_sep_default"
  [ "${outputlog_date+X}" = "" ] && outputlog_date="$outputlog_date_default"
  [ "$numlogs" = "" ] && numlogs="$numlogs_default"
  [ "$dayslogs" = "" ] && dayslogs="$dayslogs_default"
  [ "$usesyslog" = "" ] && usesyslog="$usesyslog_default"
  [ "$quiet" = "" ] && quiet="$quiet_default"
  [ "${statuslog+X}" = "" ] && statuslog="$statuslog_default"

  # SSH tunnels (individual and global defaults)
  [ "$rsync_localport" = "" ] && rsync_localport="$rsync_localport_default"
  [ "$rsync_remoteport" = "" ] && rsync_remoteport="$rsync_remoteport_default"
  [ "$mysql_localport" = "" ] && mysql_localport="$mysql_localport_default"
  [ "$mysql_remoteport" = "" ] && mysql_remoteport="$mysql_remoteport_default"
  # global
  [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="$sshtimeout_default"
  [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="$sshtimeout_default"

  # rsync
  [ "$do_rsync" = "" ] && do_rsync="$do_rsync_default"
  [ "$rsync_mode" = "" ] && rsync_mode="$rsync_mode_default"
  [ "${rsync_pwfile+X}" = "" ] && rsync_pwfile="$rsync_pwfile_default"

  # DBMSes (global defaults; see also below)
  [ "$mysql_dodump" = "" ] && mysql_dodump="$dbms_dodump_default"
  [ "$mysql_usetunnel" = "" ] && mysql_usetunnel="$dbms_usetunnel_default"
  [ "$mysql_dumpdir" = "" ] && mysql_dumpdir="$dbms_dumpdir_default"
  [ "$mysql_layout" = "" ] && mysql_layout="$dbms_layout_default"
  [ "${mysql_filesuffix+X}" = "" ] && mysql_filesuffix="$dbms_filesuffix_default"
  [ "${mysql_filedirsep+X}" = "" ] && mysql_filedirsep="$dbms_filedirsep_default"
  [ "${mysql_filedirdate+X}" = "" ] && mysql_filedirdate="$dbms_filedirdate_default"
  [ "$mysql_numfiles" = "" ] && mysql_numfiles="$dbms_numfiles_default"
  [ "$mysql_daysfiles" = "" ] && mysql_daysfiles="$dbms_daysfiles_default"
  [ "$mysql_zipmode" = "" ] && mysql_zipmode="$dbms_zipmode_default"
  [ "$mysql_preserve" = "" ] && mysql_preserve="$dbms_preserve_default"

  # DBMSes (individual defaults; see also above)
  [ "${mysql_pwfile+X}" = "" ] && mysql_pwfile="$mysql_pwfile_default"
  [ "$mysql_dbmode" = "" ] && mysql_dbmode="$mysql_dbmode_default"
  [ "$mysql_splitdbs" = "" ] && mysql_splitdbs="$mysql_splitdbs_default"
  [ "${mysql_dumpoptions+X}" = "" ] && mysql_dumpoptions="$mysql_dumpoptions_default"
  [ "$mysql_altmode" = "" ] && mysql_altmode="$mysql_altmode_default"
  [ "${mysql_fileprefix+X}" = "" ] && mysql_fileprefix="$mysql_fileprefix_default"
  [ "${mysql_subdirprefix+X}" = "" ] && mysql_subdirprefix="$mysql_subdirprefix_default"
}

#
# validate the configuration settings
#
# "local" vars: dbms
# global vars: dbmslist
# config settings: (all except usepath, useumask, outputlog_sep,
#              outputlog_date, syslogtag, *_sshuser, *_sshoptions,
#              rsync_options, rsync_add,
#              [DBMS]: *_user, *_protocol, *_clientoptions, *_dumpoptions,
#              *_dumponeoptions, *_dumpmultoptions, *_dumpalloptions,
#              *_filedirsep, *_filedirdate, *_zipoptions)
# library funcs: validnoblank(), validnotbothblank(), validnum(),
#                validnochar(), validrwxdir(), validcreate(),
#                validreadfile(), validrwfile(), validlist()
# utilities: [
#
validconf () {
  # housekeeping
  #
  # note: umask could be symbolic in some shells, not going to try to
  # parse it
  validlist "timecomptype" "find" "date-r" "date-d" "awk" "gawk"
  validlist "filecomptype" "cmp" "diff"
  validlist "debugme" "yes" "no"
  validlist "on_ssherr" "phase" "exit"
  validlist "on_dblisterr" "phase" "exit"
  validlist "on_dbcharerr" "phase" "exit"
  validlist "on_dbduplerr" "ignore" "warn" "db" "phase" "exit"
  validlist "on_dumperr" "db" "phase" "exit"
  validlist "on_ziperr" "db" "phase" "exit"

  # checks and logging
  validnum "runevery"
  validcreate "startedfile" "file"
  validnum "ifrunning"
  validcreate "lockfile" "dir"
  validlist "suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    validnoblank "mailto"
    validnoblank "subject"
  fi
  validcreate "alertfile" "file"
  if [ "$outputlog" != "" ]; then
    validcreate "outputlog" "file" "rotate"
    validlist "outputlog_layout" "append" "number" "date"
    validnochar "outputlog_sep" "/"
    validnochar "outputlog_date" "/"
    if [ "$outputlog_layout" != "append" ]; then
      validnum "numlogs"
      validnum "dayslogs"
    fi
  fi
  validlist "usesyslog" "all" "yes" "no"
  validlist "quiet" "yes" "no"
  [ "$statuslog" != "" ] && validcreate "statuslog" "file"

  # rsync, including SSH tunnel
  validlist "do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    validlist "rsync_mode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsync_mode" = "tunnel" ]; then
      validnoblank "rsync_sshhost"
      validnum "rsync_localport" 1 65535
      validnum "rsync_remoteport" 1 65535
      validnum "rsync_sshtimeout" 1
    fi
    if [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "nodaemon" ]; then
      [ "$rsync_sshkeyfile" != "" ] && validreadfile "rsync_sshkeyfile"
      [ "$rsync_sshport" != "" ] && validnum "rsync_sshport" 1 65535
    fi
    validnoblank "rsync_source"
    validnoblank "rsync_dest"
    if [ "$rsync_mode" = "direct" ]; then
      [ "$rsync_port" != "" ] && validnum "rsync_port" 1 65535
    fi
    { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
        [ "$rsync_pwfile" != "" ] && validreadfile "rsync_pwfile"
    [ "$rsync_filterfile" != "" ] && validreadfile "rsync_filterfile"
  fi

  # DBMS dumps, including SSH tunnels
  for dbms in $dbmslist; do
    switchdbms "$dbms"
    switchtunnel "$dbms"

    # note: lines like
    #   validlist "${dbms}_dodump" "yes" "no"
    # are passing, e.g., "mysql_dodump",
    # but lines like
    #   if [ "$dbms_dodump" = "yes" ]; then
    # are referencing the dbms_dodump variable...

    validlist "${dbms}_dodump" "yes" "no"
    if [ "$dbms_dodump" = "yes" ]; then
      validlist "${dbms}_usetunnel" "yes" "no"
      if [ "$dbms_usetunnel" = "yes" ]; then
        validnoblank "${dbms}_sshhost"
        [ "$tun_sshkeyfile" != "" ] && validreadfile "${dbms}_sshkeyfile"
        [ "$tun_sshport" != "" ] && validnum "${dbms}_sshport" 1 65535
        validnum "${dbms}_localport" 1 65535
        validnum "${dbms}_remoteport" 1 65535
        validnum "${dbms}_sshtimeout" 1
        # ignore these
        eval "$(printf "%s" "$dbms")_host=\"localhost\""
        eval "$(printf "%s" "$dbms")_port=\"${dbms}_localport\""
        eval "$(printf "%s" "$dbms")_socket=\"\""
        # also change the dbms_* variables, for completeness
        dbms_host="localhost"
        dbms_port="${dbms}_localport"
        dbms_socket=""
      else
        if [ "$dbms_host" != "" ]; then  # nothing to validate, but...
          # ignore socket
          eval "$(printf "%s" "$dbms")_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        if [ "$dbms_port" != "" ]; then
          validnum "${dbms}_port" 1 65535
          # ignore socket
          eval "$(printf "%s" "$dbms")_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        [ "$dbms_socket" != "" ] && validrwfile "${dbms}_socket"
      fi  # if [ "$dbms_usetunnel" = "yes" ]
      [ "$dbms_pwfile" != "" ] && validreadfile "${dbms}_pwfile"
      validlist "${dbms}_dbmode" "all" "include" "exclude" "includefile" \
                                 "excludefile"
      [ "$dbms_dbmode" != "all" ] && validnoblank "${dbms}_dbs"
      validlist "${dbms}_splitdbs" "yes" "no"
      validlist "${dbms}_altmode" "none" "list" "file"
      [ "$dbms_altmode" = "file" ] && validreadfile "${dbms}_alts"
      validrwxdir "${dbms}_dumpdir"
      validlist "${dbms}_layout" "single" "number" "date" "singledir" \
                "numberdir" "datedir"
      [ "$dbms_splitdbs" = "no" ] && [ "$dbms_layout" != "date" ] && \
          validnotbothblank "${dbms}_fileprefix" "${dbms}_filesuffix"
      validnochar "${dbms}_fileprefix" "/"
      validnochar "${dbms}_filesuffix" "/"
      { [ "$dbms_layout" = "singledir" ] || [ "$dbms_layout" = "numberdir" ]; } && \
          validnoblank "${dbms}_subdirprefix"
      validnochar "${dbms}_subdirprefix" "/"
      validnochar "${dbms}_filedirsep" "/"
      validnochar "${dbms}_filedirdate" "/"
      if [ "$dbms_layout" != "single" ] && [ "$dbms_layout" != "singledir" ]; then
        validnum "${dbms}_numfiles"
        validnum "${dbms}_daysfiles"
      fi
      validlist "${dbms}_zipmode" "none" "gzip" "pigz" "bzip2" "lzip"
      validlist "${dbms}_preserve" "data" "space"
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist
}


###########################
# core functions: DB dumps
###########################

#
# check if dbdumponecmd() should be using alternate options
#
# $1 is the name of the database to dump
#
# "local" vars: OLDIFS, dbname, altline_esc, altdb_esc, altopts_esc, altdb
# global vars: IFS, dbms_altmode, dbms_alts, altopts
# library vars: newline, tab
# library funcs: dbunescape()
# utilities: printf, sed, [
#
checkusealtopts () {
  OLDIFS="$IFS"
  dbname="$1"

  case "$dbms_altmode" in
    none)
      return 1  # false
      ;;
    list)
      IFS="$newline"
      for altline_esc in $(printf "%s" "$dbms_alts"); do
        IFS="$OLDIFS"
        # \t isn't portable in sed
        altdb_esc=$(printf "%s\n" "$altline_esc" | sed "s/$tab.*\$//")
        altopts_esc=$(printf "%s\n" "$altline_esc" | sed "s/^.*$tab//")
        altdb=$(dbunescape "$altdb_esc")
        altopts=$(dbunescape "$altopts_esc")
        if [ "$dbname" = "$altdb" ]; then
          return 0  # true
        fi
        IFS="$newline"
      done
      IFS="$OLDIFS"
      return 1  # false
      ;;
    file)
      IFS=""
      while read -r altline_esc; do  # < "$dbms_alts"
        IFS="$OLDIFS"
        # \t isn't portable in sed
        altdb_esc=$(printf "%s\n" "$altline_esc" | sed "s/$tab.*\$//")
        altopts_esc=$(printf "%s\n" "$altline_esc" | sed "s/^.*$tab//")
        altdb=$(dbunescape "$altdb_esc")
        altopts=$(dbunescape "$altopts_esc")
        if [ "$dbname" = "$altdb" ]; then
          return 0  # true
        fi
        IFS=""
      done < "$dbms_alts"
      IFS="$OLDIFS"
      return 1  # false
      ;;
  esac
}

#
# run a command to dump a single database to stdout
#
# (may not be possible with all DBMSes; see also dbdumpmultcmd(),
# dbdumpallcmd())
#
# $1 is the name of the database to dump
#
# "local" vars: opts_l
# global vars: dbms_prefix, altopts
# config settings: *_user, *_pwfile, *_protocol, *_host, *_port, *_socket,
#                  *_dumpoptions/*_dumponeoptions/etc. (depending on DBMS)
# utilities: mysqldump, [
#
dbdumponecmd () {
  case "$dbms_prefix" in
    mysql)
      if checkusealtopts "$1"; then
        opts_l="$altopts"
      else
        opts_l="$mysql_dumpoptions"
      fi

      # --defaults-extra-file must be the first option if present
      # note no " on opts_l
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socket:+-S "$mysql_socket"} \
        ${opts_l:+$opts_l} \
        "$1"
      ;;
  esac
}

#
# run a command to dump multiple databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpallcmd())
#
# $1 is a string containing the names of the databases to dump (names
#    containing spaces must be sub-quoted (e.g., '... "foo bar" ...' or
#    "... \"foo bar\" ..."))
#
# global vars: dbms_prefix
# config settings: *_user, *_pwfile, *_protocol, *_host, *_port, *_socket,
#                  *_dumpoptions/*_dumpmultoptions/etc. (depending on DBMS)
# utilities: mysqldump
#
dbdumpmultcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      # note no " on mysql_dumpoptions, $1
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socket:+-S "$mysql_socket"} \
        ${mysql_dumpoptions:+$mysql_dumpoptions} \
        -B $1
      ;;
  esac
}

#
# run a command to dump all databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpmultcmd())
#
# global vars: dbms_prefix
# config settings: *_user, *_pwfile, *_protocol, *_host, *_port, *_socket,
#                  *_dumpoptions/*_dumpalloptions/etc. (depending on DBMS)
# utilities: mysqldump
#
dbdumpallcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      # note no " on mysql_dumpoptions
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socket:+-S "$mysql_socket"} \
        ${mysql_dumpoptions:+$mysql_dumpoptions} \
        -A
      ;;
  esac
}

#
#
# get the list of all DBs if necessary
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# global vars: dbms_prefix, dbms_dbmode, dbms_splitdbs, lockfile, alldbs,
#              alldbstmp, getdblist_exitval, dblistchar_exitval
# config settings: on_dblisterr, on_dbcharerr
# library vars: newline, tab
# library funcs: dblistcmd(), filecomp(), logstatusquiet(), logstatus(),
#                sendalert(), do_exit()
# utilities: rm, tr, printf, [
# files: alldbs, alldbstmp
# FDs: 3
#
getdblist () {
  # do we need the list?
  case "$dbms_prefix" in
    # use dbms_ vars in case we need to lump DBMSes together
    mysql)
      if { [ "$dbms_dbmode" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
         || \
         [ "$dbms_dbmode" = "exclude" ]; then
        :  # avoid non-portable 'if !'
      else
        return 0
      fi
      ;;
  esac

  # remove any existing file, to prevent noclobber-type issues
  rm -f "$lockfile/$alldbs"

  # log that we're running the command
  logstatusquiet "running $dbms_prefix get-DB-list command"
  printf "%s\n" "running $dbms_prefix get-DB-list command" >&3

  # run the command
  dblistcmd > "$lockfile/$alldbs" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    sendalert "could not get the list of $dbms_prefix databases; exiting" log
    case "$on_dblisterr" in
      exit)
        do_exit "$getdblist_exitval"
        ;;
      phase)
        return 1  # skip to the next phase
        ;;
    esac
  else
    logstatus "obtained the list of $dbms_prefix databases"
  fi

  # separate this by DBMS in case some have different output formats,
  # but most can probably be lumped together;
  # however, they all need to be massaged into the same format:
  # DB names separated by newlines, with these encodings:
  # newline -> \n
  # tab -> \t
  # \ -> \\

  case "$dbms_prefix" in
    mysql)
      # check for characters that could break out of a quoted string,
      # or drop things into one
      #
      # could be done more simply with egrep/grep -E, but this way is
      # probably more portable
      rm -f "$lockfile/$alldbstmp"  # to prevent noclobber-type issues
      tr -d "'\"\`$" < "$lockfile/$alldbs" \
                     > "$lockfile/$alldbstmp"
      if filecomp "$lockfile/$alldbs" "$lockfile/$alldbstmp"; then
        :  # avoid non-portable 'if !'
      else  # cover both mismatch and error
        sendalert "the list of $dbms_prefix databases contains a dangerous character; exiting" log
        case "$on_dbcharerr" in
          exit)
            do_exit "$dblistchar_exitval"
            ;;
          phase)
            return 1  # skip to the next phase
            ;;
        esac
      fi
      ;;
  esac

  return 0
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary
#
# this populates two sets of path variables: one for the dump, with a place
# for the DB name, and one for the rotation/pruning, with a place for the
# number/date (and the DB name, if $dbms_layout is not a "dir" option)
#
# note that for "number"/"numberdir" layouts, dumpprefix and dumpsuffix omit
# the number, because the most recent version is unnumbered
#
# mkdir -p isn't portable, so subdirectories must be directly under the
# dumpdir (until/unless we emulate it...)
#
# global vars: dumpprefix, dumpsuffix, rotateprefix, rotatesep,
#              rotatesuffix, dbms_splitdbs, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_datestring
# utilities: mkdir, [
#
getdumppaths () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
      else
        rotatesep="$dbms_filedirsep"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
        dumpsuffix="$dbms_datestring$dbms_filesuffix"
      else
        rotatesep="$dbms_filedirsep"
        dumpsuffix="$dbms_filedirsep$dbms_datestring$dbms_filesuffix"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    singledir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    numberdir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
      rotatesep="$dbms_filedirsep"
      rotatesuffix=""
      ;;
    datedir)
      if [ "$dbms_subdirprefix" = "" ]; then
        [ ! -d "$dbms_dumpdir/$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/"
        rotatesep=""
      else
        [ ! -d "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep"
        dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
        rotatesep="$dbms_filedirsep"
      fi
      dumpsuffix="$dbms_filesuffix"
      rotatesuffix=""
      ;;
  esac
}

#
# do a single DB dump pass, including file rotation, etc.
# (one pass = one dump command, but may be more than one DB)
#
# $1 is "one", "mult", or "all" (how many DBs to dump; see dbdumponecmd(),
# dbdumpmultcmd(), dbdumpallcmd())
#
# $2 is a string containing the name(s) of the database(s) to dump (names
# containing spaces must be sub-quoted (e.g., '... "foo bar" ...' or
# "... \"foo bar\" ..."); ignored if $1="all")
#
# returns 1 to mean "skip to the next phase of the backup",
# 2 to mean "we have skipped this dump",
# else 0
#
# see getdumppaths() for info about dumpprefix/dumpsep/dumpsuffix
#
# "local" vars: dumptype, dbstring, dbname, fileexists
# global vars: dumptmp, dumpprefix, dumpsuffix, rotateprefix,
#              rotatesep, rotatesuffix, dbms_prefix, dbms_layout,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dumpexists_exitval, dbdump_exitval,
#              dbzip_exitval
# config settings: on_duplerr, on_dumperr, on_ziperr
# library vars: newline
# library funcs: rotatenumfiles(), prunefiles(), removefilezip(),
#                dbdumponecmd(), dbdumpmultcmd(), dbdumpallcmd(),
#                sendalert(), logstatus(), logstatusquiet(), do_exit()
# utilities: (allowed values of $dbms_zipmode), rm, mv, date, printf, [
# FDs: 3
#
do_dbdump () {
  dumptype="$1"
  dbstring="$2"

  # if we're dumping only one DB, the DB name will be part of the filename(s)
  dbname=""
  if [ "$dumptype" = "one" ]; then
    dbname="$dbstring"
  }

  # rotate if we need to, to make way for the new dump
  case "$dbms_layout" in
    number)
      rotatenumfiles "$rotateprefix$dbname" "$rotatesep" "$rotatesuffix"
      ;;
    numberdir)
      rotatenumfiles "$rotateprefix" "$rotatesep" "$rotatesuffix"
      ;;
  esac

  # are we (still) about to overwrite an existing dump?
  fileexists="no"
  if [ "$dbms_layout" != "single" ] \
     && \
     [ "$dbms_layout" != "singledir" ]; then
    #
    [ -f "$dumpprefix$dbname$dumpsuffix" ] && fileexists="yes"
    #
    { [ "$dbms_zipmode" = "gzip" ] || [ "$dbms_zipmode" = "pigz" ]; } && \
      [ -f "$dumpprefix$dbname$dumpsuffix.gz" ] && fileexists="yes"
    #
    [ "$dbms_zipmode" = "bzip2" ] && \
      { [ -f "$dumpprefix$dbname$dumpsuffix.bz" ] || [ -f "$dumpprefix$dbname$dumpsuffix.bz2" ]; } && \
      fileexists="yes"
    #
    [ "$dbms_zipmode" = "lzip" ] && \
      [ -f "$dumpprefix$dbname$dumpsuffix.lz" ] && fileexists="yes"
  fi

  if [ "$fileexists" = "yes" ]; then
    case "$on_dbduplerr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists; exiting" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; exiting" log
        fi
        do_exit "$dumpexists_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists;${newline}skipping to next phase of backup" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists;${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists; skipping" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; skipping" log
        fi
        return 2  # skip to the next DB
        ;;
      warn)
        if [ "$dbname" != "" ]; then
          sendalert "warning: dumpfile for $dbms_prefix database \"$dbname\" already exists; overwriting" log
        else
          sendalert "warning: dumpfile for $dbms_prefix database(s) already exists; overwriting" log
        fi
        ;;
      ignore)
        :  # do nothing
        ;;
    esac
  fi

  # clean up ("space" preservation mode; see below)
  if [ "$dbms_preserve" = "space" ]; then
    # prune old dumpfiles
    case "$dbms_layout" in
      single|number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      singledir|numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac

    # remove any current dumpfile that's in the way ("single"/"singledir",
    # or from, e.g., rerunning the backup)
    removefilezip "$dumpprefix$dbname$dumpsuffix"
  fi

  # if we're dumping a single database, log the name
  if [ "$dbname" != "" ]; then
    logstatus "dumping $dbms_prefix database \"$dbname\""
  fi

  # log that we're running the command
  if [ "$dbname" != "" ]; then
    logstatusquiet "running $dbms_prefix dump command for database \"$dbname\""
    printf "%s\n" "running $dbms_prefix dump command for database \"$dbname\"" >&3
  else
    logstatusquiet "running $dbms_prefix dump command"
    printf "%s\n" "running $dbms_prefix dump command" >&3
  fi

  # starting timestamp
  printf "%s\n" "$dbms_prefix dump started $(date)" >&3

  # run the command
  case "$dbms_preserve" in
    data)
      rm -f "$dumpprefix$dbname$dumpsuffix$dumptmp"  # safer for >
      case "$dumptype" in
        one)
          dbdumponecmd "$dbstring" > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
          ;;
        mult)
          dbdumpmultcmd "$dbstring" > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
          ;;
      esac
      ;;
    space)
      case "$dumptype" in
        one)
          dbdumponecmd "$dbstring" > "$dumpprefix$dbname$dumpsuffix" 2>&3
          ;;
        mult)
          dbdumpmultcmd "$dbstring" > "$dumpprefix$dbname$dumpsuffix" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dbname$dumpsuffix" 2>&3
          ;;
      esac
      ;;
  esac

  # check status
  if [ "$?" != 0 ]; then
    case "$on_dumperr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\"; exiting" log
        else
          sendalert "error dumping $dbms_prefix database(s); exiting" log
        fi
        do_exit "$dbdump_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\";${newline}skipping to next phase of backup" log
        else
          sendalert "error dumping $dbms_prefix database(s);${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\"; skipping" log
        else
          sendalert "error dumping $dbms_prefix database(s); skipping" log
        fi
        return 2  # skip to the next DB
        ;;
    esac
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped $dbms_prefix database \"$dbname\""
    else
      logstatus "successfully dumped $dbms_prefix database(s)"
    fi
  fi

  # ending timestamp
  printf "%s\n" "$dbms_prefix dump finished $(date)" >&3

  # clean up ("data" preservation mode; see above)
  if [ "$dbms_preserve" = "data" ]; then
    # remove current dumpfile (including zips), and move the temp file into
    # place
    #
    # only really need the zip part of this, since we use mv -f
    removefilezip "$dumpprefix$dbname$dumpsuffix"
    mv -f "$dumpprefix$dbname$dumpsuffix$dumptmp" \
          "$dumpprefix$dbname$dumpsuffix"

    # prune old dumpfiles
    case "$dbms_layout" in
      single|number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      singledir|numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac
  fi

  # zip current dumpfile
  #
  # wait until after pruning; we use less total space during the backup
  # process, and don't sacrifice any data preservation gain
  if [ "$dbms_zipmode" != "none" ]; then
    # starting timestamp
    printf "%s\n" "$dbms_zipmode started $(date)" >&3

    # no " so we can specify multiple options
    "$dbms_zipmode" $dbms_zipoptions "$dumpprefix$dbname$dumpsuffix" >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      case "$on_ziperr" in
        exit)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\"; exiting" log
          else
            sendalert "error compressing $dbms_prefix database(s); exiting" log
          fi
          do_exit "$dbzip_exitval"
          ;;
        phase)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\";${newline}skipping to next phase of backup" log
          else
            sendalert "error compressing $dbms_prefix database(s);${newline}skipping to next phase of backup" log
          fi
          return 1  # skip to the next phase
          ;;
        db)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\"; skipping" log
          else
            sendalert "error compressing $dbms_prefix database(s); skipping" log
          fi
          return 2  # skip to the next DB
          ;;
      esac
    else
      if [ "$dbname" != "" ]; then
        logstatus "successfully compressed $dbms_prefix database \"$dbname\""
      else
        logstatus "successfully compressed $dbms_prefix database(s)"
      fi
    fi
    # ending timestamp
    printf "%s\n" "$dbms_zipmode finished $(date)" >&3
  fi

  return 0
}

#
# wrapper around the different modes of DB dumps
# (split/unsplit, all/include/exclude/etc.)
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# "local" vars: OLDIFS, dbnames, dbname_esc, dbname, exclude_esc, exclude
# global vars: IFS, dbms_dbmode, dbms_dbs, dbms_splitdbs, lockfile, alldbs
# library vars: newline, tab
# library funcs: dbunescape()
# utilities: [
# files: alldbs
#
do_dbdumploop () {
  OLDIFS="$IFS"

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbmode" in
      all)
        do_dbdump "all"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      include)
        dbnames=""
        IFS="$tab$newline"
        for dbname_esc in $(printf "%s" "$dbms_dbs"); do
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          dbnames="$dbnames \"$dbname\""
          IFS="$tab$newline"
        done
        IFS="$OLDIFS"
        do_dbdump "mult" "$dbnames"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      exclude)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS="$tab$newline"
          for exclude_esc in $(printf "%s" "$dbms_dbs"); do
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS="$tab$newline"
          done
          IFS="$OLDIFS"

          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        do_dbdump "mult" "$dbnames"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      includefile)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$dbms_dbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$dbms_dbs"
        IFS="$OLDIFS"
        do_dbdump "mult" "$dbnames"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      excludefile)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS=""
          while read -r exclude_esc; do  # < "$dbms_dbs"
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS=""
          done < "$dbms_dbs"
          IFS="$OLDIFS"

          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        do_dbdump "mult" "$dbnames"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
    esac  # case "$dbms_dbmode"
  else  # dbms_splitdbs="yes"
    case "$dbms_dbmode" in
      all)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        ;;
      include)
        IFS="$tab$newline"
        for dbname_esc in $(printf "%s" "$dbms_dbs"); do
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS="$tab$newline"
        done
        IFS="$OLDIFS"
        ;;
      exclude)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS="$tab$newline"
          for exclude_esc in $(printf "%s" "$dbms_dbs"); do
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS="$tab$newline"
          done
          IFS="$OLDIFS"

          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
       ;;
      includefile)
        IFS=""
        while read -r dbname_esc; do  # < "$dbms_dbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$dbms_dbs"
        IFS="$OLDIFS"
        ;;
      excludefile)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS=""
          while read -r exclude_esc; do  # < "$dbms_dbs"
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS=""
          done < "$dbms_dbs"
          IFS="$OLDIFS"

          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        ;;
    esac  # case "$dbms_dbmode"
  fi  # if [ "$dbms_splitdbs" = "no" ]

  return 0
}


##########################################
# command line and configuration settings
##########################################

configfile=""
noconfigfile="no"
mode=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    -f)
      shift
      if [ "$#" = "0" ]; then
        throwusageerr "Error: -f requires a config-file path; exiting."
      else
        configfile="$1"
        noconfigfile="no"
        shift
      fi
      ;;
    -n)
      noconfigfile="yes"
      configfile=""
      shift
      ;;
    *)
      mode="${1#--}"
      shift
      ;;
  esac
done

validlist "mode" "" "help" "usage" "license" "config" "settings" \
          "status" "statusall" "silence" "unsilence" "stop" "disable" \
          "start" "enable" "clearlock" "unlock" "create" "systemtest"

# first deal with the modes that don't require sourcing the config file
# or dealing with settings
case "$mode" in
  help|usage)
    # print the usage message
    usage
    do_exit "$no_error_exitval"
    ;;
  license)
    # print the license message
    license
    do_exit "$no_error_exitval"
    ;;
  create)
    # output a "blank" config file
    #
    # do this _before_ applying default config file
    if [ "$noconfigfile" = "no" ] && [ "$configfile" != "" ]; then
      if [ -f "$configfile" ]; then
        throwusageerr "Error: specified config file already exists; exiting."
      else
        # use a separate FD to make the code cleaner
        exec 3>&1  # save for later
        exec 1>"$configfile"
      fi
    fi
    echo
    echo "# see CONFIG for details"
    echo
    for setting in $configsettings; do
      printf "%s\n" "#$setting=\"\""
    done
    if [ "$noconfigfile" = "no" ] && [ "$configfile" != "" ]; then
      exec 1>&3  # put stdout back
    fi
    do_exit "$no_error_exitval"
    ;;
esac

# save variables set on the command line
saveclset

# check and source config file
if [ "$noconfigfile" = "no" ]; then
  # apply default config file if applicable
  if [ "$configfile" = "" ]; then
    configfile="$defaultconfigfile"
  fi

  validreadfile "configfile"

  # . won't work with no directory (unless ./ is in the PATH);
  # the cwd has to be specified explicitly
  if printf "%s\n" "$configfile" | grep -v '/' > /dev/null 2>&1; then
    . "./$configfile"
  else
    . "$configfile"
  fi
fi

# restore variables set on the command line, overriding the config file
restoreclset

# apply default settings where applicable
applydefaults

# validate the config settings
validconf

# debug mode?
# (in case it was turned on in the config file, but not on the command line;
# see above)
if [ "$debugme" = "yes" ]; then
  do_debug
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$mode" in
  config|settings)
    # print the current config settings
    echo
    printconfig
    echo
    do_exit "$no_error_exitval"
    ;;
  status|statusall)
    # print the current status
    echo
    if [ "$mode" = "statusall" ]; then  # include temp files
      printstatus all
    else
      printstatus
    fi
    echo
    do_exit "$no_error_exitval"
    ;;
  silence)
    # silence lockfile-exists alerts
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory doesn't exist; nothing to silence"
      do_exit "$startup_exitval"
    fi
    if [ -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already silenced"
      do_exit "$startup_exitval"
    fi
    # using a file in the lockfile dir means that we automatically
    # get the silencing cleared when the lockfile is removed
    touch "$lockfile/$silencealerts"
    echo "lockfile alerts have been silenced"
    quiet="yes"  # don't print to the terminal again
    logclconfig  # so we know what the status message means
    logstatus "lockfile alerts have been silenced, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    if [ ! -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already unsilenced"
      do_exit "$startup_exitval"
    fi
    rm -f "$lockfile/$silencealerts"
    echo "lockfile alerts have been unsilenced"
    quiet="yes"  # don't print to the terminal again
    logclconfig  # so we know what the status message means
    logstatus "lockfile alerts have been unsilenced, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  stop|disable)
    # disable backups
    if [ -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already disabled"
      do_exit "$startup_exitval"
    fi
    if [ -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory exists; a backup is probably running"
      echo "disable command will take effect after the current backup finishes"
      echo
    fi
    mkdir "$lockfile" > /dev/null 2>&1  # ignore already-exists errors
    touch "$lockfile/$disable"
    echo "backups have been disabled; remember to re-enable them later!"
    quiet="yes"  # don't print to the terminal again
    logclconfig  # so we know what the status message means
    logstatus "backups have been disabled, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  start|enable)
    # re-enable backups
    if [ ! -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already enabled"
      do_exit "$startup_exitval"
    fi
    rm -f "$lockfile/$disable"
    echo "backups have been re-enabled"
    echo "if a backup is not currently running, you should now remove the lockfile"
    echo "with the unlock command"
    quiet="yes"  # don't print to the terminal again
    logclconfig  # so we know what the status message means
    logstatus "backups have been re-enabled, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  clearlock|unlock)
    # remove lockfile dir
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile has already been removed"
      do_exit "$startup_exitval"
    fi
    echo
    echo "WARNING: the lockfile should only be removed if you're sure a backup is not"
    echo "currently running."
    echo "Type 'y' (without the quotes) to continue."
    # it would be nice to have this on the same line as the prompt,
    # but the portability issues aren't worth it for this
    read type_y
    if [ "$type_y" != "y" ]; then
      echo "Exiting."
      do_exit "$no_error_exitval"
    fi
    echo
    rm -rf "$lockfile"
    echo "lockfile has been removed"
    quiet="yes"  # don't print to the terminal again
    logclconfig  # so we know what the status message means
    logstatus "lockfile \"$lockfile\" has been manually removed"
    do_exit "$no_error_exitval"
    ;;
  systemtest)
    echo
    echo "checking for commands in the PATH..."
    echo "(note that missing commands may not matter, depending on the command"
    echo "and the settings used; on the other hand, commands may be present"
    echo "but not support required options)"
    echo
    for cmd in $externalcmds; do
      if command -v "$cmd" > /dev/null 2>&1; then
        printf "%-10s\n" "$cmd was found"
      else
        printf "%-10s\n" "$cmd was NOT found"
      fi
    done
    echo
    do_exit "$no_error_exitval"
    ;;
esac

# log config file, current working directory, and setting variables supplied
# on the command line
logclconfig


################
# status checks
################

if [ "$runevery" != "0" ]; then
  # has it been long enough since the last backup started?
  #
  # if $startedfile exists and is newer than $runevery, exit
  # (-f instead of -e because it's more portable)
  if [ -f "$startedfile" ] \
     && \
     newerthan "$startedfile" "$runevery" "$lockfile/$timetemp"; then
    logstatus "backup interval has not expired; exiting"
    do_exit "$no_error_exitval"
  else
    logstatus "backup interval has expired; continuing"
  fi
else
  logstatus "interval checking has been disabled; continuing"
fi

# did the previous backup finish?
#
# use an atomic command to check and create the lock
# (could also be ln -s, but we might not be able to set the metadata, and
#  it could cause issues with commands that don't manipulate links directly;
#  plus, now we have a tempdir)
if mkdir "$lockfile" > /dev/null 2>&1; then
  # got the lock, clear lock-alert status
  if [ -f "$alertfile" ]; then  # -f is more portable than -e
    rm "$alertfile"
    sendalert "lockfile created; cancelling previous alert status" log
  fi
  # set flag to remove the lockfile (etc.) on exit
  cleanup_on_exit="yes"
else
  # assume mkdir failed because it already existed;
  # but that could be because we manually disabled backups
  if [ -f "$lockfile/$disable" ]; then
    logalert "backups have been manually disabled; exiting"
  else
    logalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  # don't actually exit yet

  # send the initial alert email (no "log", we already logged it)
  #
  # (-f instead of -e because it's more portable)
  if [ ! -f "$alertfile" ]; then
    touch "$alertfile"
    if [ -f "$lockfile/$disable" ]; then
      sendalert "backups have been manually disabled; exiting"
    else
      sendalert "could not create lockfile (previous backup still running or failed?); exiting"
    fi
    do_exit "$lockfile_exitval"
  fi

  # but what about subsequent emails?

  # if ifrunning=0, log it but don't send email
  if [ "$ifrunning" = "0" ]; then
    logalert "ifrunning=0; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # if alerts have been silenced, log it but don't send email
  # (and don't bother checking $ifrunning)
  if [ -f "$lockfile/$silencealerts" ]; then
    logalert "alerts have been silenced; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # if $alertfile is newer than $ifrunning, log it but don't send email
  if newerthan "$alertfile" "$ifrunning" "$lockfile/$timetemp"; then
    logalert "alert interval has not expired; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # send an alert email (no "log", we already logged it)
  touch "$alertfile"
  if [ -f "$lockfile/$disable" ]; then
    sendalert "backups have been manually disabled; exiting"
  else
    sendalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  do_exit "$lockfile_exitval"
fi  # if mkdir "$lockfile"


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for the current output log; set the filename while we're at it
outputlog_filename="$outputlog"
if [ "$outputlog" != "" ] && [ "$outputlog_layout" = "date" ]; then
  if [ "$outputlog_date" != "" ]; then
    outputlog_datestring=$(date "$outputlog_date")
  else
    outputlog_datestring=$(date)
  fi
  outputlog_filename="$outputlog_filename$outputlog_sep$outputlog_datestring"
  touch "$outputlog_filename"  # needed for prunedayslogs()
fi

# for the current DB dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      dbms_datestring=$(date "$dbms_filedirdate")
    else
      dbms_datestring=$(date)
    fi
    eval "$(printf "%s" "$dbms")_datestring=\"$dbms_datestring\""
  fi
done


###################
# start output log
###################

# set up a fifo for logging; this has two benefits:
# 1) we can handle multiple output options in one place
# 2) we can run commands without needing pipelines, so we can get the
#    return values
mkfifo "$lockfile/$logfifo"

# rotate and prune output logs
# (also tests in case there is no output log, and prints status accordingly)
rotatepruneoutputlogs

if [ "$outputlog" != "" ]; then
  # append to the output log and possibly stdout
  # appending is always safe / the right thing to do, because either the
  # file won't exist, or it will have been moved out of the way by the
  # rotation - except in one case:
  # if we're using a date layout, and the script has been run more recently
  # than the datestring allows for, we should append so as not to lose
  # information
  if [ "$quiet" = "no" ]; then  # default to yes
    tee -a "$outputlog_filename" < "$lockfile/$logfifo" &
  else
    cat >> "$outputlog_filename" < "$lockfile/$logfifo" &
  fi
else  # no output log
  if [ "$quiet" = "no" ]; then
    cat < "$lockfile/$logfifo" &
  else
    cat > /dev/null < "$lockfile/$logfifo" &
  fi
fi

# create an fd to write to instead of the fifo,
# so it won't be closed after every line;
# see http://mywiki.wooledge.org/BashFAQ/085
exec 3> "$lockfile/$logfifo"


################
# begin working
################

# starting notifications/timestamps
logstatus "starting backup"
touch "$startedfile"
printf "%s\n" "backup started $(date)" >&3

# are we supposed to actually do anything?
do_something="no"  # set this to yes later if we do something


###########
# DB dumps
###########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_dbms () {
  if [ "$dbms_usetunnel" = "yes" ]; then
    closesshtunnel
  fi
}

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    do_something="yes"

    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms"
      opensshtunnel
      [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase
    fi

    # get the list of all DBs if necessary
    getdblist
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary
    getdumppaths

    # do the actual dump(s)
    do_dbdumploop
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_rsync () {
  # close the SSH tunnel
  if [ "$rsync_mode" = "tunnel" ]; then
    closesshtunnel
  fi
}

while true; do  # only here to allow us to easily skip to the next phase
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    logstatus "starting rsync backup sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync"
      opensshtunnel
      [ "$?" = "1" ] && skip_rsync && continue  # skip to the next phase
    fi

    # log that we're running the command
    logstatusquiet "running rsync command"
    printf "%s\n" "running rsync command" >&3

    # starting timestamp
    printf "%s\n" "rsync started $(date)" >&3

    # run the command
    rsynccmd >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      sendalert "warning: rsync finished with errors; please check the log" log
      setexitval "$rsync_exitval"
    else
      logstatus "rsync completed without errors"
    fi

    # ending timestamp
    printf "%s\n" "rsync finished $(date)" >&3

    # close the SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      closesshtunnel
    fi

    logstatus "rsync backup sequence completed"
  fi

  break  # don't actually loop
done


###############
# done working
###############

# did we actually do anything?
if [ "$do_something" = "no" ]; then  # everything was turned off
  logstatus "nothing to do, because no actions are turned on"
fi

# finishing notifications
logstatus "backup finished"
printf "%s\n" "backup finished $(date)" >&3


##################
# stop output log
##################

# remove the fifo and kill the reader process;
# note that we don't have to worry about doing this if we exit abnormally,
# because exiting will close the fd, and the fifo is in the lockfile dir

exec 3>&-  # close the fd, this should kill the reader
rm -f "$lockfile/$logfifo"


###########
# clean up
###########

do_exit "$no_error_exitval"
