#!/bin/bash

#######################################################################
# Aeolus
# a portable, super-configurable database dump and rsync backup script
# by Daniel Malament
# see license() for license info
#######################################################################

# see usage() and the usage and sample config files for usage notes

# exit values:
#   0  = no error (e.g., runevery hasn't expired, or backup was completed
#        without errors)
#   1  = problem with the script invocation, the config file, or a setting
#        (also used in command modes like 'disable' as a generic error value)
#   2  = previous lockfile still exists (possibly because backups were
#        manually disabled)
#   3  = bad variable name or subscript key
#   4  = error finding a delimiter for a string
#   5  = error opening SSH tunnel
#   6  = error getting DB list
#   7  = problem with contents of DB list (e.g., unsafe characters)
#   8  = DB dumpfile already exists
#   9  = error dumping DB
#   10 = error compressing DB dump
#   11 = rsync error
# if there are multiple errors, the first one to occur is used

# modification notes:
#
# if the exit values above are changed, update the *_exitval variables,
# below
#
# lockfile dir is used for the following files:
#   $lfalertssilenced, $scriptdisabled, $timetemp, $logfifo,
#   $alldbs${DBMSes}, $alldbs${DBMSes}$alldbstmp
# all files should be in printstatus()
#
# any change to the setting variables (additions, deletions, name changes,
# type changes, etc.) must be reflected in: the sample config file,
# $configsettings, configsettingisarray() [possibly], the default settings
# section, some of switch*() [possibly], applydefaults() [probably], and
# validconf()
#
# all external commands used should be listed in $externalcmds and the usage
# notes (including those used in library functions)
#
# adding a DBMS:
#   add vars to the sample config file, modeling after MySQL (but split up
#     [dbms]_dump*options if necessary)
#   add vars to the relevant variables/functions (see above)
#   add to dbdump*cmd(), getdblist()
#   add to the database functions in the library
#   add to dbmslist
#   add to usage notes on installation and portability
#
# see notes in the hardcoded variables section for other things that should
# be kept in sync (e.g., the name of the script and $scriptname, the values
# of the defaults and the comments in the sample config file, etc.)

# TODO:
# globbing in dblist?
#
# better handling of long errors?
# i18n?
# setup modes?
# emulate mkdir -p?
# allow char devs / fifos in cases where we currently test for -f?
#  (but could cause problems with, e.g., rm...)
#
# do more to protect against leading - in settings?


################
# version check
################

#
# if we're not running a high enough version of bash, we shouldn't even try
# to parse the code below
#

# we can't use arithmetical tests because BASH_VERSINFO[1] wasn't always
# purely numeric
case "$BASH_VERSION" in
  1.*|2.*|3.0.*)
    cat <<-EOF 1>&2

	This script requires bash version 3.1 or later.

	EOF
    exit 1
    ;;
esac


######################
# pull in the library
######################

# preparatory massaging:
# this won't get reset if it's set on the command line,
# but if it's unset, the library will set it;
# this will make the script think it was set on the command line
[ "${on_tunerr+X}" = "" ] && on_tunerr_unset="yes"

# source the library
. /root/backup/aeolus-lib.sh

# finish massaging
[ "$on_tunerr_unset" = "yes" ] && unset on_tunerr


############
# debugging
############

#
# turn on debugging
#
# note: this function must be idempotent
#
do_debug () {
  # see http://bashdb.sourceforge.net/bashdb.html#Interactive-Line-Tracing-Session
  #PS4='(${BASH_SOURCE}:${LINENO}): ${FUNCNAME[0]} - [${SHLVL},${BASH_SUBSHELL}, $?]$newline'
  set -vx
}

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
#
# however, this only applies if debugging is turned on on the command line;
# see also below
#
# (note: setting isn't called 'debug' to avoid possible collisions)
#
if [ "$debugme" = "yes" ]; then
  do_debug
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# name of the script, as reported by usage(), etc.
# change this if you rename the script file
scriptname="aeolus"

# external commands used (potentially)
#
# commands that are always builtins, such as 'set' and 'wait', can be
# omitted (and in some cases, we would have used them already by the time
# we try to test for them)
#
externalcmds="
  rsync
  ssh
  nc
  mysql
  mysqldump
  gzip
  pigz
  bzip2
  lzip
  date
  hostname
  logger
  mailx
  grep
  awk
  gawk
  sed
  tr
  expr
  cat
  tee
  ls
  find
  diff
  cmp
  touch
  mv
  rm
  mkdir
  mkfifo
  sleep
"

# default path to the config file, if one isn't specified
# change usage notes if you change this
defaultconfigfile="/etc/aeolus/aeolus.conf"

# names of all config file settings, in logical order
configsettings="
  usepath
  useumask
  timecomptype
  filecomptype
  debugme
  on_tunerr
  on_dblisterr
  on_dbcharerr
  on_dbduplerr
  on_dbdumperr
  on_dbziperr
  runevery
  startedfile
  lockfile
  ifrunning
  alertfile
  suppressemail
  mailto
  subject
  outputlog
  outputlog_layout
  outputlog_sep
  outputlog_date
  numlogs
  dayslogs
  usesyslog
  syslogstat
  syslogerr
  syslogtag
  quiet
  statuslog
  rsync_sshuser
  rsync_sshhost
  rsync_sshkeyfile
  rsync_sshport
  rsync_localport
  rsync_remoteport
  rsync_sshoptions
  rsync_sshtimeout
  do_rsync
  rsync_mode
  rsync_source
  rsync_dest
  rsync_port
  rsync_pwfile
  rsync_filterfile
  rsync_options
  rsync_add
  mysql_dodump
  mysql_usetunnel
  mysql_sshuser
  mysql_sshhost
  mysql_sshkeyfile
  mysql_sshport
  mysql_localport
  mysql_remoteport
  mysql_sshoptions
  mysql_sshtimeout
  mysql_user
  mysql_pwfile
  mysql_protocol
  mysql_host
  mysql_port
  mysql_socketfile
  mysql_dbmode
  mysql_dblist
  mysql_splitdbs
  mysql_options
  mysql_dumpoptions
  mysql_usealtopts
  mysql_dumpdir
  mysql_layout
  mysql_fileprefix
  mysql_filesuffix
  mysql_subdirprefix
  mysql_filedirsep
  mysql_filedirdate
  mysql_numfiles
  mysql_daysfiles
  mysql_zipmode
  mysql_zipoptions
  mysql_preserve
"

#
# which settings are arrays?
#
# (this is the only reasonable way I have come up with to handle this,
# without requiring bash4 for associative arrays)
#
# $1 is the name of a config setting
#
# returns 0 (true) if the setting is an array, 1 (false) if not
#
configsettingisarray () {
  # break this up for readability
  case "$1" in
    rsync_sshoptions|rsync_source|rsync_options|rsync_add)
      return 0  # true
      ;;
    mysql_sshoptions|mysql_dblist|mysql_options|mysql_dumpoptions|mysql_zipoptions)
      return 0  # true
      ;;
  esac

  return 1  # false
}

#
# default settings
#
# change comments in sample config file if you change these
#

# default settings: housekeeping
timecomptype_default="find"
filecomptype_default="cmp"
debugme_default="no"
on_tunerr_default="phase"
on_dblisterr_default="phase"
on_dbcharerr_default="phase"
on_dbduplerr_default="db"
on_dbdumperr_default="db"
on_dbziperr_default="db"

# default settings: checks and logging
runevery_default="0"
startedfile_default="/var/run/aeolus/started"
lockfile_default="/var/run/aeolus/lock"
ifrunning_default="120"  # 2 hours
#alertfile_default="$lockfile.alert"  # set it later, after lockfile
suppressemail_default="no"
if command -v hostname > /dev/null 2>&1; then
  mailto_default="root@$(hostname)"
  subject_default="Aeolus alert on $(hostname)"
else
  mailto_default="root@localhost"
  subject_default="Aeolus alert"
fi
outputlog_default="/var/log/aeolus-output.log"  # only if unset
outputlog_layout_default="number"
outputlog_sep_default="."  # only if unset
outputlog_date_default="+%Y%m%d"  # only if unset
numlogs_default="0"
dayslogs_default="7"
usesyslog_default="yes"
quiet_default="no"
statuslog_default="/var/log/aeolus.log"  # only if unset

# default settings: SSH tunnels (all)
rsync_localport_default="8873"
rsync_remoteport_default="873"
mysql_localport_default="4306"
mysql_remoteport_default="3306"
sshtimeout_default="15"  # applies to all SSH tunnels

# default settings: rsync
do_rsync_default="no"
rsync_mode_default="tunnel"
rsync_pwfile_default="/etc/aeolus/rsync.pw"  # only if unset

# default settings: DBMSes (all; see also below)
dbms_dodump_default="no"
dbms_usetunnel_default="no"
dbms_dumpdir_default="."
dbms_layout_default="date"
dbms_filesuffix_default=".sql"  # only if unset
dbms_filedirsep_default="-"  # only if unset
dbms_filedirdate_default="+%Y%m%d"  # only if unset
dbms_numfiles_default="0"
dbms_daysfiles_default="7"
dbms_zipmode_default="gzip"
dbms_preserve_default="data"

# default settings: MySQL (see also above)
mysql_pwfile_default="/etc/aeolus/mysql.pw"  # only if unset
mysql_dbmode_default="all"
mysql_splitdbs_default="no"
mysql_dumpoptions_default=(--opt -Q -R -c)  # only if unset
mysql_usealtopts_default="no"
mysql_fileprefix_default="mysqldump"  # only if unset
mysql_subdirprefix_default="mysqldump"  # only if unset

# settings that have no default, and can't be blank
# (but may be ignored, depending on other settings)
#
# [tun]_sshhost
# rsync_source
# rsync_dest
# [dbms]_dblist

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
#
# removing a DBMS from this list will effectively disable it
dbmslist="mysql"

# names of tempfiles stored in the lockfile directory
lfalertssilenced="lfalertssilenced"
scriptdisabled="scriptdisabled"
timetemp="timetemp"
logfifo="logfifo"
alldbs="alldbs-"  # gets DBMS name appended
alldbstmp=".tmp"  # added to $alldbs${DBMS}

# extension to use for temporary dumpfiles
dumptmp=".tmp"

# exit values; see top of script for details
# (and keep numbers in sync when modifying)
no_error_exitval="0"
startup_exitval="1"
lockfile_exitval="2"
badvarname_exitval="3"
nodelim_exitval="4"
sshtunnel_exitval="5"
getdblist_exitval="6"
dblistchar_exitval="7"
dumpexists_exitval="8"
dbdump_exitval="9"
dbzip_exitval="10"
rsync_exitval="11"


###########################
# default config functions
###########################

#
# these are functions associated with config settings, and defined by the
# user; they can be:
# - defined and exported from the invoking shell, in which case we don't
#   redefine them
# - undefined, in which case these defaults will apply
# - defined in the config file, in which case those definitions will
#   override these
#

#
# for mysql_usealtopts
#
# $1 = the name of a database
#
# returns 1 (false) if mysql_dumpoptions should be used
# otherwise, returns 0 (true) and sets altopts array
#
# global vars: altopts
# config settings: mysql_dumpoptions
# library functions: copyarray()
# bashisms: if !, declare -F, array+=() [v3.1]
#
if ! declare -F mysql_altopts > /dev/null 2>&1; then
  mysql_altopts () {
    case "$1" in
      information_schema)
        copyarray "mysql_dumpoptions" "altopts"  # include regular options
        altopts+=(--skip-lock-tables)
        return 0
        ;;
      mysql)
        copyarray "mysql_dumpoptions" "altopts"  # include regular options
        altopts+=(--skip-extended-insert)
        return 0
        ;;
    esac

    return 1
  }
fi


#################################
# helper functions: housekeeping
#################################

#
# cleanup function, to be called by do_exit()
#
#   * closes any open SSH tunnel
#   * removes the lockfile, unless the scriptdisabled semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: tunpid_prefix, scriptdisabled
# config settings: lockfile
# library functions: closesshtunnel()
# utilities: rm, [
# files: $lockfile, $lockfile/$scriptdisabled
#
do_exit_cleanup () {
  # closesshtunnel() can be run after the tunnel was already closed,
  # but should not be run if it was never started
  if [ "$tunpid_prefix" != "" ]; then
    closesshtunnel
  fi

  if [ ! -f "$lockfile/$scriptdisabled" ]; then
    rm -r "$lockfile"
  fi
  # otherwise, a disable command must have been run while we were
  # doing this backup; leave the lockfile dir alone, so future backups
  # will be disabled
}


#######################################
# helper functions: logging and alerts
#######################################

#
# print diagnostics, for sendalert()
#
# must not be called until after printstatus() is defined
#
# library functions: printconfig()
# utilities: cat
#
sendalert_body () {
  cat <<-EOF


	$(printconfig)


	$(printstatus all)
	EOF
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g., "rsync" or a member of
# $dbmslist)
#
# (in the notes below, [tun] = the value of $1)
#
# note: the [tun]_* settings may still be used in addition to or instead of
# the tun_* globals; keep them in sync while in use
#
# [tun]_sshoptions must be an indexed, non-sparse array
#
# global vars: tun_prefix, tun_sshuser, tun_sshhost, tun_sshkeyfile,
#              tun_sshport, tun_localport, tun_remoteport,
#              tun_sshoptions, tun_sshtimeout
# config settings: [tun]_sshuser, [tun]_sshhost, [tun]_sshkeyfile,
#                  [tun]_sshport, [tun]_localport, [tun]_remoteport,
#                  [tun]_sshoptions, [tun]_sshtimeout
# library functions: copyvar(), copyarray()
#
switchtunnel () {
  tun_prefix="$1"
  copyvar "${1}_sshuser" "tun_sshuser"
  copyvar "${1}_sshhost" "tun_sshhost"
  copyvar "${1}_sshkeyfile" "tun_sshkeyfile"
  copyvar "${1}_sshport" "tun_sshport"
  copyvar "${1}_localport" "tun_localport"
  copyvar "${1}_remoteport" "tun_remoteport"
  copyarray "${1}_sshoptions" "tun_sshoptions"
  copyvar "${1}_sshtimeout" "tun_sshtimeout"
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# (in the notes below, [dbms] = the value of $1)
#
# note: the [dbms]_* settings may still be used in addition to or instead of
# the dbms_* globals; keep them in sync while in use
#
# [dbms]_dblist, [dbms]_options, [dbms]_dumpoptions, [dbms]_dumponeoptions,
# [dbms]_dumpmultoptions, [dbms]_dumpalloptions, and [dbms]_zipoptions must
# be indexed, non-sparse arrays
#
# global vars: [dbms]_datestring, dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socketfile,
#              dbms_dbmode, dbms_dblist, dbms_splitdbs, dbms_options,
#              dbms_dumpoptions, dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_usealtopts, dbms_dumpdir,
#              dbms_layout, dbms_fileprefix, dbms_filesuffix,
#              dbms_subdirprefix, dbms_filedirsep, dbms_filedirdate,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dbms_datestring
# config settings: [dbms]_dodump, [dbms]_usetunnel, [dbms]_user,
#                  [dbms]_pwfile, [dbms]_protocol, [dbms]_host, [dbms]_port,
#                  [dbms]_socketfile, [dbms]_dbmode, [dbms]_dblist,
#                  [dbms]_splitdbs, [dbms]_options, [dbms]_dumpoptions,
#                  [dbms]_dumponeoptions, [dbms]_dumpmultoptions,
#                  [dbms]_dumpalloptions, [dbms]_usealtopts, [dbms]_dumpdir,
#                  [dbms]_layout, [dbms]_fileprefix, [dbms]_filesuffix,
#                  [dbms]_subdirprefix, [dbms]_filedirsep,
#                  [dbms]_filedirdate, [dbms]_numfiles, [dbms]_daysfiles,
#                  [dbms]_zipmode, [dbms]_zipoptions, [dbms]_preserve
# library functions: copyvar(), copyarray()
#
switchdbms () {
  dbms_prefix="$1"
  copyvar "${1}_dodump" "dbms_dodump"
  copyvar "${1}_usetunnel" "dbms_usetunnel"
  copyvar "${1}_user" "dbms_user"
  copyvar "${1}_pwfile" "dbms_pwfile"
  copyvar "${1}_protocol" "dbms_protocol"
  copyvar "${1}_host" "dbms_host"
  copyvar "${1}_port" "dbms_port"
  copyvar "${1}_socketfile" "dbms_socketfile"
  copyvar "${1}_dbmode" "dbms_dbmode"
  copyarray "${1}_dblist" "dbms_dblist"
  copyvar "${1}_splitdbs" "dbms_splitdbs"
  copyarray "${1}_options" "dbms_options"
  copyarray "${1}_dumpoptions" "dbms_dumpoptions"
  copyarray "${1}_dumponeoptions" "dbms_dumponeoptions"
  copyarray "${1}_dumpmultoptions" "dbms_dumpmultoptions"
  copyarray "${1}_dumpalloptions" "dbms_dumpalloptions"
  copyvar "${1}_usealtopts" "dbms_usealtopts"
  copyvar "${1}_dumpdir" "dbms_dumpdir"
  copyvar "${1}_layout" "dbms_layout"
  copyvar "${1}_fileprefix" "dbms_fileprefix"
  copyvar "${1}_filesuffix" "dbms_filesuffix"
  copyvar "${1}_subdirprefix" "dbms_subdirprefix"
  copyvar "${1}_filedirsep" "dbms_filedirsep"
  copyvar "${1}_filedirdate" "dbms_filedirdate"
  copyvar "${1}_numfiles" "dbms_numfiles"
  copyvar "${1}_daysfiles" "dbms_daysfiles"
  copyvar "${1}_zipmode" "dbms_zipmode"
  copyarray "${1}_zipoptions" "dbms_zipoptions"
  copyvar "${1}_preserve" "dbms_preserve"
  # internal, not from config
  copyvar "${1}_datestring" "dbms_datestring"
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# global vars: scriptname, defaultconfigfile
# utilities: cat
#
usage () {
  # not necessarily reliable/consistent, switched to static global
  # (see hardcoded vars)
  #scriptname=$(printf "%s\n" "$0" | sed 's|^.*/||')

  cat <<EOF 1>&2

Usage:

  [ setting="value" ] $scriptname [ -f /path/to/config/file | -n ] [ mode ]

  Multiple settings can be added to the command line, separated by spaces;
  command-line settings override the config file.  Array settings may have
  to be supplied by creating a wrapper script that sets them, then sources
  this script.  There is no way to override a config-file-supplied array
  setting with an empty array, but ("") may suffice in some cases.

Options:

  -f /path/to/config/file: supply the path to the config file
  -n: use no config file
  The last-supplied of -f and -n will be used.
  If neither option is supplied, "$defaultconfigfile" will be tried.

Modes:

  Modes can have a leading '--'; e.g., '--help' (omit the quotes).
  If multiple modes are given, the last one is used.

  Available modes and their effects:

  "help" or "usage": this message is printed

  "license": a license message is printed

  "config" or "settings": the current config settings are printed

  "status": the current status, including timestamps, is printed
  "statusall": temp files mainly relevant for debugging are also included

  "silence": alerts about the lockfile existing are silenced until
  either they are unsilenced, or the lockfile is no longer present

  "unsilence": alerts about the lockfile existing are re-enabled

  "stop" or "disable": backups are disabled until "start" or "enable"
  is used

  "start" or "enable": backups are re-enabled

  "clearlock" or "unlock": the lockfile is forcibly removed; only use this
  if you're sure a backup isn't currently running!

  "create": a config file template is printed (all settings, in logical
  order, commented out so that the default values will be used unless
  otherwise specified); if -f is also given, the config file is output to
  the supplied path, but only if the file does not already exist

  "systemtest": diagnostics are printed about the system's support for
  the script (i.e., what utilities are present in the current PATH)

EOF
}

#
# print a license message to stderr
#
# utilities: cat
#
license () {
  cat <<EOF 1>&2

Copyright 2011 Daniel Malament.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
}

#
# print the current status, including file timestamps, etc.
#
# if $1 is "all", include timestamps for temp files that are only really
# relevant for debugging
#
# doesn't print surrounding blank lines; add them if necessary in context
#
# "local" vars: dbms
# global vars: lfalertssilenced, scriptdisabled, timetemp, logfifo, alldbs,
#              alldbstmp, dbmslist
# config settings: startedfile, lockfile, alertfile
# library functions: getfilemetadata()
# utilities: cat, echo, [
# files: $startedfile, $alertfile, $lockfile, $lockfile/$lfalertssilenced,
#        $lockfile/$scriptdisabled, $lockfile/$timetemp, $lockfile/$logfifo,
#        $lockfile/$alldbs${DBMSes}, $lockfile/$alldbs${DBMSes}$alldbstmp
#
printstatus () {
  cat <<-EOF
	-------
	Status:
	-------

	EOF

  if [ ! -f "$startedfile" ]; then  # -e isn't portable
    echo "no last-started file; this backup appears to have never been run"
  fi
  if [ -d "$lockfile" ]; then
    echo "lockfile directory exists; a backup may be in progress"
  else
    echo "no lockfile directory found; backups enabled but not in progress"
  fi
  if [ -f "$alertfile" ]; then
    echo "alertfile exists; a running backup prevented a new one from starting"
  fi
  if [ -f "$lockfile/$lfalertssilenced" ]; then
    echo "lockfile alerts have been silenced"
  fi
  if [ -f "$lockfile/$scriptdisabled" ]; then
    echo "backups have been disabled (but the last one may still be running)"
  fi

  cat <<-EOF


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	$(getfilemetadata "$startedfile")

	lockfile:
	$(getfilemetadata "$lockfile")

	alertfile:
	$(getfilemetadata "$alertfile")

	lfalertssilenced:
	$(getfilemetadata "$lockfile/$lfalertssilenced")

	scriptdisabled:
	$(getfilemetadata "$lockfile/$scriptdisabled")
	EOF

  if [ "$1" = "all" ]; then
    cat <<-EOF

	[temp files below this line, mainly relevant for debugging]

	timetemp:
	$(getfilemetadata "$lockfile/$timetemp")

	logfifo:
	$(getfilemetadata "$lockfile/$logfifo")
	EOF
    for dbms in $dbmslist; do
      cat <<-EOF

	alldbs-$dbms:
	$(getfilemetadata "$lockfile/$alldbs$dbms")

	alldbs-$dbms.tmp:
	$(getfilemetadata "$lockfile/$alldbs$dbms$alldbstmp")
	EOF
    done
  fi
}

#
# apply default settings where applicable
#
# see hardcoded variables section for rules
# (e.g. default only if unset, late checking)
#
# global vars: (setting _defaults)
# config settings: (most of them)
# library functions: copyarray()
# utilities: [
# bashisms: declare -p
#
applydefaults () {
  # housekeeping
  [ "$timecomptype" = "" ] && timecomptype="$timecomptype_default"
  [ "$filecomptype" = "" ] && filecomptype="$filecomptype_default"
  [ "$debugme" = "" ] && debugme="$debugme_default"
  [ "$on_tunerr" = "" ] && on_tunerr="$on_tunerr_default"
  [ "$on_dblisterr" = "" ] && on_dblisterr="$on_dblisterr_default"
  [ "$on_dbcharerr" = "" ] && on_dbcharerr="$on_dbcharerr_default"
  [ "$on_dbduplerr" = "" ] && on_dbduplerr="$on_dbduplerr_default"
  [ "$on_dbdumperr" = "" ] && on_dbdumperr="$on_dbdumperr_default"
  [ "$on_dbziperr" = "" ] && on_dbziperr="$on_dbziperr_default"

  # checks and logging
  [ "$runevery" = "" ] && runevery="$runevery_default"
  [ "$startedfile" = "" ] && startedfile="$startedfile_default"
  [ "$lockfile" = "" ] && lockfile="$lockfile_default"
  [ "$ifrunning" = "" ] && ifrunning="$ifrunning_default"
  [ "$alertfile" = "" ] && alertfile="$lockfile.alert"  # late-binding default
  [ "$suppressemail" = "" ] && suppressemail="$suppressemail_default"
  [ "$mailto" = "" ] && mailto="$mailto_default"
  [ "$subject" = "" ] && subject="$subject_default"
  [ "${outputlog+X}" = "" ] && outputlog="$outputlog_default"
  [ "$outputlog_layout" = "" ] && outputlog_layout="$outputlog_layout_default"
  [ "${outputlog_sep+X}" = "" ] && outputlog_sep="$outputlog_sep_default"
  [ "${outputlog_date+X}" = "" ] && outputlog_date="$outputlog_date_default"
  [ "$numlogs" = "" ] && numlogs="$numlogs_default"
  [ "$dayslogs" = "" ] && dayslogs="$dayslogs_default"
  [ "$usesyslog" = "" ] && usesyslog="$usesyslog_default"
  [ "$quiet" = "" ] && quiet="$quiet_default"
  [ "${statuslog+X}" = "" ] && statuslog="$statuslog_default"

  # SSH tunnels (individual and global defaults)
  [ "$rsync_localport" = "" ] && rsync_localport="$rsync_localport_default"
  [ "$rsync_remoteport" = "" ] && rsync_remoteport="$rsync_remoteport_default"
  [ "$mysql_localport" = "" ] && mysql_localport="$mysql_localport_default"
  [ "$mysql_remoteport" = "" ] && mysql_remoteport="$mysql_remoteport_default"
  # global
  [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="$sshtimeout_default"
  [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="$sshtimeout_default"

  # rsync
  [ "$do_rsync" = "" ] && do_rsync="$do_rsync_default"
  [ "$rsync_mode" = "" ] && rsync_mode="$rsync_mode_default"
  [ "${rsync_pwfile+X}" = "" ] && rsync_pwfile="$rsync_pwfile_default"

  # DBMSes (global defaults; see also below)
  [ "$mysql_dodump" = "" ] && mysql_dodump="$dbms_dodump_default"
  [ "$mysql_usetunnel" = "" ] && mysql_usetunnel="$dbms_usetunnel_default"
  [ "$mysql_dumpdir" = "" ] && mysql_dumpdir="$dbms_dumpdir_default"
  [ "$mysql_layout" = "" ] && mysql_layout="$dbms_layout_default"
  [ "${mysql_filesuffix+X}" = "" ] && mysql_filesuffix="$dbms_filesuffix_default"
  [ "${mysql_filedirsep+X}" = "" ] && mysql_filedirsep="$dbms_filedirsep_default"
  [ "${mysql_filedirdate+X}" = "" ] && mysql_filedirdate="$dbms_filedirdate_default"
  [ "$mysql_numfiles" = "" ] && mysql_numfiles="$dbms_numfiles_default"
  [ "$mysql_daysfiles" = "" ] && mysql_daysfiles="$dbms_daysfiles_default"
  [ "$mysql_zipmode" = "" ] && mysql_zipmode="$dbms_zipmode_default"
  [ "$mysql_preserve" = "" ] && mysql_preserve="$dbms_preserve_default"

  # DBMSes (individual defaults; see also above)
  # MySQL
  [ "${mysql_pwfile+X}" = "" ] && mysql_pwfile="$mysql_pwfile_default"
  [ "$mysql_dbmode" = "" ] && mysql_dbmode="$mysql_dbmode_default"
  [ "$mysql_splitdbs" = "" ] && mysql_splitdbs="$mysql_splitdbs_default"
  declare -p "mysql_dumpoptions" > /dev/null 2>&1 || \
      copyarray "mysql_dumpoptions_default" "mysql_dumpoptions"
  [ "$mysql_usealtopts" = "" ] && mysql_usealtopts="$mysql_usealtopts_default"
  [ "${mysql_fileprefix+X}" = "" ] && mysql_fileprefix="$mysql_fileprefix_default"
  [ "${mysql_subdirprefix+X}" = "" ] && mysql_subdirprefix="$mysql_subdirprefix_default"
}

#
# validate the configuration settings
#
# adjusts/blanks some settings based on others; e.g.:
# - host/port -> "localhost"/localport when using tunnels
# - ignore socketfile when using TCP
#
# also un-sparses arrays to be on the safe side
#
# (in the notes below, [tun] = all tunnel prefixes (e.g., "rsync" and the
# members of $dbmslist), and [dbms] = all of the members of $dbmslist)
#
# "local" vars: dbms
# global vars: dbmslist
# config settings: (most of them)
# library functions: validnoblank(), validnoblankarr(), validnotbothblank(),
#                    validnum(), validnochar(), validrwxdir(),
#                    validcreate(), validreadfile(), validrwfile(),
#                    validlist(), copyvar(), unsparsearray()
# utilities: [
# files: $startedfile, $lockfile, $alertfile, $outputlog, $statuslog,
#        $rsync_sshkeyfile, $rsync_pwfile, $rsync_filterfile,
#        $[dbms]_sshkeyfile, $[dbms]_socketfile, $[dbms]_pwfile,
#        $[dbms]_dumpdir
# bashisms: printf -v [v3.1]
#
validconf () {
  # housekeeping
  #
  # note: umask could be symbolic, not going to try to parse it
  validlist "timecomptype" "find" "date-r" "date-d" "awk" "gawk"
  validlist "filecomptype" "cmp" "diff"
  validlist "debugme" "yes" "no"
  validlist "on_tunerr" "phase" "exit"
  validlist "on_dblisterr" "phase" "exit"
  validlist "on_dbcharerr" "phase" "exit"
  validlist "on_dbduplerr" "ignore" "warn" "db" "phase" "exit"
  validlist "on_dbdumperr" "db" "phase" "exit"
  validlist "on_dbziperr" "db" "phase" "exit"

  # checks and logging
  validnum "runevery"
  validcreate "startedfile" "file"
  validcreate "lockfile" "dir"
  validnum "ifrunning"
  validcreate "alertfile" "file"
  validlist "suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    validnoblank "mailto"
    validnoblank "subject"
  fi
  if [ "$outputlog" != "" ]; then
    validcreate "outputlog" "file" "rotate"
    validlist "outputlog_layout" "append" "number" "date"
    validnochar "outputlog_sep" "/"
    validnochar "outputlog_date" "/"
    if [ "$outputlog_layout" != "append" ]; then
      validnum "numlogs"
      validnum "dayslogs"
    fi
  fi
  validlist "usesyslog" "yes" "no"
  validlist "quiet" "yes" "no"
  [ "$statuslog" != "" ] && validcreate "statuslog" "file"

  # rsync, including SSH tunnel
  validlist "do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    validlist "rsync_mode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsync_mode" = "tunnel" ]; then
      validnoblank "rsync_sshhost"
      validnum "rsync_localport" 1 65535
      validnum "rsync_remoteport" 1 65535
      validnum "rsync_sshtimeout" 1
      # use the local port for rsync_port
      rsync_port="$rsync_localport"
    fi
    if [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "nodaemon" ]; then
      [ "$rsync_sshkeyfile" != "" ] && validreadfile "rsync_sshkeyfile"
      [ "$rsync_sshport" != "" ] && validnum "rsync_sshport" 1 65535
      unsparsearray "rsync_sshoptions"
    fi
    validnoblankarr "rsync_source"
    unsparsearray "rsync_source"
    validnoblank "rsync_dest"
    if [ "$rsync_mode" = "direct" ]; then
      [ "$rsync_port" != "" ] && validnum "rsync_port" 1 65535
    fi
    { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
        [ "$rsync_pwfile" != "" ] && validreadfile "rsync_pwfile"
    [ "$rsync_filterfile" != "" ] && validreadfile "rsync_filterfile"
    unsparsearray "rsync_options"
    unsparsearray "rsync_add"
  fi

  # DBMS dumps, including SSH tunnels
  for dbms in $dbmslist; do
    switchdbms "$dbms"
    switchtunnel "$dbms"

    # note: lines like
    #   validlist "${dbms}_dodump" "yes" "no"
    # are passing, e.g., "mysql_dodump",
    # but lines like
    #   if [ "$dbms_dodump" = "yes" ]; then
    # are referencing the dbms_dodump variable...

    # mirror all changes to the ${dbms}_ vars in the dbms_ vars, in case
    # we need them further down (and on principle); same with tun_

    validlist "${dbms}_dodump" "yes" "no"
    if [ "$dbms_dodump" = "yes" ]; then
      validlist "${dbms}_usetunnel" "yes" "no"
      if [ "$dbms_usetunnel" = "yes" ]; then
        validnoblank "${dbms}_sshhost"
        [ "$tun_sshkeyfile" != "" ] && validreadfile "${dbms}_sshkeyfile"
        [ "$tun_sshport" != "" ] && validnum "${dbms}_sshport" 1 65535
        validnum "${dbms}_localport" 1 65535
        validnum "${dbms}_remoteport" 1 65535
        validnum "${dbms}_sshtimeout" 1
        unsparsearray "${dbms}_sshoptions"
        unsparsearray "tun_sshoptions"
        # adjust/ignore these
        printf -v "${dbms}_host" "%s" "localhost"
        dbms_host="localhost"
        copyvar "${dbms}_localport" "${dbms}_port"
        copyvar "${dbms}_localport" "dbms_port"
        printf -v "${dbms}_socketfile" "%s" ""
        dbms_socketfile=""
      else
        if [ "$dbms_host" != "" ]; then  # nothing to validate, but...
          # ignore socketfile
          printf -v "${dbms}_socketfile" "%s" ""
          dbms_socketfile=""
        fi
        if [ "$dbms_port" != "" ]; then
          validnum "${dbms}_port" 1 65535
          # ignore socketfile
          printf -v "${dbms}_socketfile" "%s" ""
          dbms_socketfile=""
        fi
        [ "$dbms_socketfile" != "" ] && validrwfile "${dbms}_socketfile"
      fi  # if [ "$dbms_usetunnel" = "yes" ]
      [ "$dbms_pwfile" != "" ] && validreadfile "${dbms}_pwfile"
      validlist "${dbms}_dbmode" "all" "include" "exclude"
      unsparsearray "${dbms}_dblist"
      unsparsearray "dbms_dblist"
      validlist "${dbms}_splitdbs" "yes" "no"
      unsparsearray "${dbms}_options"
      unsparsearray "dbms_options"
      unsparsearray "${dbms}_dumpoptions"
      unsparsearray "dbms_dumpoptions"
      unsparsearray "${dbms}_dumponeoptions"
      unsparsearray "dbms_dumponeoptions"
      unsparsearray "${dbms}_dumpmultoptions"
      unsparsearray "dbms_dumpmultoptions"
      unsparsearray "${dbms}_dumpalloptions"
      unsparsearray "dbms_dumpalloptions"
      validlist "${dbms}_usealtopts" "yes" "no"
      validrwxdir "${dbms}_dumpdir"
      validlist "${dbms}_layout" "single" "number" "date" "singledir" \
                "numberdir" "datedir"
      [ "$dbms_splitdbs" = "no" ] && [ "$dbms_layout" != "date" ] && \
          validnotbothblank "${dbms}_fileprefix" "${dbms}_filesuffix"
      validnochar "${dbms}_fileprefix" "/"
      validnochar "${dbms}_filesuffix" "/"
      { [ "$dbms_layout" = "singledir" ] || [ "$dbms_layout" = "numberdir" ]; } && \
          validnoblank "${dbms}_subdirprefix"
      validnochar "${dbms}_subdirprefix" "/"
      validnochar "${dbms}_filedirsep" "/"
      validnochar "${dbms}_filedirdate" "/"
      if [ "$dbms_layout" != "single" ] && [ "$dbms_layout" != "singledir" ]; then
        validnum "${dbms}_numfiles"
        validnum "${dbms}_daysfiles"
      fi
      validlist "${dbms}_zipmode" "none" "gzip" "pigz" "bzip2" "lzip"
      unsparsearray "${dbms}_zipoptions"
      unsparsearray "dbms_zipoptions"
      validlist "${dbms}_preserve" "data" "space"
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist
}


###########################
# core functions: DB dumps
###########################

#
# run a command to dump a single database to stdout
#
# (may not be possible with all DBMSes; see also dbdumpmultcmd(),
# dbdumpallcmd())
#
# $1 is the name of the database to dump
#
# dbms_prefix must be one of the accepted values (see dbmslist)
#
# when using an SSH tunnel, set host to "localhost" and port to the local
# port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# altopts and [dbms]_dumpoptions/[dbms]_dumponeoptions/etc. must be indexed,
# non-sparse arrays
#
# "local" vars: opts_l
# global vars: dbms_prefix, altopts
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile, [dbms]_splitdbs,
#                  [dbms]_dumpoptions/[dbms]_dumponeoptions/etc. (depending
#                  on the DBMS), [dbms]_usealtopts
# config functions: [dbms]_altopts()
# library functions: copyarray()
# utilities: mysqldump, [
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumponecmd () {
  case "$dbms_prefix" in
    mysql)
      if [ "$mysql_splitdbs" = "yes" ] && \
         [ "$mysql_usealtopts" = "yes" ] && mysql_altopts "$1"; then
        copyarray "altopts" "opts_l"
      else
        copyarray "mysql_dumpoptions" "opts_l"
      fi

      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${opts_l+"${opts_l[@]}"} \
        "$1"
      ;;
  esac
}

#
# run a command to dump multiple databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpallcmd())
#
# the names of the databases to dump must be in the dbnames array
#
# dbms_prefix must be one of the accepted values (see dbmslist)
#
# when using an SSH tunnel, set host to "localhost" and port to the local
# port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# dbnames and [dbms]_dumpoptions/[dbms]_dumpmultoptions/etc. must be indexed,
# non-sparse arrays
#
# global vars: dbnames, dbms_prefix
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile,
#                  [dbms]_dumpoptions/[dbms]_dumpmultoptions/etc. (depending
#                  on the DBMS)
# utilities: mysqldump
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumpmultcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${mysql_dumpoptions+"${mysql_dumpoptions[@]}"} \
        -B "${dbnames[@]}"
      ;;
  esac
}

#
# run a command to dump all databases to stdout
#
# (may not be possible with all DBMSes; see also dbdumponecmd(),
# dbdumpmultcmd())
#
# dbms_prefix must be one of the accepted values (see dbmslist)
#
# when using an SSH tunnel, set host to "localhost" and port to the local
# port of the tunnel
#
# (in the notes below, [dbms] = the value of $dbms_prefix)
#
# [dbms]_dumpoptions/[dbms]_dumpalloptions/etc. must be indexed, non-sparse
# arrays
#
# global vars: dbms_prefix
# config settings: [dbms]_user, [dbms]_pwfile, [dbms]_protocol, [dbms]_host,
#                  [dbms]_port, [dbms]_socketfile,
#                  [dbms]_dumpoptions/[dbms]_dumpalloptions/etc. (depending
#                  on the DBMS)
# utilities: mysqldump
# files: $[dbms]_pwfile, $[dbms]_socketfile
# bashisms: arrays
#
dbdumpallcmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option if present
      mysqldump \
        ${mysql_pwfile:+"--defaults-extra-file=$mysql_pwfile"} \
        ${mysql_user:+-u "$mysql_user"} \
        ${mysql_protocol:+"--protocol=$mysql_protocol"} \
        ${mysql_host:+-h "$mysql_host"} \
        ${mysql_port:+-P "$mysql_port"} \
        ${mysql_socketfile:+-S "$mysql_socketfile"} \
        ${mysql_dumpoptions+"${mysql_dumpoptions[@]}"} \
        -A
      ;;
  esac
}

#
#
# get the list of all DBs if necessary
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# dbms_prefix must be one of the accepted values (see dbmslist)
#
# local vars: dbms
# global vars: dbms_prefix, dbms_dbmode, dbms_splitdbs, alldbs, alldbstmp,
#              getdblist_exitval, dblistchar_exitval, dbmslist
# config settings: lockfile, on_dblisterr, on_dbcharerr
# library vars: newline, tab
# library functions: dblistcmd(), filecomp(), logstatusquiet(), logstatus(),
#                    sendalert(), do_exit()
# utilities: rm, tr, printf, [
# files: $lockfile/$alldbs$dbms_prefix,
#        $lockfile/$alldbs$dbms_prefix$alldbstmp
# FDs: 3
#
getdblist () {
  # remove any existing files, to prevent both confusion and noclobber-type
  # issues
  rm -f "$lockfile/$alldbs$dbms_prefix"
  rm -f "$lockfile/$alldbs$dbms_prefix$alldbstmp"

  # do we need the list?
  case "$dbms_prefix" in
    # use dbms_ vars in case we need to lump DBMSes together
    mysql)
      if { [ "$dbms_dbmode" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
         || \
         [ "$dbms_dbmode" = "exclude" ]; then
        :  # avoid non-portable 'if !'
      else
        return 0
      fi
      ;;
  esac

  # log that we're running the command
  logstatusquiet "running $dbms_prefix get-DB-list command"
  printf "%s\n" "running $dbms_prefix get-DB-list command" >&3

  # run the command
  dblistcmd > "$lockfile/$alldbs$dbms_prefix" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    sendalert "could not get the list of $dbms_prefix databases; exiting" log
    case "$on_dblisterr" in
      exit)
        do_exit "$getdblist_exitval"
        ;;
      phase)
        return 1  # skip to the next phase
        ;;
    esac
  else
    logstatus "obtained the list of $dbms_prefix databases"
  fi

  # separate this by DBMS in case some have different output formats,
  # but most can probably be lumped together;
  # however, they all need to be massaged into the same format:
  # DB names separated by newlines, with these encodings:
  # newline -> \n
  # tab -> \t
  # \ -> \\

  case "$dbms_prefix" in
    mysql)
      # check for characters that could break out of a quoted string,
      # or drop into one
      #
      # could be done more simply with egrep/grep -E, but this way is
      # probably more portable
      tr -d "'\"\`$" < "$lockfile/$alldbs$dbms_prefix" \
                     > "$lockfile/$alldbs$dbms_prefix$alldbstmp"
      if filecomp "$lockfile/$alldbs$dbms_prefix" \
                  "$lockfile/$alldbs$dbms_prefix$alldbstmp" 2>/dev/null; then
        :  # avoid non-portable 'if !'
      else  # cover both mismatch and error
        sendalert "the list of $dbms_prefix databases contains a dangerous character; exiting" log
        case "$on_dbcharerr" in
          exit)
            do_exit "$dblistchar_exitval"
            ;;
          phase)
            return 1  # skip to the next phase
            ;;
        esac
      fi
      ;;
  esac

  return 0
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary
#
# this populates two sets of path variables: one for the dump, with a place
# for the DB name, and one for the rotation/pruning, with a place for the
# number/date (and a place for the DB name, if $dbms_layout is not a "dir"
# option)
#
# note that for "number"/"numberdir" layouts, dumpprefix and dumpsuffix omit
# the number, because the most recent version is unnumbered
#
# mkdir -p isn't portable, so subdirectories must be directly under the
# dumpdir (until/unless we emulate it...)
#
# global vars: dumpprefix, dumpsuffix, rotateprefix, rotatesep,
#              rotatesuffix, dbms_splitdbs, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_datestring
# utilities: mkdir, [
#
getdumppaths () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
      else
        rotatesep="$dbms_filedirsep"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
        dumpsuffix="$dbms_datestring$dbms_filesuffix"
      else
        rotatesep="$dbms_filedirsep"
        dumpsuffix="$dbms_filedirsep$dbms_datestring$dbms_filesuffix"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    singledir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    numberdir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
      rotatesep="$dbms_filedirsep"
      rotatesuffix=""
      ;;
    datedir)
      if [ "$dbms_subdirprefix" = "" ]; then
        [ ! -d "$dbms_dumpdir/$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/"
        rotatesep=""
      else
        [ ! -d "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep"
        dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
        rotatesep="$dbms_filedirsep"
      fi
      dumpsuffix="$dbms_filesuffix"
      rotatesuffix=""
      ;;
  esac
}

#
# do a single DB dump pass, including file rotation, etc.
# (one pass = one dump command, but may be more than one DB)
#
# $1 is "one", "mult", or "all" (how many DBs to dump; see dbdumponecmd(),
# dbdumpmultcmd(), dbdumpallcmd())
#
# if $1 is "one", $2 is the name of the database to dump
# if $1 is "mult", the names of the databases to dump must be in the dbnames
# array
#
# returns 1 to mean "skip to the next phase of the backup",
# 2 to mean "we have skipped this dump",
# else 0
#
# see getdumppaths() for info about dumpprefix/dumpsuffix
#
# dbnames and dbms_zipoptions must be indexed, non-sparse arrays
#
# "local" vars: dumptype, dbname, fileexists
# global vars: dbnames, dumptmp, dumpprefix, dumpsuffix, rotateprefix,
#              rotatesep, rotatesuffix, dbms_prefix, dbms_layout,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve, dumpexists_exitval, dbdump_exitval,
#              dbzip_exitval
# config settings: on_duplerr, on_dbdumperr, on_dbziperr
# library vars: newline
# library functions: rotatenumfiles(), prunefiles(), existsfilezip(),
#                    removefilezip(), dbdumponecmd(), dbdumpmultcmd(),
#                    dbdumpallcmd(), sendalert(), logstatus(),
#                    logstatusquiet(), do_exit()
# utilities: (allowed values of $dbms_zipmode), rm, mv, date, printf, [
# FDs: 3
# bashisms: arrays
#
do_dbdump () {
  dumptype="$1"
  dbname="$2"  # will be null unless $1 is "one"

  # rotate if we need to, to make way for the new dump
  case "$dbms_layout" in
    number)
      rotatenumfiles "$rotateprefix$dbname" "$rotatesep" "$rotatesuffix"
      ;;
    numberdir)
      rotatenumfiles "$rotateprefix" "$rotatesep" "$rotatesuffix"
      ;;
  esac

  # are we (still) about to overwrite an existing dump?
  fileexists="no"
  if [ "$dbms_layout" != "single" ] \
     && \
     [ "$dbms_layout" != "singledir" ] \
     && \
     existsfilezip "$dumpprefix$dbname$dumpsuffix"; then
    fileexists="yes"
  fi

  if [ "$fileexists" = "yes" ]; then
    case "$on_dbduplerr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists; exiting" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; exiting" log
        fi
        do_exit "$dumpexists_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists;${newline}skipping to next phase of backup" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists;${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database '$dbname' already exists; skipping" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; skipping" log
        fi
        return 2  # skip to the next DB
        ;;
      warn)
        if [ "$dbname" != "" ]; then
          sendalert "warning: dumpfile for $dbms_prefix database '$dbname' already exists; overwriting" log
        else
          sendalert "warning: dumpfile for $dbms_prefix database(s) already exists; overwriting" log
        fi
        ;;
      ignore)
        :  # do nothing
        ;;
    esac
  fi

  # clean up ("space" preservation mode; see below)
  if [ "$dbms_preserve" = "space" ]; then
    # prune old dumpfiles
    case "$dbms_layout" in
      number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac

    # remove any current dumpfile that's in the way ("single"/"singledir",
    # or from, e.g., rerunning the backup)
    removefilezip "$dumpprefix$dbname$dumpsuffix" "$dbms_zipmode"
  fi

  # if we're dumping a single database, log the name
  if [ "$dbname" != "" ]; then
    logstatus "dumping $dbms_prefix database '$dbname'"
  fi

  # log that we're running the command
  if [ "$dbname" != "" ]; then
    logstatusquiet "running $dbms_prefix dump command for database '$dbname'"
    printf "%s\n" "running $dbms_prefix dump command for database '$dbname'" >&3
  else
    logstatusquiet "running $dbms_prefix dump command"
    printf "%s\n" "running $dbms_prefix dump command" >&3
  fi

  # starting timestamp
  printf "%s\n" "$dbms_prefix dump started $(date)" >&3

  # run the command
  case "$dbms_preserve" in
    data)
      rm -f "$dumpprefix$dbname$dumpsuffix$dumptmp"  # safer for >
      case "$dumptype" in
        one)
          dbdumponecmd "$dbname" > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
          ;;
        mult)
          # uses dbnames array
          dbdumpmultcmd > "$dumpprefix$dumpsuffix$dumptmp" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dumpsuffix$dumptmp" 2>&3
          ;;
      esac
      ;;
    space)
      case "$dumptype" in
        one)
          dbdumponecmd "$dbname" > "$dumpprefix$dbname$dumpsuffix" 2>&3
          ;;
        mult)
          # uses dbnames array
          dbdumpmultcmd > "$dumpprefix$dumpsuffix" 2>&3
          ;;
        all)
          dbdumpallcmd > "$dumpprefix$dumpsuffix" 2>&3
          ;;
      esac
      ;;
  esac

  # check status
  if [ "$?" != 0 ]; then
    case "$on_dbdumperr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname'; exiting" log
        else
          sendalert "error dumping $dbms_prefix database(s); exiting" log
        fi
        do_exit "$dbdump_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname';${newline}skipping to next phase of backup" log
        else
          sendalert "error dumping $dbms_prefix database(s);${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database '$dbname'; skipping" log
        else
          sendalert "error dumping $dbms_prefix database(s); skipping" log
        fi
        return 2  # skip to the next DB
        ;;
    esac
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped $dbms_prefix database '$dbname'"
    else
      logstatus "successfully dumped $dbms_prefix database(s)"
    fi
  fi

  # ending timestamp
  printf "%s\n" "$dbms_prefix dump finished $(date)" >&3

  # clean up ("data" preservation mode; see above)
  if [ "$dbms_preserve" = "data" ]; then
    # remove current dumpfile (including zips), and move the temp file into
    # place
    #
    # only really need the zip part of this, since we use mv -f
    removefilezip "$dumpprefix$dbname$dumpsuffix" "$dbms_zipmode"
    mv -f "$dumpprefix$dbname$dumpsuffix$dumptmp" \
          "$dumpprefix$dbname$dumpsuffix"

    # prune old dumpfiles
    case "$dbms_layout" in
      number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac
  fi

  # zip current dumpfile
  #
  # wait until after pruning; we use less total space during the backup
  # process, and don't sacrifice any data preservation gain
  if [ "$dbms_zipmode" != "none" ]; then
    # starting timestamp
    printf "%s\n" "$dbms_zipmode started $(date)" >&3

    # do the zip
    "$dbms_zipmode" "${dbms_zipoptions[@]}" \
                    "$dumpprefix$dbname$dumpsuffix" >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      case "$on_dbziperr" in
        exit)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname'; exiting" log
          else
            sendalert "error compressing $dbms_prefix database(s); exiting" log
          fi
          do_exit "$dbzip_exitval"
          ;;
        phase)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname';${newline}skipping to next phase of backup" log
          else
            sendalert "error compressing $dbms_prefix database(s);${newline}skipping to next phase of backup" log
          fi
          return 1  # skip to the next phase
          ;;
        db)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database '$dbname'; skipping" log
          else
            sendalert "error compressing $dbms_prefix database(s); skipping" log
          fi
          return 2  # skip to the next DB
          ;;
      esac
    else
      if [ "$dbname" != "" ]; then
        logstatus "successfully compressed $dbms_prefix database '$dbname'"
      else
        logstatus "successfully compressed $dbms_prefix database(s)"
      fi
    fi
    # ending timestamp
    printf "%s\n" "$dbms_zipmode finished $(date)" >&3
  fi

  return 0
}

#
# wrapper around the different modes of DB dumps
# (split/unsplit, all/include/exclude/etc.)
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# dbms_dblist must be an indexed, non-sparse array
#
# "local" vars: OLDIFS, dbname_esc, dbname, exclude
# global vars: IFS, dbnames, dbms_prefix, dbms_dbmode, dbms_dblist,
#              dbms_splitdbs, alldbs
# config settings: lockfile
# library functions: copyarray(), dbunescape()
# utilities: [
# files: $lockfile/$alldbs$dbms_prefix
# bashisms: array+=() [v3.1]
#
do_dbdumploop () {
  OLDIFS="$IFS"

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbmode" in
      all)
        do_dbdump "all"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      include)
        copyarray "dbms_dblist" "dbnames"

        do_dbdump "mult"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
      exclude)
        dbnames=()
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs$dbms_prefix"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          for exclude in "${dbms_dblist[@]}"; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done

          dbnames+=("$dbname")
          IFS=""
        done < "$lockfile/$alldbs$dbms_prefix"
        IFS="$OLDIFS"

        do_dbdump "mult"
        [ "$?" = "1" ] && return 1  # skip to the next phase
        ;;
    esac  # case "$dbms_dbmode"
  else  # dbms_splitdbs="yes"
    case "$dbms_dbmode" in
      all)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs$dbms_prefix"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase

          IFS=""
        done < "$lockfile/$alldbs$dbms_prefix"
        IFS="$OLDIFS"
        ;;
      include)
        for dbname in "${dbms_dblist[@]}"; do
          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
        done
        ;;
      exclude)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs$dbms_prefix"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          for exclude in "${dbms_dblist[@]}"; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done

          do_dbdump "one" "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase

          IFS=""
        done < "$lockfile/$alldbs$dbms_prefix"
        IFS="$OLDIFS"
       ;;
    esac  # case "$dbms_dbmode"
  fi  # if [ "$dbms_splitdbs" = "no" ]

  return 0
}


##########################################
# command line and configuration settings
##########################################

configfile=""
noconfigfile="no"
mode=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    -f)
      shift
      if [ "$#" = "0" ]; then
        throwusageerr "Error: -f requires a config-file path; exiting."
      else
        configfile="$1"
        noconfigfile="no"
        shift
      fi
      ;;
    -n)
      noconfigfile="yes"
      configfile=""
      shift
      ;;
    *)
      mode="${1#--}"
      shift
      ;;
  esac
done

validlist "mode" "" "help" "usage" "license" "config" "settings" \
          "status" "statusall" "silence" "unsilence" "stop" "disable" \
          "start" "enable" "clearlock" "unlock" "create" "systemtest"

# first deal with the modes that don't require sourcing the config file
# or dealing with settings
case "$mode" in
  help|usage)
    # print the usage message
    usage
    do_exit "$no_error_exitval"
    ;;
  license)
    # print the license message
    license
    do_exit "$no_error_exitval"
    ;;
  create)
    createblankconfig "# see CONFIG for details"
    if [ "$?" = "1" ]; then
      throwusageerr "Error: specified config file already exists; exiting."
    else
      do_exit "$no_error_exitval"
    fi
    ;;
esac

# process command-line settings and the config file
do_config

# debug mode?
# (in case it was turned on in the config file, but not on the command line;
# see above)
if [ "$debugme" = "yes" ]; then
  do_debug
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$mode" in
  config|settings)
    # print the current config settings
    echo
    printconfig
    echo
    do_exit "$no_error_exitval"
    ;;
  status|statusall)
    # print the current status
    echo
    if [ "$mode" = "statusall" ]; then  # include temp files
      printstatus all
    else
      printstatus
    fi
    echo
    do_exit "$no_error_exitval"
    ;;
  silence)
    # silence lockfile-exists alerts
    silencelfalerts
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    unsilencelfalerts
    ;;
  stop|disable)
    # disable backups
    disablescript "a" "backup" "backups"
    ;;
  start|enable)
    # re-enable backups
    enablescript "a" "backup" "backups"
    ;;
  clearlock|unlock)
    # remove lockfile dir
    clearlock "a" "backup"
    ;;
  systemtest)
    checkextcmds
    do_exit "$no_error_exitval"
    ;;
esac

# log config file, current working directory, and setting variables supplied
# on the command line
logclconfig


################
# status checks
################

checkstatus "backup" "backups"


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for the current DB dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      dbms_datestring=$(date "$dbms_filedirdate")
    else
      dbms_datestring=$(date)
    fi
    printf -v "${dbms}_datestring" "%s" "$dbms_datestring"
  fi
done

# output log datestring is included in startoutputlog(), called below


###################
# start output log
###################

startoutputlog  # includes getting output log datestring


################
# begin working
################

# log starting messages and timestamp, and touch $startedfile
do_start

# are we supposed to actually do anything?
do_something="no"  # set this to yes later if we do something


###########
# DB dumps
###########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_dbms () {
  if [ "$dbms_usetunnel" = "yes" ]; then
    closesshtunnel
  fi
}

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    do_something="yes"

    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms"
      opensshtunnel
      [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase
    fi

    # get the list of all DBs if necessary
    getdblist
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary
    getdumppaths

    # do the actual dump(s)
    do_dbdumploop
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_rsync () {
  # close the SSH tunnel
  if [ "$rsync_mode" = "tunnel" ]; then
    closesshtunnel
  fi
}

while true; do  # only here to allow us to easily skip to the next phase
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    logstatus "starting rsync backup sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync"
      opensshtunnel
      [ "$?" = "1" ] && skip_rsync && break  # skip to the next phase
    fi

    # log that we're running the command
    logstatusquiet "running rsync command"
    printf "%s\n" "running rsync command" >&3

    # starting timestamp
    printf "%s\n" "rsync started $(date)" >&3

    # run the command
    rsynccmd >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      sendalert "warning: rsync finished with errors; please check the log" log
      setexitval "$rsync_exitval"
    else
      logstatus "rsync completed without errors"
    fi

    # ending timestamp
    printf "%s\n" "rsync finished $(date)" >&3

    # close the SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      closesshtunnel
    fi

    logstatus "rsync backup sequence completed"
  fi

  break  # don't actually loop
done


###############
# done working
###############

# did we actually do anything?
if [ "$do_something" = "no" ]; then  # everything was turned off
  logstatus "nothing to do, because no actions are turned on"
fi

# log finished messages and timestamp
do_finish


##################
# stop output log
##################

stopoutputlog


###########
# clean up
###########

do_exit "$no_error_exitval"
