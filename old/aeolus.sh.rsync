#!/bin/sh

###################################
# configurable rsync backup script
# by Daniel Malament
###################################

# see usage() and the backup.usage and config files for usage notes

# exit values (if there are multiple errors, the first one to occur is used):
# 0 = no error (e.g. runevery hasn't expired, or backup was completed
#     without errors)
# 1 = problem with the script invocation, the config file, or a setting
# 2 = previous lockfile still exists (possibly because backups were
#     manually disabled)
# 3 = problem opening ssh tunnel
# 4 = there were rsync errors

# lockfile dir is used for the following files:
# disable, silencealerts, timetemp, logfifo

# modification note: any change to the setting variables (additions,
# deletions, name changes, type changes, etc.) must be reflected
# in sendalert(), checkconf(), savevars(), logclvars(), and restorevars()


# TODO:
# do more to protect against leading - in settings?
# better handling of long errors?
# i18n?
#
# setup notes
# setup modes?
#
# name & refs, incl repl. $0
#
# modularity
# mysql, postgres, etc.
#
# checker script
# self-updating?


############
# debugging
############

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
if [ "$debugme" = "yes" ]; then
  set -x
fi


##############################################
# helper functions: housekeeping and wrappers
##############################################

#
# update an exit value for the script
#
# if the value has already been set, don't change it,
# so that we can return the value corresponding to
# the first error encountered
#
# global vars: exitval
#
exitval="-1"
setexitval () {
  if [ "$exitval" = "-1" ]; then
    exitval="$1"
  fi
}

#
# update exit value (see setexitval()) and exit, possibly doing some cleanup
#
# $1 = exit value (required)
# if $2 = "clean", remove the lockfile, unless the disable semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: lockfile, exitval
#
do_exit () {
  if [ "$2" = "clean" ]; then
    if [ ! -f "$lockfile/disable" ]; then
      rm -r "$lockfile"
    fi
    # otherwise, a disable command must have been run while we were
    # doing this backup; leave the lockfile dir alone, so future backups
    # will be disabled
  fi

  setexitval "$1"
  exit "$exitval"
}

#
# get the parent directory of a file or dir
#
# this is more portable and more correct than dirname;
# in particular, dirname returns . for any of . ./ .. ../
# which fits the documentation, but doesn't make sense, at least not here
#
# to get the "standard" behavior, make $2 non-null
#
# "local" vars: parentdir
#
getparentdir () {
  # remove trailing /'s
  parentdir="`echo "$1" | sed 's|/*$||'`"

  # are there no /'s left?
  if echo "$parentdir" | grep -v '/' > /dev/null 2>&1; then
    if [ "$parentdir" = "" ]; then
      echo "/"  # it was /, and / is its own parent
      return
    fi
    if [ "$2" = "" ]; then
      if [ "$parentdir" = "." ]; then
        echo ".."
        return
      fi
      if [ "$parentdir" = ".." ]; then
        echo "../.."
        return
      fi
    fi
    echo "."
    return
  fi
  parentdir="`echo "$parentdir" | sed 's|/*[^/]*$||'`"
  if [ "$parentdir" = "" ]; then
    echo "/"
    return
  fi
  echo "$parentdir"
}

# tests for getparentdir:
#getparentdir //                   # /
#getparentdir //foo                # /
#getparentdir //foo//              # /
#getparentdir //foo//bar           # //foo
#getparentdir //foo//bar//         # //foo
#getparentdir //foo//bar//baz      # //foo//bar
#getparentdir //foo//bar//baz//    # //foo//bar
#getparentdir .                    # ..
#getparentdir .//                  # ..
#getparentdir . x                  # .
#getparentdir .// x                # .
#getparentdir .//foo               # .
#getparentdir .//foo//             # .
#getparentdir .//foo//bar          # .//foo
#getparentdir .//foo//bar//        # .//foo
#getparentdir .//foo//bar//baz     # .//foo//bar
#getparentdir .//foo//bar//baz//   # .//foo//bar
#getparentdir ..                   # ../..
#getparentdir ..//                 # ../..
#getparentdir .. x                 # .
#getparentdir ..// x               # .
#getparentdir ..//foo              # ..
#getparentdir ..//foo//            # ..
#getparentdir ..//foo//bar         # ..//foo
#getparentdir ..//foo//bar//       # ..//foo
#getparentdir ..//foo//bar//baz    # ..//foo//bar
#getparentdir ..//foo//bar//baz//  # ..//foo//bar
#getparentdir foo                  # .
#getparentdir foo//                # .
#getparentdir foo//bar             # foo
#getparentdir foo//bar//           # foo
#getparentdir foo//bar//baz        # foo//bar
#getparentdir foo//bar//baz//      # foo//bar
#getparentdir foo//bar//baz// x    # foo//bar
#exit

#
# check if the file in $1 is less than $2 minutes old
#
# file must exist; check before calling
#
# factored out for simplicity, but it's also a wrapper to choose between
# different non-portable methods (some of which use $lockfile/timetemp)
#
# "local" vars: curtime, filetime, timediff, reftime
# global vars: timechecktype, lockfile
#
newerthan () {
  case "$timechecktype" in
    find)
      # find returns 0 even if no files are matched
      find "$1" \! -mmin +"$2" | grep "^$1$" > /dev/null 2>&1
      return "$?"
      ;;
    date-r)
      curtime="`date "+%s"`"
      filetime="`date -r "$1" "+%s"`"
      # expr is more portable than $(())
      timediff="`expr \( "$curtime" - "$filetime" \) / 60`"
      if [ "$timediff" -lt "$2" ]; then
        return 0;  # true (newer)
      else
        return 1;  # false (older)
      fi
      ;;
    date-d)
      reftime="`date -d "$2 minutes ago" "+%Y%m%d%H%M.%S"`"
      ;;  # continue after esac
    awk|gawk)
      reftime="`echo | "$timechecktype" \
              '{print strftime("%Y%m%d%H%M.%S", systime() - ('"$2"' * 60))}'`"
      ;;  # continue after esac
  esac
  touch -t "$reftime" "$lockfile/timetemp"
  # find returns 0 even if no files are matched
  find "$1" -newer "$lockfile/timetemp" | grep "^$1$" > /dev/null 2>&1
}


#######################################
# helper functions: logging and alerts
#######################################

#
# log a message ($1) to the status log
# (depending on $statuslog)
#
# global vars: statuslog
#
logstatlog () {
  if [ "$statuslog" != "" ]; then
    # quotes preserve spacing in output of date
    echo "`date` [$$]: $1" >> "$statuslog"
  fi
}

#
# log a message ($1) to stdout and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprint () {
  # use "$1" to preserve spacing

  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    echo "$1"
  fi

  logstatlog "$1"
}

#
# log a message ($1) to stderr and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprinterr () {
  # use "$1" to preserve spacing

  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    echo "$1" 1>&2
  fi

  logstatlog "$1"
}

#
# actually send a syslog message; factored out here so logger
# is only called in one place, for maintainability
#
# $1 = message
# $2 = priority (facility.level or numeric)
#      (optional, use '.' if not passing priority but passing a tag)
# $3 = tag (optional)
#
# "local" vars: slcmd
#
do_syslog () {
  # see SECURITY NOTE, below, about this code
  slcmd="logger -i"
  [ "$2" != "" ] && [ "$2" != "." ] && slcmd="$slcmd -p \"$2\""
  [ "$3" != "" ] && slcmd="$slcmd -t \"$3\""
  slcmd="$slcmd \"$1\""
  eval "$slcmd"
}

#
# log a status message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogstat, syslogtag
#
logstatus () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; } then
    do_syslog "$1" "$syslogstat" "$syslogtag"
  fi

  logprint "$1"
}

#
# log an alert/error message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogerr, syslogtag
#
logalert () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; } then
    do_syslog "$1" "$syslogerr" "$syslogtag"
  fi

  logprint "$1"
}

#
# print the metadata of a file/dir if it exists,
# or "(none)" (used in alert emails)
#
# note: it would be nice to be able provide just timestamps,
# since the rest is much less useful here, and it would be easier
# to read, but it's more or less impossible to to that portably
#
getmetadata () {
  if [ -f "$1" ] || [ -d "$1" ]; then
    echo "`ls -ld "$1" 2>&1`"  # use echo "``" to preserve spacing
  else
    echo "(none)"
  fi
}

#
# send an alert email, including diagnostics,
# and log to syslog/terminal/status log that an email was sent
#
# * message begins with the contents of $1
# * if $2 is "log", also log $1 before the sent notice
#
# note: even if suppressemail="yes", $1 is still logged
# (if settings permit)
#
# global vars: suppressemail, mailto, subject, all other config settings
#
sendalert () {
  if [ "$suppressemail" != "yes" ]; then
    mailx -s "$subject" $mailto <<-EOF
	$1


	---------
	Settings:
	---------

	usepath="$usepath"
	timechecktype="$timechecktype"
	useumask="$useumask"
	debugme="$debugme"
	runevery="$runevery"
	startedfile="$startedfile"
	ifrunning="$ifrunning"
	lockfile="$lockfile"
	suppressemail="$suppressemail"
	mailto="$mailto"
	subject="$subject"
	alertfile="$alertfile"
	backuplog="$backuplog"
	numlogs="$numlogs"
	dayslogs="$dayslogs"
	usesyslog="$usesyslog"
	syslogstat="$syslogstat"
	syslogerr="$syslogerr"
	syslogtag="$syslogtag"
	quiet="$quiet"
	statuslog="$statuslog"
	sshlogin="$sshlogin"
	sshkey="$sshkey"
	sshport="$sshport"
	localport="$localport"
	remoteport="$remoteport"
	sshtimeout="$sshtimeout"
	rsyncmode="$rsyncmode"
	source="$source"
	dest="$dest"
	rsyncdport="$rsyncdport"
	passwordfile="$passwordfile"
	filterfile="$filterfile"
	rsyncoptions="$rsyncoptions"
	rsyncadd="$rsyncadd"


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	`getmetadata "$startedfile"`

	lockfile:
	`getmetadata "$lockfile"`

	alertfile:
	`getmetadata "$alertfile"`
	EOF
  fi

  if [ "$2" = "log" ]; then
    logalert "$1"
  fi

  if [ "$suppressemail" != "yes" ]; then
    logalert "alert email sent to $mailto"
  fi
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# NOTE: when updating this, update backup.usage as well
#
# "local" vars: scriptname
#
usage () {
  scriptname="`echo "$0" | sed 's|^.*/||'`"
  cat <<EOF 1>&2

Usage: [setting="value"] $scriptname /path/to/config/file [mode]

Multiple settings can be added to the command line, separated by spaces.

If the config file path is omitted, "./backup.conf" will be tried.

If the mode is "help" or "usage", this message is printed.

If the mode is "cmds", the ssh and rsync commands that would be run are
printed, but nothing else is done.

If the mode is "silence", then alerts about the lockfile existing will be
silenced until either they are unsilenced, or the lockfile is no longer present.

If the mode is "unsilence", then alerts about the lockfile existing will be
re-enabled.

If the mode is "stop" or "disable", then backups will be disabled until "start"
or "enable" is used.

If the mode is "start" or "enable", then backups will be re-enabled.

If the mode is "clearlock" or "unlock", then the lockfile will be removed.
Only use this if you're sure a backup isn't currently running!

EOF
}

#
# print a startup error to stderr and exit
#
# $1 = message
#
throwerr () {
  cat <<-EOF 1>&2

	$1

	EOF
  do_exit 1
}

#
# print a bad-setting error to stderr and exit
#
# $1 = variable name
# $2 = variable value
#
settingerr () {
  throwerr "Error: invalid setting for $1 (\"$2\"); exiting."
}

#
# validate a setting that can't be blank
#
# $1 = variable name
# $2 = variable value
#
checknoblank () {
  if [ "$2" = "" ]; then
    throwerr "Error: $1 is not set; exiting."
  fi
}

#
# validate a numeric setting (only 0-9 allowed)
#
# $1 = variable name
# $2 = variable value
# $3 = minimum (optional)
# $4 = maximum (optional)
#
checknum () {
  # use extra [0-9] to avoid having to use egrep
  if echo "$2" | grep '^[0-9][0-9]*$' > /dev/null 2>&1; then
    if [ "$3" != "" ] && [ "$2" -lt "$3" ]; then
      settingerr "$1" "$2"
    fi
    if [ "$4" != "" ] && [ "$2" -gt "$4" ]; then
      settingerr "$1" "$2"
    fi
  else
    settingerr "$1" "$2"
  fi
}

#
# validate a file setting, for files we're going to be touching,
# writing to, and/or creating:
# 1) it may not be blank
# 2) if the file exists, it must be a file or a directory
#    (or a link to one, since [ derefs links; dir is to allow for the
#    lockfile dir), and it must be writable
# 3) regardless, the parent directory must exist, be a directory,
#    and be writable
#
# $1 = variable name
# $2 = variable value
#
# "local" vars: parentdir
#
checkfile () {
  # condition 1
  checknoblank "$1" "$2"

  # condition 2
  #
  # note: [ -e ] isn't portable, so try ls, even though it's probably not
  # robust enough to be a general solution...
  if ls "$2" > /dev/null 2>&1; then
    if [ ! -f "$2" ] && [ ! -d "$2" ]; then
      throwerr "Error: $1 is not a file or directory; exiting."
    fi
    if [ ! -w "$2" ]; then
      throwerr "Error: $1 is not writable; exiting."
    fi
  fi

  # condition 3
  parentdir="`getparentdir "$2"`"
  if [ ! -d "$parentdir" ]; then
    throwerr "Error: $1 is in a non-existent directory (\"$parentdir\"); exiting."
  fi
  if [ ! -w "$parentdir" ]; then
    throwerr "Error: $1 is is a non-writable directory; exiting."
  fi
}

#
# validate a file setting, for files we just need to be able to read:
# setting must not be blank, and file must exist, be a file or a
# symlink to a file, and be readable
#
# $1 = variable name
# $2 = variable value
#
checkreadfile () {
  # blank?
  checknoblank "$1" "$2"

  # not a file or symlink to one?
  # ([ dereferences symlinks for us)
  if [ ! -f "$2" ]; then
    throwerr "Error: $1 does not exist, or is not a file or a symlink to one; exiting."
  fi

  # not readable?
  if [ ! -r "$2" ]; then
    throwerr "Error: $1 is not readable; exiting."
  fi
}

#
# validate a setting that can be one of a list of possiblities
#
# $1 = variable name (use "mode" for command-line mode setting)
# $2 = variable value
# other args = list of possiblities (can include "")
#
# "local" vars: vname, vval, poss
#
checklist () {
  vname="$1"
  vval="$2"
  shift
  shift  # shift 2 isn't portable

  #local i  # not portable, so use something else to prevent problems
  for poss;
  do  # has to be on a separate line for portability, when there's no 'in'
    if [ "$vval" = "$poss" ]; then
      return 0
    fi
  done

  if [ "$vname" = "mode" ]; then
    usage
    throwerr "Error: invalid mode supplied on the command line; exiting."
  else
    settingerr "$vname" "$vval"
  fi
}

#
# validate the configuration settings
#
# note: there are ways to get around having to supply both the name and
# the value of a variable, but they're not portable (and they can also be
# tricky and sometimes insecure)
#
# global vars: all config settings except usepath, useumask, syslogtag,
#              rsyncoptions, rsyncadd
#
checkconf () {
  # note: umask could be symbolic in some shells, so we can't use checknum
  checklist "timechecktype" "$timechecktype" "find" "date-r" "date-d" \
            "awk" "gawk"
  checklist "debugme" "$debugme" "yes" "no"
  checknum "runevery" "$runevery"
  checkfile "startedfile" "$startedfile"
  checknum "ifrunning" "$ifrunning"
  checkfile "lockfile" "$lockfile"
  checklist "suppressemail" "$suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    checknoblank "mailto" "$mailto"
    [ "$subject" = "" ] && subject="backup alert on `hostname`"
  fi
  checkfile "alertfile" "$alertfile"
  [ "$backuplog" != "" ] && checkfile "backuplog" "$backuplog"
  checknum "numlogs" "$numlogs"
  checknum "dayslogs" "$dayslogs"
  checklist "usesyslog" "$usesyslog" "all" "yes" "no"
  if [ "$usesyslog" != "no" ]; then
    [ "$syslogstat" = "" ] && syslogstat="."  # see do_syslog()
    [ "$syslogerr" = "" ] && syslogerr="."  # see do_syslog()
  fi
  checklist "quiet" "$quiet" "yes" "no"
  [ "$statuslog" != "" ] && checkfile "statuslog" "$statuslog"
  checklist "rsyncmode" "$rsyncmode" "tunnel" "direct" "nodaemon" "local"
  if [ "$rsyncmode" = "tunnel" ]; then
    checknoblank "sshlogin" "$sshlogin"
    [ "$localport" = "" ] && localport="8873"
    [ "$remoteport" = "" ] && remoteport="873"
    checknum "localport" "$localport" 1 65535
    checknum "remoteport" "$remoteport" 1 65535
    checknum "sshtimeout" "$sshtimeout" 1
  fi
  if [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "nodaemon" ]; then
    [ "$sshkey" != "" ] && checkreadfile "sshkey" "$sshkey"
    [ "$sshport" = "" ] && sshport="22"
    checknum "sshport" "$sshport" 1 65535
  fi
  checknoblank "source" "$source"
  checknoblank "dest" "$dest"
  if [ "$rsyncmode" = "direct" ]; then
    [ "$rsyncdport" = "" ] && rsyncdport="873"
    checknum "rsyncdport" "$rsyncdport" 1 65535
  fi
  { [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "direct" ]; } && \
      checkreadfile "passwordfile" "$passwordfile"
  [ "$filterfile" != "" ] && checkreadfile "filterfile" "$filterfile"
}

#
# save variables set on the command line (even if they're set to null)
#
# global vars: varssaved, all config settings, cl_ for all config settings
#
savevars () {
  # so we know if anything was saved, when we want to use logclvars
  varssaved="no"

  [ "${usepath+X}" = "X" ] && cl_usepath="$usepath" && varssaved="yes"
  [ "${timechecktype+X}" = "X" ] && cl_timechecktype="$timechecktype" && varssaved="yes"
  [ "${useumask+X}" = "X" ] && cl_useumask="$useumask" && varssaved="yes"
  [ "${debugme+X}" = "X" ] && cl_debugme="$debugme" && varssaved="yes"
  [ "${runevery+X}" = "X" ] && cl_runevery="$runevery" && varssaved="yes"
  [ "${startedfile+X}" = "X" ] && cl_startedfile="$startedfile" && varssaved="yes"
  [ "${ifrunning+X}" = "X" ] && cl_ifrunning="$ifrunning" && varssaved="yes"
  [ "${lockfile+X}" = "X" ] && cl_lockfile="$lockfile" && varssaved="yes"
  [ "${suppressemail+X}" = "X" ] && cl_suppressemail="$suppressemail" && varssaved="yes"
  [ "${mailto+X}" = "X" ] && cl_mailto="$mailto" && varssaved="yes"
  [ "${subject+X}" = "X" ] && cl_subject="$subject" && varssaved="yes"
  [ "${alertfile+X}" = "X" ] && cl_alertfile="$alertfile" && varssaved="yes"
  [ "${backuplog+X}" = "X" ] && cl_backuplog="$backuplog" && varssaved="yes"
  [ "${numlogs+X}" = "X" ] && cl_numlogs="$numlogs" && varssaved="yes"
  [ "${dayslogs+X}" = "X" ] && cl_dayslogs="$dayslogs" && varssaved="yes"
  [ "${usesyslog+X}" = "X" ] && cl_usesyslog="$usesyslog" && varssaved="yes"
  [ "${syslogstat+X}" = "X" ] && cl_syslogstat="$syslogstat" && varssaved="yes"
  [ "${syslogerr+X}" = "X" ] && cl_syslogerr="$syslogerr" && varssaved="yes"
  [ "${syslogtag+X}" = "X" ] && cl_syslogtag="$syslogtag" && varssaved="yes"
  [ "${quiet+X}" = "X" ] && cl_quiet="$quiet" && varssaved="yes"
  [ "${statuslog+X}" = "X" ] && cl_statuslog="$statuslog" && varssaved="yes"
  [ "${sshlogin+X}" = "X" ] && cl_sshlogin="$sshlogin" && varssaved="yes"
  [ "${sshkey+X}" = "X" ] && cl_sshkey="$sshkey" && varssaved="yes"
  [ "${sshport+X}" = "X" ] && cl_sshport="$sshport" && varssaved="yes"
  [ "${localport+X}" = "X" ] && cl_localport="$localport" && varssaved="yes"
  [ "${remoteport+X}" = "X" ] && cl_remoteport="$remoteport" && varssaved="yes"
  [ "${sshtimeout+X}" = "X" ] && cl_sshtimeout="$sshtimeout" && varssaved="yes"
  [ "${rsyncmode+X}" = "X" ] && cl_rsyncmode="$rsyncmode" && varssaved="yes"
  [ "${source+X}" = "X" ] && cl_source="$source" && varssaved="yes"
  [ "${dest+X}" = "X" ] && cl_dest="$dest" && varssaved="yes"
  [ "${rsyncdport+X}" = "X" ] && cl_rsyncdport="$rsyncdport" && varssaved="yes"
  [ "${passwordfile+X}" = "X" ] && cl_passwordfile="$passwordfile" && varssaved="yes"
  [ "${filterfile+X}" = "X" ] && cl_filterfile="$filterfile" && varssaved="yes"
  [ "${rsyncoptions+X}" = "X" ] && cl_rsyncoptions="$rsyncoptions" && varssaved="yes"
  [ "${rsyncadd+X}" = "X" ] && cl_rsyncadd="$rsyncadd" && varssaved="yes"
}

#
# log the variables that were set on the command line
#
# must be run after savevars()
#
# (\" will be lost in syslog, but work elsewhere - see SECURITY NOTE, below)
#
# global vars: all config settings, cl_ for all config settings
#
logclvars () {
  [ "${cl_usepath+X}" = "X" ] && logstatus "usepath=\"$cl_usepath\""
  [ "${cl_timechecktype+X}" = "X" ] && logstatus "timechecktype=\"$cl_timechecktype\""
  [ "${cl_useumask+X}" = "X" ] && logstatus "useumask=\"$cl_useumask\""
  [ "${cl_debugme+X}" = "X" ] && logstatus "debugme=\"$cl_debugme\""
  [ "${cl_runevery+X}" = "X" ] && logstatus "runevery=\"$cl_runevery\""
  [ "${cl_startedfile+X}" = "X" ] && logstatus "startedfile=\"$cl_startedfile\""
  [ "${cl_ifrunning+X}" = "X" ] && logstatus "ifrunning=\"$cl_ifrunning\""
  [ "${cl_lockfile+X}" = "X" ] && logstatus "lockfile=\"$cl_lockfile\""
  [ "${cl_suppressemail+X}" = "X" ] && logstatus "suppressemail=\"$cl_suppressemail\""
  [ "${cl_mailto+X}" = "X" ] && logstatus "mailto=\"$cl_mailto\""
  [ "${cl_subject+X}" = "X" ] && logstatus "subject=\"$cl_subject\""
  [ "${cl_alertfile+X}" = "X" ] && logstatus "alertfile=\"$cl_alertfile\""
  [ "${cl_backuplog+X}" = "X" ] && logstatus "backuplog=\"$cl_backuplog\""
  [ "${cl_numlogs+X}" = "X" ] && logstatus "numlogs=\"$cl_numlogs\""
  [ "${cl_dayslogs+X}" = "X" ] && logstatus "dayslogs=\"$cl_dayslogs\""
  [ "${cl_usesyslog+X}" = "X" ] && logstatus "usesyslog=\"$cl_usesyslog\""
  [ "${cl_syslogstat+X}" = "X" ] && logstatus "syslogstat=\"$cl_syslogstat\""
  [ "${cl_syslogerr+X}" = "X" ] && logstatus "syslogerr=\"$cl_syslogerr\""
  [ "${cl_syslogtag+X}" = "X" ] && logstatus "syslogtag=\"$cl_syslogtag\""
  [ "${cl_quiet+X}" = "X" ] && logstatus "quiet=\"$cl_quiet\""
  [ "${cl_statuslog+X}" = "X" ] && logstatus "statuslog=\"$cl_statuslog\""
  [ "${cl_sshlogin+X}" = "X" ] && logstatus "sshlogin=\"$cl_sshlogin\""
  [ "${cl_sshkey+X}" = "X" ] && logstatus "sshkey=\"$cl_sshkey\""
  [ "${cl_sshport+X}" = "X" ] && logstatus "sshport=\"$cl_sshport\""
  [ "${cl_localport+X}" = "X" ] && logstatus "localport=\"$cl_localport\""
  [ "${cl_remoteport+X}" = "X" ] && logstatus "remoteport=\"$cl_remoteport\""
  [ "${cl_sshtimeout+X}" = "X" ] && logstatus "sshtimeout=\"$cl_sshtimeout\""
  [ "${cl_rsyncmode+X}" = "X" ] && logstatus "rsyncmode=\"$cl_rsyncmode\""
  [ "${cl_source+X}" = "X" ] && logstatus "source=\"$cl_source\""
  [ "${cl_dest+X}" = "X" ] && logstatus "dest=\"$cl_dest\""
  [ "${cl_rsyncdport+X}" = "X" ] && logstatus "rsyncdport=\"$cl_rsyncdport\""
  [ "${cl_passwordfile+X}" = "X" ] && logstatus "passwordfile=\"$cl_passwordfile\""
  [ "${cl_filterfile+X}" = "X" ] && logstatus "filterfile=\"$cl_filterfile\""
  [ "${cl_rsyncoptions+X}" = "X" ] && logstatus "rsyncoptions=\"$cl_rsyncoptions\""
  [ "${cl_rsyncadd+X}" = "X" ] && logstatus "rsyncadd=\"$cl_rsyncadd\""
}

#
# restore variables set on the command line, overriding the config file
#
# global vars: all config settings, cl_ for all config settings
#
restorevars () {
  [ "${cl_usepath+X}" = "X" ] && usepath="$cl_usepath"
  [ "${cl_timechecktype+X}" = "X" ] && timechecktype="$cl_timechecktype"
  [ "${cl_useumask+X}" = "X" ] && useumask="$cl_useumask"
  [ "${cl_debugme+X}" = "X" ] && debugme="$cl_debugme"
  [ "${cl_runevery+X}" = "X" ] && runevery="$cl_runevery"
  [ "${cl_startedfile+X}" = "X" ] && startedfile="$cl_startedfile"
  [ "${cl_ifrunning+X}" = "X" ] && ifrunning="$cl_ifrunning"
  [ "${cl_lockfile+X}" = "X" ] && lockfile="$cl_lockfile"
  [ "${cl_suppressemail+X}" = "X" ] && suppressemail="$cl_suppressemail"
  [ "${cl_mailto+X}" = "X" ] && mailto="$cl_mailto"
  [ "${cl_subject+X}" = "X" ] && subject="$cl_subject"
  [ "${cl_alertfile+X}" = "X" ] && alertfile="$cl_alertfile"
  [ "${cl_backuplog+X}" = "X" ] && backuplog="$cl_backuplog"
  [ "${cl_numlogs+X}" = "X" ] && numlogs="$cl_numlogs"
  [ "${cl_dayslogs+X}" = "X" ] && dayslogs="$cl_dayslogs"
  [ "${cl_usesyslog+X}" = "X" ] && usesyslog="$cl_usesyslog"
  [ "${cl_syslogstat+X}" = "X" ] && syslogstat="$cl_syslogstat"
  [ "${cl_syslogerr+X}" = "X" ] && syslogerr="$cl_syslogerr"
  [ "${cl_syslogtag+X}" = "X" ] && syslogtag="$cl_syslogtag"
  [ "${cl_quiet+X}" = "X" ] && quiet="$cl_quiet"
  [ "${cl_statuslog+X}" = "X" ] && statuslog="$cl_statuslog"
  [ "${cl_sshlogin+X}" = "X" ] && sshlogin="$cl_sshlogin"
  [ "${cl_sshkey+X}" = "X" ] && sshkey="$cl_sshkey"
  [ "${cl_sshport+X}" = "X" ] && sshport="$cl_sshport"
  [ "${cl_localport+X}" = "X" ] && localport="$cl_localport"
  [ "${cl_remoteport+X}" = "X" ] && remoteport="$cl_remoteport"
  [ "${cl_sshtimeout+X}" = "X" ] && sshtimeout="$cl_sshtimeout"
  [ "${cl_rsyncmode+X}" = "X" ] && rsyncmode="$cl_rsyncmode"
  [ "${cl_source+X}" = "X" ] && source="$cl_source"
  [ "${cl_dest+X}" = "X" ] && dest="$cl_dest"
  [ "${cl_rsyncdport+X}" = "X" ] && rsyncdport="$cl_rsyncdport"
  [ "${cl_passwordfile+X}" = "X" ] && passwordfile="$cl_passwordfile"
  [ "${cl_filterfile+X}" = "X" ] && filterfile="$cl_filterfile"
  [ "${cl_rsyncoptions+X}" = "X" ] && rsyncoptions="$cl_rsyncoptions"
  [ "${cl_rsyncadd+X}" = "X" ] && rsyncadd="$cl_rsyncadd"
}

#
# log config file, current working directory, and command-line settings
#
# global vars: configfile, varssaved
#
logconfig () {
  # `pwd` is more portable than $PWD
  logstatus "using config file: \"$configfile\", cwd: \"`pwd`\""
  if [ "$varssaved" = "yes" ]; then
    logstatus "settings passed on the command line:"
    logclvars
  else
    logstatus "no settings passed on the command line"
  fi
}


######################################
# helper functions: assemble commands
######################################

#
# these are factored out here so the "cmds" argument to the script
# doesn't make things complicated and unreadable;
# when running for real, they are used to set $cmd, which is then eval'ed
#

#
# SECURITY NOTE: this is the only portable way I've found to be able to
# pass optional arguments that can contain spaces, and get everything
# to work as expected; I've done some tests, and I'm pretty sure using
# eval like this, with early evaluation and as much quoting as possible,
# is at worst no more dangerous than passing user-supplied filenames
# and arguments is in the first place, but if anyone reading this has
# a better idea, I'm listening...
#
# also, this approach doesn't handle some combinations of e.g. embedded
# quotes well, but it's probably good enough for this script, anyway...
#

#
# set $cmd to the ssh command to run for the tunnel
#
# global vars: cmd, localport, remoteport, sshport, sshkey, sshlogin
#
setsshcmd () {
  cmd="ssh -L \"$localport:localhost:$remoteport\" -N -p \"$sshport\""
  [ "$sshkey" != "" ] && cmd="$cmd -i \"$sshkey\""
  cmd="$cmd \"$sshlogin\""
}

#
# set $cmd to the rsync command to run for the backup
#
# global vars: cmd, rsyncmode, passwordfile, localport, rsyncdport, sshport,
#              sshkey, filterfile, rsyncoptions, rsyncadd, source, dest
#
setrsynccmd () {
  cmd="rsync"
  { [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "direct" ]; } && \
      cmd="$cmd --password-file=\"$passwordfile\""
  [ "$rsyncmode" = "tunnel" ] && \
      cmd="$cmd --port=\"$localport\""
  [ "$rsyncmode" = "direct" ] && \
      cmd="$cmd --port=\"$rsyncdport\""
  if [ "$rsyncmode" = "nodaemon" ]; then
    cmd="$cmd -e \"ssh -p \\\"$sshport\\\""
    [ "$sshkey" != "" ] && cmd="$cmd -i \\\"$sshkey\\\""
    cmd="$cmd\""
  fi
  [ "$filterfile" != "" ] && \
      cmd="$cmd -f \"merge $filterfile\""
  cmd="$cmd $rsyncoptions"  # no \" so we can specify multiple options
  cmd="$cmd $rsyncadd"  # no \" so we can specify multiple options
  cmd="$cmd $source"  # no \" so we can specify multiple paths
  cmd="$cmd \"$dest\""
}


##########################################
# command line and configuration settings
##########################################

# make sure the script was called sensibly
if [ "$#" -gt 2 ]; then
  usage
  throwerr "Error: invalid number of command-line parameters; exiting."
fi
checklist "mode" "$2" "" "help" "usage" "cmds" "silence" "unsilence" \
          "stop" "disable" "start" "enable" "clearlock" "unlock"

# need the usage message?
if [ "$2" = "help" ] || [ "$2" = "usage" ]; then
  usage
  do_exit 0
fi

# save variables set on the command line
# (moved to a function to make the script more readable)
savevars

if [ "$1" = "-" ]; then  # - means no config file
  configfile="-"  # save for later
  # nothing to source
else
  # get config file path
  if [ "$1" = "" ]; then
    configfile="./backup.conf"
  else
    configfile="$1"
  fi

  # . won't work with no directory (unless ./ is in the PATH),
  # the cwd has to be specified explicitly
  if echo "$configfile" | grep -v '/' > /dev/null 2>&1; then
    configfile="./$configfile"
  fi

  # source config file
  checkreadfile "config file \"$configfile\"" "$configfile"
  . "$configfile"
fi

# restore variables set on the command line, overriding the config file
restorevars

# validate the config
checkconf

# debug mode?
if [ "$debugme" = "yes" ]; then
  set -x
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$2" in
  cmds)
    # print the ssh and rsync commands that would be run
    if [ "$rsyncmode" = "tunnel" ]; then
      setsshcmd; echo "ssh command: $cmd"
    fi
    setrsynccmd; echo "rsync command: $cmd"
    do_exit 0
    ;;
  silence)
    # silence lockfile-exists alerts
    if [ ! -d "$lockfile" ]; then
      echo "lockfile directory doesn't exist, nothing to silence"
      do_exit 1
    else
      # using a file in the lockfile dir means that we automatically
      # get the silencing cleared when the lockfile is removed
      touch "$lockfile/silencealerts"
      echo "lockfile alerts have been silenced"
      quiet="yes"  # don't print to the terminal again
      logconfig  # so we know what the status message means
      logstatus "lockfile alerts have been silenced, lockfile=\"$lockfile\""
      do_exit 0
    fi
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    if [ ! -f "$lockfile/silencealerts" ]; then
      echo "alerts were already unsilenced"
      do_exit 1
    else
      rm -f "$lockfile/silencealerts"
      echo "lockfile alerts have been unsilenced"
      quiet="yes"  # don't print to the terminal again
      logconfig  # so we know what the status message means
      logstatus "lockfile alerts have been unsilenced, lockfile=\"$lockfile\""
      do_exit 0
    fi
    ;;
  stop|disable)
    # disable backups
    if [ -d "$lockfile" ]; then
      echo "lockfile directory exists; backup is probably running"
      echo "disable command will take effect after the current backup finishes"
      echo
    fi
    mkdir "$lockfile" > /dev/null 2>&1  # ignore already-exists errors
    touch "$lockfile/disable"
    echo "backups have been disabled; remember to re-enable them later!"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been disabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  start|enable)
    # re-enable backups
    if [ ! -f "$lockfile/disable" ]; then
      echo "backups are already enabled"
      do_exit 1
    fi
    rm -f "$lockfile/disable"
    echo "backups have been re-enabled"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been re-enabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  clearlock|unlock)
    # remove lockfile dir
    #
    # -e isn't portable; we could check further, but this should suffice
    if [ ! -d "$lockfile" ] && [ ! -f "$lockfile" ]; then
      echo "lockfile appears to have already been removed"
      do_exit 1
    fi
    echo
    echo "WARNING: the lockfile should only be removed if you're sure a backup isn't"
    echo "currently running."
    echo "Type 'y' (without the quotes) to continue."
    # it would be nice to have this on the same line as the prompt,
    # but the portability issues aren't worth it for this
    read type_y
    if [ "$type_y" != "y" ]; then
      do_exit 0
    fi
    echo
    rm -rf "$lockfile"
    echo "lockfile has been removed"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile \"$lockfile\" has been manually removed"
    do_exit 0
    ;;
esac

# log config file, current working directory, and command-line settings
logconfig


################
# status checks
################

if [ "$runevery" != "0" ]; then
  # has it been long enough since the last backup started?
  #
  # if $startedfile exists and is newer than $runevery, exit
  # (-f instead of -e because it's more portable)
  if [ -f "$startedfile" ] && newerthan "$startedfile" "$runevery"; then
    logstatus "backup interval has not expired; exiting"
    do_exit 0
  else
    logstatus "backup interval has expired; continuing"
  fi
else
  logstatus "interval checking has been disabled; continuing"
fi

# did the previous backup finish?
#
# use an atomic command to check and create the lock
# (could also be ln -s, but we might not be able to set the metadata, and
#  it could cause issues with commands that don't manipulate links directly;
#  plus, now we have a tempdir)
if mkdir "$lockfile" > /dev/null 2>&1; then
  # got the lock, clear lock-alert status
  if [ -f "$alertfile" ]; then  # -f is more portable than -e
    sendalert "lockfile created; cancelling previous alert status" log
  fi
  rm -f "$alertfile"  # -f because it usually won't exist
else
  # assume mkdir failed because it already existed;
  # but that could be because we manually disabled backups
  if [ -f "$lockfile/disable" ]; then
    logalert "backups have been manually disabled; exiting"
  else
    logalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi

  # send the initial alert email (no "log", we already logged it)
  #
  # (-f instead of -e because it's more portable)
  if [ ! -f "$alertfile" ]; then
    touch "$alertfile"
    if [ -f "$lockfile/disable" ]; then
      sendalert "backups have been manually disabled; exiting"
    else
      sendalert "could not create lockfile (previous backup still running or failed?); exiting"
    fi
    do_exit 2
  fi

  # but what about subsequent emails?

  # if ifrunning=0, log it but don't send email
  if [ "$ifrunning" = "0" ]; then
    logalert "ifrunning=0; no email sent"
    do_exit 2
  fi

  # if alerts have been silenced, log it but don't send email
  # (and don't bother checking $ifrunning)
  if [ -f "$lockfile/silencealerts" ]; then
    logalert "alerts have been silenced; no email sent"
    do_exit 2
  fi

  # if $alertfile is newer than $ifrunning, log it but don't send email
  if newerthan "$alertfile" "$ifrunning"; then
    logalert "alert interval has not expired; no email sent"
    do_exit 2
  fi

  # send an alert email (no "log", we already logged it)
  touch "$alertfile"
  if [ -f "$lockfile/disable" ]; then
    sendalert "backups have been manually disabled; exiting"
  else
    sendalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  do_exit 2
fi


##################
# open ssh tunnel
##################

if [ "$rsyncmode" = "tunnel" ]; then
  # set $cmd for ssh; see SECURITY NOTE, above, about this
  setsshcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatus "running ssh command: $cmd" all

  # run the command
  eval "$cmd &"  # note & _in the quotes_, so $! contains the correct pid
  sshpid="$!"

  # make sure it's actually working;
  # see http://mywiki.wooledge.org/ProcessManagement#Starting_a_.22daemon.22_and_checking_whether_it_started_successfully
  waited=0
  while sleep 1; do
    nc -z localhost "$localport" && break
    if kill -0 "$sshpid"; then
      # expr is more portable than $(())
      waited="`expr "$waited" + 1`"
      if [ "$waited" -gt "$sshtimeout" ]; then
        sendalert "could not establish ssh tunnel (timed out); exiting" log
        kill "$sshpid"
        wait "$sshpid"
        do_exit 3 clean
      fi
    else
      wait "$sshpid"
      sshexit="$?"
      sendalert "could not establish ssh tunnel (error code $sshexit); exiting" log
      do_exit 3 clean
    fi
  done

  logstatus "ssh tunnel established"
fi


##############
# rotate logs
##############

if [ "$backuplog" = "" ]; then
  logstatus "backup logging is off; not rotating logs"
else
  logstatus "rotating logs"

  # first pass
  for i in "$backuplog".[0-9]*; do
    # if nothing is found, the actual glob will be used for $i
    if [ "$i" = "$backuplog.[0-9]*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$i" | grep -v "^$backuplog\.[0-9][0-9]*$" > /dev/null 2>&1 \
       && \
       echo "$i" | grep -v "^$backuplog\.[0-9][0-9]*\..*$" > /dev/null 2>&1; then
      continue
    fi

    # rotate by date
    #
    # don't use -exec in the find so we know if we should continue the loop;
    # also, find returns 0 even if no files are matched
    if [ "$dayslogs" != "0" ] && \
       find "$i" -mtime +"$dayslogs" | grep "^$i$" > /dev/null 2>&1; then
      rm -f "$i"
      continue
    fi

    # get the log number (without any .gz, .bz, etc.)
    #
    # this regexp could be a bit more precise (and concise),
    # but it would be less portable
    lognum="`echo "$i" | sed 's/^'"$backuplog"'\.\([0-9][0-9]*\)\.*.*/\1/'`"
    # expr is more portable than $(())
    if [ "$numlogs" != "0" ] && [ "$lognum" -ge "`expr "$numlogs" - 1`" ]; then
      rm -f "$i"
    else
      # use temporary variables because we'd need quote nesting that
      # can't be done with ` and $() is less portable;
      # also, expr is more portable than $(())
      newnum="`expr "$lognum" + 1`"
      newname="`echo "$i" | \
                sed 's/^\('"$backuplog"'\.\)[0-9][0-9]*/\1'"$newnum"'/'`"
      # if we renumber the files without going in descending order,
      # we'll overwrite some, but sorting on the $lognum is tricky;
      # instead, add .new, then rename all of them
      mv "$i" "$newname.new"
    fi
  done

  # remove .new extensions
  for i in "$backuplog".[0-9]*.new; do
    # if nothing is found, the actual glob will be used for $i
    if [ "$i" = "$backuplog.[0-9]*.new" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$i" | grep "^$backuplog\.[0-9][0-9]*\.new$" > /dev/null 2>&1 \
       || \
       echo "$i" | grep "^$backuplog\.[0-9][0-9]*\..*\.new$" > /dev/null 2>&1; then
      mv "$i" "`echo "$i" | sed 's/\.new$//'`"
    else
      continue
    fi
  done

  # handle the most recent backup log
  if { [ "$numlogs" = "0" ] || [ "$numlogs" -ge 2 ]; } && \
     [ -f "$backuplog" ]; then  # -f more portable than -e
    mv "$backuplog" "$backuplog.1"
  else
    rm -f "$backuplog"
  fi
fi  # if [ "$backuplog" = "" ]


#############
# run backup
#############

logstatus "starting backup"
touch "$startedfile"

# set up a fifo for logging
#
# this has two benefits:
# 1) we can handle multiple output options in one place
# 2) when we eval the rsync command, we can get the return value because it
#    won't be in a pipeline
mkfifo "$lockfile/logfifo"
if [ "$backuplog" != "" ]; then
  # note that the most recent backup log should already have been (re)moved
  # by the log rotation
  #
  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    tee -a "$backuplog" < "$lockfile/logfifo" &
  else
    cat >> "$backuplog" < "$lockfile/logfifo" &
  fi
else  # no backup log
  if [ "$quiet" = "no" ]; then
    cat < "$lockfile/logfifo" &
  else
    cat >> /dev/null < "$lockfile/logfifo" &
  fi
fi
# create an fd to write to instead of the fifo,
# so it won't be closed after every line;
# see http://mywiki.wooledge.org/BashFAQ/085
exec 3> "$lockfile/logfifo"

# starting timestamp
echo "backup started `date`" >&3

# log the ssh command
if [ "$rsyncmode" = "tunnel" ]; then
  # already printed and logged, but print it again because the alternative
  # would be echo >> "$backuplog", which might be risky while there's
  # another process already writing to the log
  echo "ssh tunnel command was: $cmd" >&3
fi

# set $cmd for rsync; see SECURITY NOTE, above, about this
setrsynccmd

# log the command; only log to syslog if usesyslog="all"
#
# in this case, echo >&3 will also print to stdout, so temporarily disable
# printing before calling logstatus so we don't print it twice
savequiet="$quiet"
quiet="yes"
logstatus "running rsync command: $cmd" all
quiet="$savequiet"
echo "running rsync command: $cmd" >&3

# run the command
eval "$cmd" >&3 2>&1

if [ "$?" != 0 ]; then
  sendalert "warning: rsync finished with errors; please check the log" log
  setexitval 4
else
  logstatus "backup completed without errors"
fi

# ending timestamp
echo "backup ended `date`" >&3

# take down the fifo
exec 3>&-  # close the fd, this should kill the reader
rm -f "$lockfile/logfifo"


###################
# close ssh tunnel
###################

if [ "$rsyncmode" = "tunnel" ]; then
  kill "$sshpid"
  wait "$sshpid"
  logstatus "ssh tunnel closed"
fi


###########
# clean up
###########

do_exit 0 clean
