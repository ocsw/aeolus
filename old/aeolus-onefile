#!/bin/sh

#######################################################################
# Aeolus
# a portable, super-configurable database dump and rsync backup script
# by Daniel Malament
# see license() for license info
#######################################################################

# see usage() and the usage and sample config files for usage notes

# exit values:
#   0  = no error (e.g., runevery hasn't expired, or backup was completed
#        without errors)
#   1  = problem with the script invocation, the config file, or a setting
#        (also used in command modes like 'disable' as a generic error value)
#   2  = previous lockfile still exists (possibly because backups were
#        manually disabled)
#   3  = error finding a delimiter for a string
#   4  = error opening SSH tunnel
#   5  = error getting DB list
#   6  = problem with contents of DB list (e.g., unsafe characters)
#   7  = DB dumpfile already exists
#   8  = error dumping DB
#   9  = error compressing DB dump
#   10 = rsync error
# if there are multiple errors, the first one to occur is used

# modification notes:
#
# if the ext values above are changed, update the *_exitval variables, below
#
# lockfile dir is used for the following files:
#   $silencealerts, $disable, $timetemp, $logfifo, $alldbs, $alldbstmp
# all files should be in printstatus()
#
# any change to the setting variables (additions, deletions, name changes,
# type changes, etc.) must be reflected in: the sample config file,
# configsettings(), the default settings section, some of switch*()
# [possibly], applydefaults() [probably], and checkconf()
#
# all commands used should be listed in externalcmds() and the usage notes
#
# adding a DBMS:
#   add vars to the sample config file, modeling after MySQL (but split up
#     *_dump*options if necessary)
#   add vars to the relevant variables/functions (see above)
#   add to adddbconncmd(), setdblistcmd(), setdbdump*cmd(), needdblist()
#   add to dbmslist
#   add to usage notes on installation and portability
#
# see notes in the hardcoded variables section for other things that should
# be kept in sync (e.g., the name of the script and $scriptname, the values
# of the defaults and the comments in the sample config file, etc.)

# TODO:
# prune dated files by number
#
# better handling of long errors?
# i18n?
# setup modes?
# emulate mkdir -p?
# pathological cases in getparentdir()?
# squeeze // in parentdir() output?
# strange test problems in checkcreate()?
# actually parse vars on cl, in config file?
# queue sendalert()s for non-fatal messages (e.g., skipping many DB dumps)?
# globbing in dblist?

# do more to protect against leading - in settings?

# to test:
# mysql
# ssh key with ports
# all do_exit (val, clean)
# dblist in file
# alt opts
# better command-line option handling, e.g., wrt "-" for no config file
# create clean conf
# cl length limit - incl. $configsettings
# what if re-run? - incl. if zip
# stop on errors?
# when skipping to next phase, have to do cleanup/logging
# pigz
# echo -> printf
# config, status, systemtest modes, and mail alerts
# checknochar
# esc, seddelim funcs and uses
# sed \t


############
# debugging
############

#
# turn on debugging
#
do_debug () {
  set -vx
}

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
#
# however, this only applies if debugging is turned on on the command line;
# see also below
if [ "$debugme" = "yes" ]; then
  do_debug
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# name of the script, as reported by usage(), etc.
# change this if you rename the script file
scriptname="aeolus"

# external commands used (potentially)
#
# see configsettings(), below, about this code
#
# some things can probably be omitted, like 'set' and 'command';
# they should always be builtins, and anyway, by the time we try to
# test them...
#
# each setting must be on one line, and each line must start with a tab
# character
#
externalcmds () {
  cat <<-EOF
	rsync
	ssh
	nc
	mysql
	mysqldump
	gzip
	pigz
	bzip2
	lzip
	date
	hostname
	logger
	mailx
	grep
	awk
	gawk
	sed
	tr
	[
	expr
	echo
	printf
	cat
	tee
	ls
	find
	diff
	cmp
	touch
	mv
	rm
	mkdir
	mkfifo
	pwd
	kill
	sleep
	EOF
}

# default path to the config file, if one isn't specified
# change usage notes if you change this
defaultconfigfile="/etc/aeolus/aeolus.conf"

# names of all config file settings
#
# this could be an actual variable, but then we'd be using
#   'for setting in $configsettings'
# and it's not good practice to dump a lot of text on the command-line
# like that, although we're unlikely to hit a limit in this case;
# instead, we'll use a heredoc and
#   'configsettings | while read setting'
# to get around length limits
#
# each setting must be on one line for the shell (and also for clarity and
# ease of cut/paste/mangle)
#
# each line must start with a tab character
#
configsettings () {
  cat <<-EOF
	usepath
	useumask
	timecomptype
	filecomptype
	debugme
	on_ssherr
	on_dblisterr
	on_dbcharerr
	on_dbduplerr
	on_dumperr
	on_ziperr
	runevery
	startedfile
	ifrunning
	lockfile
	suppressemail
	mailto
	subject
	alertfile
	outputlog
	outputlog_layout
	outputlog_sep
	outputlog_date
	numlogs
	dayslogs
	usesyslog
	syslogstat
	syslogerr
	syslogtag
	quiet
	statuslog
	rsync_sshuser
	rsync_sshhost
	rsync_sshkey
	rsync_sshport
	rsync_localport
	rsync_remoteport
	rsync_sshoptions
	rsync_sshtimeout
	do_rsync
	rsync_mode
	rsync_source
	rsync_dest
	rsync_port
	rsync_pwfile
	rsync_filterfile
	rsync_options
	rsync_add
	mysql_dodump
	mysql_usetunnel
	mysql_sshuser
	mysql_sshhost
	mysql_sshkey
	mysql_sshport
	mysql_localport
	mysql_remoteport
	mysql_sshoptions
	mysql_sshtimeout
	mysql_user
	mysql_pwfile
	mysql_protocol
	mysql_host
	mysql_port
	mysql_socket
	mysql_dbmode
	mysql_dbs
	mysql_splitdbs
	mysql_clientoptions
	mysql_dumpoptions
	mysql_altmode
	mysql_alts
	mysql_dumpdir
	mysql_layout
	mysql_fileprefix
	mysql_filesuffix
	mysql_subdirprefix
	mysql_filedirsep
	mysql_filedirdate
	mysql_numfiles
	mysql_daysfiles
	mysql_zipmode
	mysql_zipoptions
	mysql_preserve
	EOF
}

#
# default settings
#
# change comments in sample config file if you change these
#

# default settings: housekeeping
timecomptype_default="find"
filecomptype_default="cmp"
debugme_default="no"
on_ssherr_default="phase"
on_dblisterr_default="phase"
on_dbcharerr_default="phase"
on_dbduplerr_default="db"
on_dumperr_default="db"
on_ziperr_default="db"

# default settings: checks and logging
runevery_default="0"
startedfile_default="/var/run/aeolus/started"
ifrunning_default="120"  # 2 hours
lockfile_default="/var/run/aeolus/lock"
suppressemail_default="no"
if command -v hostname > /dev/null 2>&1; then
  mailto_default="root@$(hostname)"
  subject_default="Aeolus alert on $(hostname)"
else
  mailto_default="root@localhost"
  subject_default="Aeolus alert"
fi
#alertfile_default="$lockfile.alert"  # set it later, after lockfile
outputlog_default="/var/log/aeolus-output.log"  # only if unset
outputlog_layout_default="number"
outputlog_sep_default="."  # only if unset
outputlog_date_default="+%Y%m%d"  # only if unset
numlogs_default="0"
dayslogs_default="7"
usesyslog_default="yes"
quiet_default="no"
statuslog_default="/var/log/aeolus.log"  # only if unset

# default settings: SSH tunnels (all)
rsync_localport_default="8873"
rsync_remoteport_default="873"
mysql_localport_default="4306"
mysql_remoteport_default="3306"
sshtimeout_default="15"  # applies to all SSH tunnels

# default settings: rsync
do_rsync_default="no"
rsync_mode_default="tunnel"
rsync_pwfile_default="/etc/aeolus/rsync.pw"  # only if unset

# default settings: DBMSes (all; see also below)
dbms_dodump_default="no"
dbms_usetunnel_default="no"
dbms_dumpdir_default="."
dbms_layout_default="date"
dbms_filesuffix_default=".sql"  # only if unset
dbms_filedirsep_default="-"  # only if unset
dbms_filedirdate_default="+%Y%m%d"  # only if unset
dbms_numfiles_default="0"
dbms_daysfiles_default="7"
dbms_zipmode_default="gzip"
dbms_preserve_default="data"

# default settings: MySQL (see also above)
mysql_pwfile_default="/etc/aeolus/mysql.pw"  # only if unset
mysql_dbmode_default="all"
mysql_splitdbs_default="no"
mysql_dumpoptions_default="--opt -Q -R -c"  # only if unset
mysql_altmode_default="none"
mysql_fileprefix_default="mysqldump"  # only if unset
mysql_subdirprefix_default="mysqldump"  # only if unset

# settings that have no default, and can't be blank
# (but may be ignored, depending on other settings)
#
# *_sshhost
# rsync_source
# rsync_dest
# *_dbs
# *_alts (if in "file" mode)

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
#
# removing a DBMS from this list will effectively disable it
dbmslist="mysql"

# names of tempfiles stored in the lockfile directory
disable="disable"
silencealerts="silencealerts"
timetemp="timetemp"
logfifo="logfifo"
alldbs="alldbs"
alldbstmp="alldbs.tmp"

# extension to use for temporary dumpfiles
dumptmp=".tmp"

# exit values; see top of script for details
# (and keep numbers in sync when modifying)
no_error_exitval="0"
startup_exitval="1"
lockfile_exitval="2"
nodelim_exitval="3"
sshtunnel_exitval="4"
getdblist_exitval="5"
dblistchar_exitval="6"
dumpexists_exitval="7"
dbdump_exitval="8"
dbzip_exitval="9"
rsync_exitval="10"

# a newline character
# see section 8 of http://www.dwheeler.com/essays/filenames-in-shell.html
newline=$(printf "\nX")
newline="${newline%X}"

# a tab character
tab='	'


##############################################
# helper functions: housekeeping and wrappers
##############################################

#
# update an exit value for the script
#
# if the value has already been set, don't change it,
# so that we can return the value corresponding to
# the first error encountered
#
# global vars: exitval
#
exitval="-1"
setexitval () {
  if [ "$exitval" = "-1" ]; then
    exitval="$1"
  fi
}

#
# update exit value (see setexitval()) and exit, possibly doing some cleanup
#
# $1 = exit value (required)
#
# if $cleanup_on_exit="yes":
#   * closes any open SSH tunnel
#   * removes the lockfile, unless the disable semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: cleanup_on_exit, sshpid, lockfile, disable, exitval
# tempfiles: disable
#
cleanup_on_exit="no"
do_exit () {
  if [ "$cleanup_on_exit" = "yes" ]; then
    if [ "$sshpid" != "" ]; then
      closesshtunnel
    fi

    if [ ! -f "$lockfile/$disable" ]; then
      rm -r "$lockfile"
    fi
    # otherwise, a disable command must have been run while we were
    # doing this backup; leave the lockfile dir alone, so future backups
    # will be disabled
  fi

  setexitval "$1"
  exit "$exitval"
}

#
# escape shell glob metacharacters:
#   * ? [
#
# usually, just enclosing strings in quotes suffices for the shell itself,
# but some commands, such as find, take arguments which are then globbed
#
# usage example:
#   find /path -name "$(escglob "$somevar")"
# note that you MUST use $(), NOT ``; `` does strange things with \ escapes
#
# see also escregex(), escereg(), escsedrepl()
#
escglob () {
  printf "%s\n" "$1" | sed \
      -e 's/\*/\\*/g' \
      -e 's/\?/\\?/g' \
      -e 's/\[/\\[/g'
}

#
# escape basic regex metacharacters:
#   . * [ ^ $ \
#
# for grep, sed, etc.; use when including non-sanitized data in a regex
# for example:
#   somecommand | grep "$(escregex "$somevar")"
# note that you MUST use $(), NOT ``; `` does strange things with \ escapes
#
# characters which are special only in extended regexes are not escaped:
#   ? + ( ) { |
# however, some versions of grep/sed/etc. will still accept these in basic
# regexes when they are preceded by \;
# in this case, our existing escape of \ will keep these from having a
# regex meaning (e.g., '\[' will become '\\[')
#
# see also escereg(), escglob(), escsedrepl()
#
escregex () {
  # note: \ must be first
  printf "%s\n" "$1" | sed \
      -e 's/\\/\\\\/g' \
      -e 's/\./\\./g' \
      -e 's/\*/\\*/g' \
      -e 's/\[/\\[/g' \
      -e 's/\^/\\^/g' \
      -e 's/\$/\\$/g'
}

#
# escape basic and extended regex metacharacters:
#   . * [ ^ $ \ ? + ( ) { |
#
# for grep, sed, etc.; use when including non-sanitized data in a regex
# for example:
#   somecommand | grep -E "$(escregex "$somevar")"
# note that you MUST use $(), NOT ``; `` does strange things with \ escapes
#
# portability note: ) needs escaping, but ] and } don't; see, e.g.,
# http://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.68/html_node/Limitations-of-Usual-Tools.html#Limitations-of-Usual-Tools#
# under egrep
#
# see also escregex(), escglob(), escsedrepl()
#
escereg () {
  # note: \ must be first
  printf "%s\n" "$1" | sed \
      -e 's/\\/\\\\/g' \
      -e 's/\./\\./g' \
      -e 's/\*/\\*/g' \
      -e 's/\[/\\[/g' \
      -e 's/\^/\\^/g' \
      -e 's/\$/\\$/g' \
      -e 's/?/\\?/g' \
      -e 's/+/\\+/g' \
      -e 's/(/\\(/g' \
      -e 's/)/\\)/g' \
      -e 's/{/\\{/g' \
      -e 's/|/\\|/g'
}

#
# escape sed replacement-expression metacharacters:
#   \ &
#
# usage example:
#   somecommand | sed "s/foo/$(escsedrepl "$somevar")/"
# note that you MUST use $(), NOT ``; `` does strange things with \ escapes
#
# see also escregex(), for escaping the search expression, getseddelim(),
# for finding delimiters, and escglob() and escereg()
#
escsedrepl () {
  # note: \ must be first
  printf "%s\n" "$1" | sed \
      -e 's/\\/\\\\/g' \
      -e 's/&/\\\&/g'
}

#
# find a character that can be used as a sed delimiter for a string
#
# $1 is the string to check; for a substitution, this should be the
# concatenation of both halves, without the 's' or delimiters
#
# prints an empty string if no character can be found (highly unlikely),
# otherwise the delimiter
#
# note: assumes your sed can handle any character as a delimiter
#
# portability note: we can't just escape existing separators because
# escaped separators aren't portable; see
# http://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.68/html_node/Limitations-of-Usual-Tools.html#Limitations-of-Usual-Tools
# under sed
#
# see also escregex() and escsedrepl(), for escaping sed search and replace
# expressions
#
# "local" vars: seddelim, char
#
getseddelim () {
  seddelim=""

  # note: some characters are left out because they have special meanings
  # to the shell (e.g., we would have to escape " if we used it as the
  # delimiter)
  for char in '/' '?' '.' ',' '<' '>' ';' ':' '|' '[' ']' '{' '}' \
              '=' '+' '_' '-' '(' ')' '*' '&' '^' '%' '#' '@' '!' '~' \
              A B C D E F G H I J K L M N O P Q R S T U V W X Y Z \
              a b c d e f g h i j k l m n o p q r s t u v w x y z ; do
    # use tr instead of grep so we don't have to worry about metacharacters
    # (we could use escregex(), but that's rather heavyweight for this)
    if [ "$1" = "$(printf "%s\n" "$1" | tr -d "$char")" ]; then
      seddelim="$char"
    fi
  done

  printf "%s" "$seddelim"
}

#
# assemble a complete, escaped, delimited sed substitution command
# (only useful if neither side of the substitution has any metacharacters)
#
# $1: search expression
# $2: replace expression
#
# usage example:
#   somecommand | sed "$(escsedsubst "searchexpr" "replexpr")"
# note that you MUST use $(), NOT ``; `` does strange things with \ escapes
#
# prints an empty string if getseddelim() does, otherwise the command
#
# "local" vars: seddelim, lhs_esc, rhs_esc
#
escsedsubst () {
  seddelim=$(getseddelim "$1$2")
  if [ "$seddelim" = "" ]; then
    printf ""
  else
    lhs_esc=$(escregex "$1")
    rhs_esc=$(escsedrepl "$2")
    printf "%s\n" "s$seddelim$lhs_esc$seddelim$rhs_esc$seddelim"
  fi
}

#
# wrapper: compare files
#
# $1, $2: file paths
#
# commands return 0/1/2, so test for success, not failure
#
# global vars: filecomptype
#
filecomp () {
  # don't redirect stderr, so we can see any actual errors
  case "$filecomptype" in
    cmp)
      cmp "$1" "$2" > /dev/null
      ;;
    diff)
      diff "$1" "$2" > /dev/null
      ;;
  esac
}

#
# get the parent directory of a file or dir
#
# this is more portable and more correct than dirname;
# in particular, dirname returns . for any of . ./ .. ../
# which fits the documentation, but doesn't make sense, at least not here
#
# to get the "standard" behavior, make $2 non-null
#
# note: still doesn't always correctly handle paths starting with /
# and containing . or .., e.g., getparentdir /foo/..
#
# "local" vars: parentdir
#
getparentdir () {
  # remove trailing /'s
  parentdir=$(printf "%s\n" "$1" | sed 's|/*$||')

  # are there no /'s left?
  if printf "%s\n" "$parentdir" | grep -v '/' > /dev/null 2>&1; then
    if [ "$parentdir" = "" ]; then
      echo "/"  # it was /, and / is its own parent
      return
    fi
    if [ "$2" = "" ]; then
      if [ "$parentdir" = "." ]; then
        echo ".."
        return
      fi
      if [ "$parentdir" = ".." ]; then
        echo "../.."
        return
      fi
    fi
    echo "."
    return
  fi
  parentdir=$(printf "%s\n" "$parentdir" | sed 's|/*[^/]*$||')
  if [ "$parentdir" = "" ]; then
    echo "/"
    return
  fi
  printf "%s\n" "$parentdir"
}

# tests for getparentdir:
#getparentdir //                   # /
#getparentdir //foo                # /
#getparentdir //foo//              # /
#getparentdir //foo//bar           # //foo
#getparentdir //foo//bar//         # //foo
#getparentdir //foo//bar//baz      # //foo//bar
#getparentdir //foo//bar//baz//    # //foo//bar
#getparentdir .                    # ..
#getparentdir .//                  # ..
#getparentdir . x                  # .
#getparentdir .// x                # .
#getparentdir .//foo               # .
#getparentdir .//foo//             # .
#getparentdir .//foo//bar          # .//foo
#getparentdir .//foo//bar//        # .//foo
#getparentdir .//foo//bar//baz     # .//foo//bar
#getparentdir .//foo//bar//baz//   # .//foo//bar
#getparentdir ..                   # ../..
#getparentdir ..//                 # ../..
#getparentdir .. x                 # .
#getparentdir ..// x               # .
#getparentdir ..//foo              # ..
#getparentdir ..//foo//            # ..
#getparentdir ..//foo//bar         # ..//foo
#getparentdir ..//foo//bar//       # ..//foo
#getparentdir ..//foo//bar//baz    # ..//foo//bar
#getparentdir ..//foo//bar//baz//  # ..//foo//bar
#getparentdir foo                  # .
#getparentdir foo//                # .
#getparentdir foo//bar             # foo
#getparentdir foo//bar//           # foo
#getparentdir foo//bar//baz        # foo//bar
#getparentdir foo//bar//baz//      # foo//bar
#getparentdir foo//bar//baz// x    # foo//bar
#exit

#
# check if the file in $1 is less than $2 minutes old
#
# $2 must be an unsigned integer (/[0-9]+/)
#
# file must exist; check before calling
#
# factored out for simplicity, but it's also a wrapper to choose between
# different non-portable methods (some of which use $lockfile/$timetemp)
#
# "local" vars: curtime, filetime, timediff, reftime
# global vars: timecomptype, lockfile, timetemp
# tempfiles: timetemp
#
newerthan () {
  case "$timecomptype" in
    find)
      # find returns 0 even if no files are matched
      find "$1" \! -mmin +"$2" | grep "^$(escregex "$1")$" > /dev/null 2>&1
      return
      ;;
    date-r)
      curtime=$(date "+%s")
      filetime=$(date -r "$1" "+%s")
      # expr is more portable than $(())
      timediff=$(expr \( "$curtime" - "$filetime" \) / 60)
      [ "$timediff" -lt "$2" ]
      return
      ;;
    date-d)
      reftime=$(date -d "$2 minutes ago" "+%Y%m%d%H%M.%S")
      ;;  # continue after esac
    awk|gawk)
      reftime=$(echo | "$timecomptype" \
          '{print strftime("%Y%m%d%H%M.%S", systime() - ('"$2"' * 60))}')
      ;;  # continue after esac
  esac
  touch -t "$reftime" "$lockfile/$timetemp"
  # find returns 0 even if no files are matched
  find "$1" -newer "$lockfile/$timetemp" | grep "^$(escregex "$1")$" > /dev/null 2>&1
}


#######################################
# helper functions: logging and alerts
#######################################

#
# log a message ($1) to the status log
# (depending on $statuslog)
#
# message is preceded by the date and the script's PID
#
# global vars: statuslog
#
logstatlog () {
  if [ "$statuslog" != "" ]; then
    # note: use quotes to preserve spacing, including in the output of date
    printf "%s\n" "$(date) [$$]: $1" >> "$statuslog"
  fi
}

#
# log a message ($1) to stdout and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprint () {
  # use "$1" to preserve spacing

  if [ "$quiet" = "no" ]; then  # default to yes
    printf "%s\n" "$1"
  fi

  logstatlog "$1"
}

#
# log a message ($1) to stderr and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprinterr () {
  # use "$1" to preserve spacing

  if [ "$quiet" = "no" ]; then  # default to yes
    printf "%s\n" "$1" 1>&2
  fi

  logstatlog "$1"
}

#
# actually send a syslog message; factored out here so logger
# is only called in one place, for maintainability
#
# $1 = message
# $2 = priority (facility.level or numeric)
#      (optional, use '.' if not passing priority but passing a tag)
# $3 = tag (optional)
#
# "local" vars: slcmd, message
#
do_syslog () {
  # see SECURITY NOTE, below, about this code
  slcmd="logger -i"
  [ "$2" != "" ] && [ "$2" != "." ] && slcmd="$slcmd -p \"$2\""
  [ "$3" != "" ] && slcmd="$slcmd -t \"$3\""
  # when we pass in the text of commands, they will probably contain
  # sub-quoted parts, which will cause errors in the eval unless we
  # protect them (because this function contains another evaluation,
  # relative to our other uses of the string)
  message=$(printf "%s\n" $1 | sed -e 's/^"/\\"/' -e 's/\([^\]\)"/\1\\"/g')
  slcmd="$slcmd \"$message\""
  eval "$slcmd"
}

#
# log a status message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogstat, syslogtag
#
logstatus () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogstat" "$syslogtag"
  fi

  logprint "$1"
}

#
# log an alert/error message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogerr, syslogtag
#
logalert () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogerr" "$syslogtag"
  fi

  logprint "$1"
}

#
# log a status message ($1) to syslog and/or the status log, (depending on
# $usesyslog and $statuslog), but not to stdout, regardless of the setting
# of $quiet
#
# used to avoid duplication when also logging to the output log
#
# if $2 is "all", only log to syslog if usesyslog="all" (but status logging
# proceeds normally)
#
# "local" vars: savequiet
# global vars: quiet
#
logstatusquiet () {
  savequiet="$quiet"
  quiet="yes"
  logstatus "$1" "$2"
  quiet="$savequiet"
}

#
# print the metadata of a file/dir if it exists,
# or "(none)" (used in alert emails)
#
# note: it would be nice to be able provide just timestamps,
# since the rest is much less useful here, and it would be easier
# to read, but it's more or less impossible to to that portably
#
getmetadata () {
  # -e isn't portable, and we're really only dealing with files and dirs
  # (or links to them, which [ handles for us)
  if [ -f "$1" ] || [ -d "$1" ]; then
    ls -ld "$1" 2>&1
  else
    echo "(none)"
  fi
}

#
# send an alert email, including diagnostics,
# and log to syslog/stdout/status log that an email was sent
#
# * message begins with the contents of $1
# * if $2 is "log", also log $1 before the sent notice
#
# note: even if suppressemail="yes", $1 is still logged
# (if settings permit)
#
# must not be called until after printconfig() and printstatus()
# are defined
#
# global vars: suppressemail, mailto, subject, (all other config settings
#              via printconfig)
#
sendalert () {
  if [ "$suppressemail" != "yes" ]; then
    mailx -s "$subject" $mailto <<-EOF
	$1


	$(printconfig)


	$(printstatus all)
	EOF
  fi

  if [ "$2" = "log" ]; then
    logalert "$1"
  fi

  if [ "$suppressemail" != "yes" ]; then
    logalert "alert email sent to $mailto"
  fi
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g., "rsync" or a member of
# $dbmslist)
#
# global vars: *_sshuser, *_sshhost, *_sshkey, *_sshport, *_localport,
#              *_remoteport, *_sshoptions, *_sshtimeout,
#              tun_prefix,
#              tun_sshuser, tun_sshhost, tun_sshkey, tun_sshport,
#              tun_localport, tun_remoteport, tun_sshoptions,
#              tun_sshtimeout
#
switchtunnel () {
  tun_prefix="$1"
  eval "tun_sshuser=\"$`printf '%s' $1`_sshuser\""
  eval "tun_sshhost=\"$`printf '%s' $1`_sshhost\""
  eval "tun_sshkey=\"$`printf '%s' $1`_sshkey\""
  eval "tun_sshport=\"$`printf '%s' $1`_sshport\""
  eval "tun_localport=\"$`printf '%s' $1`_localport\""
  eval "tun_remoteport=\"$`printf '%s' $1`_remoteport\""
  eval "tun_sshoptions=\"$`printf '%s' $1`_sshoptions\""
  eval "tun_sshtimeout=\"$`printf '%s' $1`_sshtimeout\""
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# global vars: *_dodump, *_usetunnel, *_user, *_pwfile, *_protocol, *_host
#              *_port, *_socket, *_dbmode, *_dbs, *_splitdbs,
#              *_clientoptions, *_dumpoptions, *_dumponeoptions,
#              *_dumpmultoptions, *_dumpalloptions, *_altmode, *_alts,
#              *_dumpdir, *_layout, *_fileprefix, *_subdirprefix,
#              *_filedirsep, *_filedirdate, *_numfiles, *_daysfiles,
#              *_zipmode, *_zipoptions, *_preserve,
#              *_datestring [internal],
#              dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socket,
#              dbms_dbmode, dbms_dbs, dbms_splitdbs, dbms_clientoptions,
#              dbms_dumpoptions, dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_altmode, dbms_alts, dbms_dumpdir,
#              dbms_layout, dbms_fileprefix, dbms_filesuffix,
#              dbms_subdirprefix, dbms_filedirsep, dbms_filedirdate,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_preserve,
#              dbms_datestring [internal]
#
switchdbms () {
  dbms_prefix="$1"
  eval "dbms_dodump=\"$`printf '%s' $1`_dodump\""
  eval "dbms_usetunnel=\"$`printf '%s' $1`_usetunnel\""
  eval "dbms_user=\"$`printf '%s' $1`_user\""
  eval "dbms_pwfile=\"$`printf '%s' $1`_pwfile\""
  eval "dbms_protocol=\"$`printf '%s' $1`_protocol\""
  eval "dbms_host=\"$`printf '%s' $1`_host\""
  eval "dbms_port=\"$`printf '%s' $1`_port\""
  eval "dbms_socket=\"$`printf '%s' $1`_socket\""
  eval "dbms_dbmode=\"$`printf '%s' $1`_dbmode\""
  eval "dbms_dbs=\"$`printf '%s' $1`_dbs\""
  eval "dbms_splitdbs=\"$`printf '%s' $1`_splitdbs\""
  eval "dbms_clientoptions=\"$`printf '%s' $1`_clientoptions\""
  eval "dbms_dumpoptions=\"$`printf '%s' $1`_dumpoptions\""
  eval "dbms_dumponeoptions=\"$`printf '%s' $1`_dumponeoptions\""
  eval "dbms_dumpmultoptions=\"$`printf '%s' $1`_dumpmultoptions\""
  eval "dbms_dumpalloptions=\"$`printf '%s' $1`_dumpalloptions\""
  eval "dbms_altmode=\"$`printf '%s' $1`_altmode\""
  eval "dbms_alts=\"$`printf '%s' $1`_alts\""
  eval "dbms_dumpdir=\"$`printf '%s' $1`_dumpdir\""
  eval "dbms_layout=\"$`printf '%s' $1`_layout\""
  eval "dbms_fileprefix=\"$`printf '%s' $1`_fileprefix\""
  eval "dbms_filesuffix=\"$`printf '%s' $1`_filesuffix\""
  eval "dbms_subdirprefix=\"$`printf '%s' $1`_subdirprefix\""
  eval "dbms_filedirsep=\"$`printf '%s' $1`_filedirsep\""
  eval "dbms_filedirdate=\"$`printf '%s' $1`_filedirdate\""
  eval "dbms_numfiles=\"$`printf '%s' $1`_numfiles\""
  eval "dbms_daysfiles=\"$`printf '%s' $1`_daysfiles\""
  eval "dbms_zipmode=\"$`printf '%s' $1`_zipmode\""
  eval "dbms_zipoptions=\"$`printf '%s' $1`_zipoptions\""
  eval "dbms_preserve=\"$`printf '%s' $1`_preserve\""
  # internal, not from config
  eval "dbms_datestring=\"$`printf '%s' $1`_datestring\""
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# global vars: scriptname, defaultconfigfile
#
usage () {
  # not necessarily reliable/consistent, switched to static global
  # (see hardcoded vars)
  #scriptname=$(printf "%s\n" "$0" | sed 's|^.*/||')

  cat <<EOF 1>&2

Usage:

  [ setting="value" ] $scriptname [ -f /path/to/config/file | -n ] [ mode ]

  Multiple settings can be added to the command line, separated by spaces;
  command-line settings override the config file.

Options:

  -f /path/to/config/file: supply the path to the config file
  -n: use no config file
  The last-supplied of -f and -n will be used.
  If neither option is supplied, "$defaultconfigfile" will be tried.

Modes:

  Modes can have a leading '--'; e.g., '--help' (omit the quotes).
  If multiple modes are given, the last one is used.

  Available modes and their effects:

  "help" or "usage": this message is printed

  "license": a license message is printed

  "config" or "settings": the current config settings are printed

  "cmds" or "commands": the ssh, DBMS, and rsync commands that would be run
  are printed, but nothing else is done

  "status": the current status, including timestamps, is printed
  "statusall": temp files mainly relevant for debugging are also included

  "silence": alerts about the lockfile existing are silenced until
  either they are unsilenced, or the lockfile is no longer present

  "unsilence": alerts about the lockfile existing are re-enabled

  "stop" or "disable": backups are disabled until "start" or "enable"
  is used

  "start" or "enable": backups are re-enabled

  "clearlock" or "unlock": the lockfile is forcibly removed; only use this
  if you're sure a backup isn't currently running!

  "create": a config file template is printed (all settings, in logical
  order, commented out so that the default values will be used unless
  otherwise specified); if -f is also given, the config file is output to
  the supplied path, but only if the file does not already exist

  "systemtest": diagnostics are printed about the system's support for
  the script (i.e., what utilities are present in the current PATH)

EOF
}


#
# print a license message to stderr
#
license () {
  cat <<EOF 1>&2

Copyright 2011 Daniel Malament.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
}

#
# save setting variables supplied on the command line (even if they're set
# to null)
#
# "local" vars: setting, cmdtemp
# global vars: varssaved, all config settings, cl_* for all config settings
#
savevars () {
  # so we know if anything was saved, when we want to use logconfig
  varssaved="no"

  configsettings | while read setting; do
    cmdtemp="[ \"\${$setting+X}\" = \"X\" ] &&"
    cmdtemp="$cmdtemp cl_$setting=\"\$$setting\" && varssaved=\"yes\""
    eval "$cmdtemp"  # doesn't work if combined into one line
  done
}

#
# log config file, current working directory, and setting variables supplied
# on the command line
#
# must be run after savevars()
#
# "local" vars: setting, cmdtemp
# global vars: noconfigfile, configfile, varssaved, all config settings,
#              cl_* for all config settings
#
logconfig () {
  # $(pwd) is more portable than $PWD
  if [ "$noconfigfile" = "yes" ]; then
    logstatus "no config file, cwd: \"$(pwd)\""
  else
    logstatus "using config file: \"$configfile\", cwd: \"$(pwd)\""
  fi

  if [ "$varssaved" = "yes" ]; then
    logstatus "settings passed on the command line:"
    configsettings | while read setting; do
      cmdtemp="[ \"\${cl_$setting+X}\" = \"X\" ] &&"
      cmdtemp="$cmdtemp logstatus \"$setting='\$cl_$setting'\""
      eval "$cmdtemp"  # doesn't work if combined into one line
    done
  else
    logstatus "no settings passed on the command line"
  fi
}

#
# restore setting variables supplied on the command line, overriding the
# config file
#
# "local" vars: setting, cmdtemp
# global vars: all config settings, cl_* for all config settings
#
restorevars () {
  configsettings | while read setting; do
    cmdtemp="[ \"\${cl_$setting+X}\" = \"X\" ] &&"
    cmdtemp="$cmdtemp $setting=\"\$cl_$setting\""
    eval "$cmdtemp"  # doesn't work if combined into one line
  done
}

#
# print all of the current config settings
#
# will print settings with '""' and "\"\"" sub-quoting correctly,
# but not "''" (prints as '''')
#
# "local" vars: setting
# global vars: all config settings
#
printsettings () {
  configsettings | while read setting; do
    eval "printf \"%s\n\" \"$setting=\\\"$`printf '%s' $setting`\\\"\""
  done
}

#
# print the current config settings, including config file name, CWD, etc.
#
# see printsettings() about quoting
#
# doesn't print surrounding blank lines; add them if necessary in context
#
# "local" vars: cfgfilestring
# global vars: noconfigfile, configfile, (all other config settings
#              via printsettings)
#
printconfig () {
  if [ "$noconfigfile" = "yes" ]; then
    cfgfilestring="(none)"
  else
    cfgfilestring="$configfile"
  fi

  # $(pwd) is more portable than $PWD
  cat <<-EOF
	-----------------
	Current Settings:
	-----------------

	Config file: $cfgfilestring
	CWD: $(pwd)

	$(printsettings)
	EOF
}

#
# print the current status, including file timestamps, etc.
#
# if $1 is "all", include timestamps for temp files that are only really
# relevant for debugging
#
# doesn't print surrounding blank lines; add them if necessary in context
#
# global vars: startedfile, lockfile, alertfile, silencealerts, disable,
#              timetemp, logfifo, alldbs, alldbstmp
#
printstatus () {
  cat <<-EOF
	-------
	Status:
	-------

	EOF

  if [ ! -f "$startedfile" ]; then  # -e isn't portable
    echo "no last-started file; this backup appears to have never been run"
  fi
  if [ -d "$lockfile" ]; then
    echo "lockfile directory exists; a backup may be in progress"
  else
    echo "no lockfile directory found; backups enabled but not in progress"
  fi
  if [ -f "$alertfile" ]; then
    echo "alertfile exists; running backup prevented new one from starting"
  fi
  if [ -f "$lockfile/$silencealerts" ]; then
    echo "lockfile alerts have been silenced"
  fi
  if [ -f "$lockfile/$disable" ]; then
    echo "backups have been disabled (but the last one may still be running)"
  fi

  cat <<-EOF


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	$(getmetadata "$startedfile")

	lockfile:
	$(getmetadata "$lockfile")

	alertfile:
	$(getmetadata "$alertfile")

	silencealerts:
	$(getmetadata "$lockfile/$silencealerts")

	disable:
	$(getmetadata "$lockfile/$disable")
	EOF

  if [ "$1" = "all" ]; then
    cat <<-EOF

	[temp files below this line, mainly relevant for debugging]

	timetemp:
	$(getmetadata "$lockfile/$timetemp")

	logfifo:
	$(getmetadata "$lockfile/$logfifo")

	alldbs:
	$(getmetadata "$lockfile/$alldbs")

	alldbstmp:
	$(getmetadata "$lockfile/$alldbstmp")
	EOF
  fi
}

#
# print a startup error to stderr and exit
#
# $1 = message
#
throwerr () {
  cat <<-EOF 1>&2

	$1

	EOF
  do_exit "$startup_exitval"
}

#
# print a command-line option error to stderr and exit
#
# $1 = message
#
# global vars: newline, scriptname
#
throwusageerr () {
  throwerr "$1${newline}${newline}Run '$scriptname usage' for more information."
}

#
# print a bad-setting error to stderr and exit
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
settingerr () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  throwerr "Error: invalid setting for $vname (\"$vval\"); exiting."
}

#
# validate a setting that can't be blank
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checknoblank () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  if [ "$vval" = "" ]; then
    throwerr "Error: $vname is unset or blank; exiting."
  fi
}

#
# validate two settings that can't both be blank
#
# $1 = first variable name
# $2 = second variable name
#
# "local" vars: vname1, vval1, vname2, vval2
# global vars: contents of $1, contents of $2
#
checknotbothblank () {
  vname1="$1"
  eval "vval1=\"$`printf '%s' $vname1`\""
  vname2="$2"
  eval "vval2=\"$`printf '%s' $vname2`\""

  if [ "$vval1" = "" ] && [ "$vval2" = "" ]; then
    throwerr "Error: $vname1 and $vname2 cannot both be blank; exiting."
  fi
}

#
# validate a numeric setting (only digits 0-9 allowed, no - or .)
#
# $1 = variable name
# $2 = minimum (optional, use "" if using $3 but not $2)
# $3 = maximum (optional)
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checknum () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  # use extra [0-9] to avoid having to use egrep
  if printf "%s\n" "$vval" | grep '^[0-9][0-9]*$' > /dev/null 2>&1; then
    if [ "$2" != "" ] && [ "$vval" -lt "$2" ]; then
      settingerr "$vname"
    fi
    if [ "$3" != "" ] && [ "$vval" -gt "$3" ]; then
      settingerr "$vname"
    fi
  else
    settingerr "$vname"
  fi
}

#
# validate a setting that may not contain a particular character
#
# $1 = variable name
# $2 = character
#
# "local" vars: vname, vval, char
# global vars: contents of $1
#
checknochar () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""
  char="$2"

  # use tr so we don't have to worry about metacharacters
  # (we could use escregex(), but that's rather heavyweight for this)
  if [ "$vval" != "$(printf "%s\n" "$vval" | tr -d "$char")" ]; then
    throwerr "Error: $vname cannot contain '$char' characters; exiting."
  fi
}

#
# validate a directory setting, for directories in which we need to create
# and/or rotate files:
# setting must not be blank, and directory must exist, be a directory or a
# symlink to a one, and have full permissions (r/w/x; r for rotation,
# wx for creating files)
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkrwxdir () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  checknoblank "$vname"

  # [ dereferences symlinks for us
  if [ ! -d "$vval" ]; then
    throwerr "Error: $vname is not a directory or a symlink to one; exiting."
  fi
  if [ ! -r "$vval" ]; then
    throwerr "Error: $vname is not readable; exiting."
  fi
  if [ ! -w "$vval" ]; then
    throwerr "Error: $vname is not writable; exiting."
  fi
  if [ ! -x "$vval" ]; then
    throwerr "Error: $vname is not searchable; exiting."
  fi
}

#
# validate a file/dir setting, for files/directories we're going to be
# touching, writing to, creating, and/or rotating (but not reading):
# 1) the setting may not be blank
# 2) if the file/dir exists, then:
#    2a) if $2="file", it must be a file or a symlink to one,
#        and it must be writable
#    2b) if $2="dir", it must be a directory or a symlink to one,
#        and it must be writable and searchable (wx; for creating files)
# 3) regardless, the parent directory must exist, be a directory or a
#    symlink to one, and be writable and searchable (wx); if $3 is not
#    null, it must also be readable (for rotation)
#
# $1 = variable name
# $2 = "file" or "dir"
# $3 = if not null (e.g., "rotate"), parent directory must be readable
#
# note: some tests (e.g., -x) seem to silently succeed in some cases in
# which the file/dir isn't readable, even if they should fail, but I'm
# not going to add extra restrictions just for that
#
# "local" vars: vname, vval, parentdir
# global vars: contents of $1
#
checkcreate () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  # condition 1
  checknoblank "$vname"

  # condition 2
  #
  # note: [ -e ] isn't portable, so try ls, even though it's probably not
  # robust enough to be a general solution...
  if ls "$vval" > /dev/null 2>&1; then
    case "$2" in
      file)
        # [ dereferences symlinks for us
        if [ ! -f "$vval" ]; then
          throwerr "Error: $vname is not a file or a symlink to one; exiting."
        fi
        if [ ! -w "$vval" ]; then
          throwerr "Error: $vname is not writable; exiting."
        fi
        ;;
      dir)
        # [ dereferences symlinks for us
        if [ ! -d "$vval" ]; then
          throwerr "Error: $vname is not a directory or a symlink to one; exiting."
        fi
        if [ ! -w "$vval" ]; then
          throwerr "Error: $vname is not writable; exiting."
        fi
        if [ ! -x "$vval" ]; then
          throwerr "Error: $vname is not searchable; exiting."
        fi
        ;;
      *)
        throwerr "Internal Error: illegal file-type value (\"$2\") in checkcreate(); exiting."
        ;;
    esac
  fi

  # condition 3
  parentdir=$(getparentdir "$vval")
  # [ dereferences symlinks for us
  if [ ! -d "$parentdir" ]; then
    # ... or a non-directory, but this is more concise
    throwerr "Error: $vname is in a non-existent directory (\"$parentdir\"); exiting."
  fi
  if [ ! -w "$parentdir" ]; then
    throwerr "Error: $vname is in a non-writable directory; exiting."
  fi
  if [ ! -x "$parentdir" ]; then
    throwerr "Error: $vname is in a non-searchable directory; exiting."
  fi
  if [ "$3" != "" ] && [ ! -r "$parentdir" ]; then
    throwerr "Error: $vname is in a non-readable directory; exiting."
  fi
}

#
# validate a file setting, for files we just need to be able to read:
# setting must not be blank, and file must exist, be a file or a symlink
# to one, and be readable
#
# $1 = variable name ("configfile" treated specially)
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkreadfile () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  # blank?
  checknoblank "$vname"

  # from here on, we will only be using $vname for printing purposes,
  # so we can doctor it
  if [ "$vname" = "configfile" ]; then
    vname="config file \"$vval\""
  fi

  # not a file or symlink to one?
  # ([ dereferences symlinks for us)
  if [ ! -f "$vval" ]; then
    throwerr "Error: $vname does not exist, or is not a file or a symlink to one; exiting."
  fi

  # not readable?
  if [ ! -r "$vval" ]; then
    throwerr "Error: $vname is not readable; exiting."
  fi
}

#
# validate a file setting, for files we need to be able to read and write,
# but not create or rotate:
# setting must not be blank, and file must exist, be a file or a
# symlink to a file, and be readable and writable
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkrwfile () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""

  checkreadfile "$vname"

  # not writable?
  if [ ! -w "$vval" ]; then
    throwerr "Error: $vname is not writable; exiting."
  fi
}

#
# validate a setting that can be one of a list of possiblities
#
# $1 = variable name ("mode" treated specially)
# other args = list of possiblities (can include "")
#
# "local" vars: vname, vval, poss
# global vars: contents of $1
#
checklist () {
  vname="$1"
  eval "vval=\"$`printf '%s' $vname`\""
  shift

  # implied $@ isn't supported by ksh
  for poss in ${1+"$@"}; do
    if [ "$vval" = "$poss" ]; then
      return
    fi
  done

  if [ "$vname" = "mode" ]; then
    throwusageerr "Error: invalid mode supplied on the command line; exiting."
  else
    settingerr "$vname"
  fi
}

#
# apply default settings where applicable
#
# global vars: most config settings, and their _defaults
#
applydefaults () {
  # housekeeping
  [ "$timecomptype" = "" ] && timecomptype="$timecomptype_default"
  [ "$filecomptype" = "" ] && filecomptype="$filecomptype_default"
  [ "$debugme" = "" ] && debugme="$debugme_default"
  [ "$on_ssherr" = "" ] && on_ssherr="$on_ssherr_default"
  [ "$on_dblisterr" = "" ] && on_dblisterr="$on_dblisterr_default"
  [ "$on_dbcharerr" = "" ] && on_dbcharerr="$on_dbcharerr_default"
  [ "$on_dbduplerr" = "" ] && on_dbduplerr="$on_dbduplerr_default"
  [ "$on_dumperr" = "" ] && on_dumperr="$on_dumperr_default"
  [ "$on_ziperr" = "" ] && on_ziperr="$on_ziperr_default"

  # checks and logging
  [ "$runevery" = "" ] && runevery="$runevery_default"
  [ "$startedfile" = "" ] && startedfile="$startedfile_default"
  [ "$ifrunning" = "" ] && ifrunning="$ifrunning_default"
  [ "$lockfile" = "" ] && lockfile="$lockfile_default"
  [ "$suppressemail" = "" ] && suppressemail="$suppressemail_default"
  [ "$mailto" = "" ] && mailto="$mailto_default"
  [ "$subject" = "" ] && subject="$subject_default"
  [ "$alertfile" = "" ] && alertfile="$lockfile.alert"  # late-binding default
  [ "${outputlog+X}" = "" ] && outputlog="$outputlog_default"
  [ "$outputlog_layout" = "" ] && outputlog_layout="$outputlog_layout_default"
  [ "${outputlog_sep+X}" = "" ] && outputlog_sep="$outputlog_sep_default"
  [ "${outputlog_date+X}" = "" ] && outputlog_date="$outputlog_date_default"
  [ "$numlogs" = "" ] && numlogs="$numlogs_default"
  [ "$dayslogs" = "" ] && dayslogs="$dayslogs_default"
  [ "$usesyslog" = "" ] && usesyslog="$usesyslog_default"
  [ "$quiet" = "" ] && quiet="$quiet_default"
  [ "${statuslog+X}" = "" ] && statuslog="$statuslog_default"

  # SSH tunnels (individual and global defaults)
  [ "$rsync_localport" = "" ] && rsync_localport="$rsync_localport_default"
  [ "$rsync_remoteport" = "" ] && rsync_remoteport="$rsync_remoteport_default"
  [ "$mysql_localport" = "" ] && mysql_localport="$mysql_localport_default"
  [ "$mysql_remoteport" = "" ] && mysql_remoteport="$mysql_remoteport_default"
  # global
  [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="$sshtimeout_default"
  [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="$sshtimeout_default"

  # rsync
  [ "$do_rsync" = "" ] && do_rsync="$do_rsync_default"
  [ "$rsync_mode" = "" ] && rsync_mode="$rsync_mode_default"
  [ "${rsync_pwfile+X}" = "" ] && rsync_pwfile="$rsync_pwfile_default"

  # DBMSes (global defaults; see also below)
  [ "$mysql_dodump" = "" ] && mysql_dodump="$dbms_dodump_default"
  [ "$mysql_usetunnel" = "" ] && mysql_usetunnel="$dbms_usetunnel_default"
  [ "$mysql_dumpdir" = "" ] && mysql_dumpdir="$dbms_dumpdir_default"
  [ "$mysql_layout" = "" ] && mysql_layout="$dbms_layout_default"
  [ "${mysql_filesuffix+X}" = "" ] && mysql_filesuffix="$dbms_filesuffix_default"
  [ "${mysql_filedirsep+X}" = "" ] && mysql_filedirsep="$dbms_filedirsep_default"
  [ "${mysql_filedirdate+X}" = "" ] && mysql_filedirdate="$dbms_filedirdate_default"
  [ "$mysql_numfiles" = "" ] && mysql_numfiles="$dbms_numfiles_default"
  [ "$mysql_daysfiles" = "" ] && mysql_daysfiles="$dbms_daysfiles_default"
  [ "$mysql_zipmode" = "" ] && mysql_zipmode="$dbms_zipmode_default"
  [ "$mysql_preserve" = "" ] && mysql_preserve="$dbms_preserve_default"

  # DBMSes (individual defaults; see also above)
  [ "${mysql_pwfile+X}" = "" ] && mysql_pwfile="$mysql_pwfile_default"
  [ "$mysql_dbmode" = "" ] && mysql_dbmode="$mysql_dbmode_default"
  [ "$mysql_splitdbs" = "" ] && mysql_splitdbs="$mysql_splitdbs_default"
  [ "${mysql_dumpoptions+X}" = "" ] && mysql_dumpoptions="$mysql_dumpoptions_default"
  [ "$mysql_altmode" = "" ] && mysql_altmode="$mysql_altmode_default"
  [ "${mysql_fileprefix+X}" = "" ] && mysql_fileprefix="$mysql_fileprefix_default"
  [ "${mysql_subdirprefix+X}" = "" ] && mysql_subdirprefix="$mysql_subdirprefix_default"
}

#
# validate the configuration settings
#
# global vars: all config settings except usepath, useumask, outputlog_sep,
#              outputlog_date, syslogtag, *_sshuser, *_sshoptions,
#              rsync_options, rsync_add,
#              [DBMS]: *_user, *_protocol, *_clientoptions, *_dumpoptions,
#              *_dumponeoptions, *_dumpmultoptions, *_dumpalloptions,
#              *_filedirsep, *_filedirdate, *_zipoptions
#
checkconf () {
  # housekeeping
  #
  # note: umask could be symbolic in some shells, not going to try to
  # parse it
  checklist "timecomptype" "find" "date-r" "date-d" "awk" "gawk"
  checklist "filecomptype" "cmp" "diff"
  checklist "debugme" "yes" "no"
  checklist "on_ssherr" "phase" "exit"
  checklist "on_dblisterr" "phase" "exit"
  checklist "on_dbcharerr" "phase" "exit"
  checklist "on_dbduplerr" "ignore" "warn" "db" "phase" "exit"
  checklist "on_dumperr" "db" "phase" "exit"
  checklist "on_ziperr" "db" "phase" "exit"

  # checks and logging
  checknum "runevery"
  checkcreate "startedfile" "file"
  checknum "ifrunning"
  checkcreate "lockfile" "dir"
  checklist "suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    checknoblank "mailto"
    checknoblank "subject"
  fi
  checkcreate "alertfile" "file"
  if [ "$outputlog" != "" ]; then
    checkcreate "outputlog" "file" "rotate"
    checklist "outputlog_layout" "append" "number" "date"
    checknochar "outputlog_sep" "/"
    checknochar "outputlog_date" "/"
    if [ "$outputlog_layout" != "append" ]; then
      checknum "numlogs"
      checknum "dayslogs"
    fi
  fi
  checklist "usesyslog" "all" "yes" "no"
  if [ "$usesyslog" != "no" ]; then
    [ "$syslogstat" = "" ] && syslogstat="."  # see do_syslog()
    [ "$syslogerr" = "" ] && syslogerr="."  # see do_syslog()
  fi
  checklist "quiet" "yes" "no"
  [ "$statuslog" != "" ] && checkcreate "statuslog" "file"

  # rsync, including SSH tunnel
  checklist "do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    checklist "rsync_mode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsync_mode" = "tunnel" ]; then
      checknoblank "rsync_sshhost"
      checknum "rsync_localport" 1 65535
      checknum "rsync_remoteport" 1 65535
      checknum "rsync_sshtimeout" 1
    fi
    if [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "nodaemon" ]; then
      [ "$rsync_sshkey" != "" ] && checkreadfile "rsync_sshkey"
      [ "$rsync_sshport" != "" ] && checknum "rsync_sshport" 1 65535
    fi
    checknoblank "rsync_source"
    checknoblank "rsync_dest"
    if [ "$rsync_mode" = "direct" ]; then
      [ "$rsync_port" != "" ] && checknum "rsync_port" 1 65535
    fi
    { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
        [ "$rsync_pwfile" != "" ] && checkreadfile "rsync_pwfile"
    [ "$rsync_filterfile" != "" ] && checkreadfile "rsync_filterfile"
  fi

  # DBMS dumps, including SSH tunnels
  for dbms in $dbmslist; do
    switchdbms "$dbms"
    switchtunnel "$dbms"

    # note: lines like
    #   checklist "${dbms}_dodump" "yes" "no"
    # are passing, e.g., "mysql_dodump",
    # but lines like
    #   if [ "$dbms_dodump" = "yes" ]; then
    # are referencing the dbms_dodump variable...

    checklist "${dbms}_dodump" "yes" "no"
    if [ "$dbms_dodump" = "yes" ]; then
      checklist "${dbms}_usetunnel" "yes" "no"
      if [ "$dbms_usetunnel" = "yes" ]; then
        checknoblank "${dbms}_sshhost"
        [ "$tun_sshkey" != "" ] && checkreadfile "${dbms}_sshkey"
        [ "$tun_sshport" != "" ] && checknum "${dbms}_sshport" 1 65535
        checknum "${dbms}_localport" 1 65535
        checknum "${dbms}_remoteport" 1 65535
        checknum "${dbms}_sshtimeout" 1
        # ignore these
        eval "`printf '%s' $dbms`_host=\"\""
        eval "`printf '%s' $dbms`_port=\"\""
        eval "`printf '%s' $dbms`_socket=\"\""
        # also change the dbms_* variables, for later tests
        dbms_host=""
        dbms_port=""
        dbms_socket=""
       else
        if [ "$dbms_host" != "" ]; then  # nothing to check, but...
          # ignore socket
          eval "`printf '%s' $dbms`_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        if [ "$dbms_port" != "" ]; then
          checknum "${dbms}_port" 1 65535
          # ignore socket
          eval "`printf '%s' $dbms`_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        [ "$dbms_socket" != "" ] && checkrwfile "${dbms}_socket"
      fi  # if [ "$dbms_usetunnel" = "yes" ]
      [ "$dbms_pwfile" != "" ] && checkreadfile "${dbms}_pwfile"
      checklist "${dbms}_dbmode" "all" "include" "exclude" "includefile" \
                                 "excludefile"
      [ "$dbms_dbmode" != "all" ] && checknoblank "${dbms}_dbs"
      checklist "${dbms}_splitdbs" "yes" "no"
      checklist "${dbms}_altmode" "none" "list" "file"
      [ "$dbms_altmode" = "file" ] && checkreadfile "${dbms}_alts"
      checkrwxdir "${dbms}_dumpdir"
      checklist "${dbms}_layout" "single" "number" "date" "singledir" \
                "numberdir" "datedir"
      [ "$dbms_splitdbs" = "no" ] && [ "$dbms_layout" != "date" ] && \
          checknotbothblank "${dbms}_fileprefix" "${dbms}_filesuffix"
      checknochar "${dbms}_fileprefix" "/"
      checknochar "${dbms}_filesuffix" "/"
      { [ "$dbms_layout" = "singledir" ] || [ "$dbms_layout" = "numberdir" ]; } && \
          checknoblank "${dbms}_subdirprefix"
      checknochar "${dbms}_subdirprefix" "/"
      checknochar "${dbms}_filedirsep" "/"
      checknochar "${dbms}_filedirdate" "/"
      if [ "$dbms_layout" != "single" ] && [ "$dbms_layout" != "singledir" ]; then
        checknum "${dbms}_numfiles"
        checknum "${dbms}_daysfiles"
      fi
      checklist "${dbms}_zipmode" "none" "gzip" "pigz" "bzip2" "lzip"
      checklist "${dbms}_preserve" "data" "space"
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist
}


####################################
# core functions: assemble commands
####################################

#
# these are factored out here so the "cmds" argument to the script
# doesn't make things complicated and unreadable;
# when running for real, they are used to set $cmd, which is then eval'ed
#

#
# SECURITY NOTE: this is the only portable way I've found to be able to
# pass optional arguments that can contain spaces, and get everything
# to work as expected; I've done some tests, and I'm pretty sure using
# eval like this, with early evaluation and as much quoting as possible,
# is at worst no more dangerous than passing user-supplied filenames
# and arguments is in the first place, but if anyone reading this has
# a better idea, I'm listening
#
# also, this approach doesn't handle some combinations of, e.g., embedded
# quotes well, but it's probably good enough for this script, anyway
#

# see also do_syslog(), above

#
# set $cmd to the ssh command to run for a tunnel
#
# global vars: cmd, tun_localport, tun_remoteport, tun_sshport, tun_sshkey,
#              tun_sshoptions, tun_sshuser, tun_sshhost
#
setsshcmd () {
  cmd="ssh -L \"${tun_localport}:localhost:${tun_remoteport}\" -N"
  [ "$tun_sshport" != "" ] && cmd="$cmd -p \"$tun_sshport\""
  [ "$tun_sshkey" != "" ] && cmd="$cmd -i \"$tun_sshkey\""
  # no \" so we can specify multiple options
  [ "$tun_sshoptions" != "" ] && cmd="$cmd $tun_sshoptions"
  [ "$tun_sshuser" != "" ] && cmd="$cmd -l \"$tun_sshuser\""
  cmd="$cmd \"$tun_sshhost\""
}

#
# add database connection options to $cmd
#
# global vars: cmd, dbms_prefix, *_user, *_pwfile, *_usetunnel, *_localport,
#              *_protocol, *_host, *_port, *_socket
#
adddbconncmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option
      [ "$mysql_pwfile" != "" ] && \
          cmd="$cmd \"--defaults-extra-file=$mysql_pwfile\""
      [ "$mysql_user" != "" ] && cmd="$cmd -u \"$mysql_user\""
      if [ "$mysql_usetunnel" = "yes" ]; then
        cmd="$cmd -h localhost"
        cmd="$cmd -P \"$mysql_localport\""
      else
        [ "$mysql_protocol" != "" ] && cmd="$cmd \"--protocol=$mysql_protocol\""
        [ "$mysql_host" != "" ] && cmd="$cmd -h \"$mysql_host\""
        [ "$mysql_port" != "" ] && cmd="$cmd -P \"$mysql_port\""
        [ "$mysql_socket" != "" ] && cmd="$cmd -S \"$mysql_socket\""
      fi
      ;;
  esac
}

#
# set $cmd to the command to run to get a list of databases
#
# global vars: cmd, dbms_prefix, *_clientoptions, vars for adddbconncmd()
#
setdblistcmd () {
  case "$dbms_prefix" in
    mysql)
      cmd="mysql"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_clientoptions" != "" ] && cmd="$cmd $mysql_clientoptions"
      cmd="$cmd -BN -e \"SHOW DATABASES;\""
      ;;
  esac
}

#
# check if setdbdumponecmd() should be using alternate options
#
# $1 is the name of the database to dump
#
# don't actually apply the options here in case there are DBMS-specific
# things that need to be done
#
# "local" vars: OLDIFS, dbname, altline_esc, altdb_esc, altopts_esc, altdb
# global vars: IFS, newline, tab, dbms_altmode, dbms_alts, altopts
#
checkusealtopts () {
  OLDIFS="$IFS"
  dbname="$1"

  case "$dbms_altmode" in
    none)
      return 1  # false
      ;;
    list)
      IFS="$newline"
      for altline_esc in $(printf "%s" "$dbms_alts"); do
        IFS="$OLDIFS"
        # \t isn't portable in sed
        altdb_esc=$(printf "%s\n" "$altline_esc" | sed "s/$tab.*\$//")
        altopts_esc=$(printf "%s\n" "$altline_esc" | sed "s/^.*$tab//")
        altdb=$(dbunescape "$altdb_esc")
        altopts=$(dbunescape "$altopts_esc")
        if [ "$dbname" = "$altdb" ]; then
          return 0  # true
        fi
        IFS="$newline"
      done
      IFS="$OLDIFS"
      return 1  # false
      ;;
    file)
      IFS=""
      while read -r altline_esc; do  # < "$dbms_alts"
        IFS="$OLDIFS"
        # \t isn't portable in sed
        altdb_esc=$(printf "%s\n" "$altline_esc" | sed "s/$tab.*\$//")
        altopts_esc=$(printf "%s\n" "$altline_esc" | sed "s/^.*$tab//")
        altdb=$(dbunescape "$altdb_esc")
        altopts=$(dbunescape "$altopts_esc")
        if [ "$dbname" = "$altdb" ]; then
          return 0  # true
        fi
        IFS=""
      done < "$dbms_alts"
      IFS="$OLDIFS"
      return 1  # false
      ;;
  esac
}

#
# set $cmd to the command to run to dump a single database
#
# $1 is the name of the database to dump; if blank, it will be replaced
#    with "DBNAME" (useful for, e.g., running the script in cmds mode)
#
# "local" vars: dbname
# global vars: cmd, dbms_prefix, altopts, *_dumponeoptions (or, e.g.,
#              *_dumpoptions for DBMSes that only need one set of options),
#              vars for adddbconncmd()
#
setdbdumponecmd () {
  if [ "$1" = "" ]; then
    dbname="DBNAME"
  else
    dbname="$1"
  fi

  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      if checkusealtopts "$1"; then
        # no \" so we can specify multiple options
        [ "$altopts" != "" ] && cmd="$cmd $altopts"
      else
        # no \" so we can specify multiple options
        [ "$dbms_dumpoptions" != "" ] && cmd="$cmd $dbms_dumpoptions"
      fi
      cmd="$cmd \"$dbname\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump multiple databases to one file
#
# $1 is a string containing the names of the databases to dump (names
#    containing spaces must be sub-quoted (e.g., '... "foo bar" ...' or
#    "... \"foo bar\" ...")); if blank, it will be replaced with
#    "DBNAMES" (useful for, e.g., running the script in cmds mode)
#
# "local" vars: dbnames
# global vars: cmd, dbms_prefix, *_dumpmultoptions (or, e.g., *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpmultcmd () {
  if [ "$1" = "" ]; then
    dbnames="DBNAMES"
  else
    dbnames="$1"
  fi

  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -B $dbnames"
      ;;
  esac
}

#
# set $cmd to the command to run to dump all databases to one file
#
# global vars: cmd, dbms_prefix, *_dumpalloptions (or, e.g., *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpallcmd () {
  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -A"
      ;;
  esac
}

#
# set $cmd to the rsync command to run for the backup
#
# global vars: cmd, rsync_mode, rsync_pwfile, rsync_localport, rsync_port,
#              rsync_sshport, rsync_sshkey, rsync_sshoptions,
#              rsync_filterfile, rsync_options, rsync_add, rsync_source,
#              rsync_dest
#
setrsynccmd () {
  cmd="rsync"
  { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
      [ "$rsync_pwfile" != "" ] && \
      cmd="$cmd \"--password-file=$rsync_pwfile\""
  [ "$rsync_mode" = "tunnel" ] && \
      cmd="$cmd \"--port=$rsync_localport\""
  [ "$rsync_mode" = "direct" ] && \
      [ "$rsync_port" != "" ] && cmd="$cmd \"--port=$rsync_port\""
  if [ "$rsync_mode" = "nodaemon" ]; then
    cmd="$cmd -e \"ssh"
    [ "$rsync_sshport" != "" ] && cmd="$cmd -p \\\"$rsync_sshport\\\""
    [ "$rsync_sshkey" != "" ] && cmd="$cmd -i \\\"$rsync_sshkey\\\""
    # no \" so we can specify multiple options
    [ "$rsync_sshoptions" != "" ] && cmd="$cmd $rsync_sshoptions"
    cmd="$cmd\""
  fi
  [ "$rsync_filterfile" != "" ] && cmd="$cmd -f \"merge $rsync_filterfile\""
  # no \" so we can specify multiple options
  [ "$rsync_options" != "" ] && cmd="$cmd $rsync_options"
  # no \" so we can specify multiple options
  [ "$rsync_add" != "" ] && cmd="$cmd $rsync_add"
  cmd="$cmd $rsync_source"  # no \" so we can specify multiple paths
  cmd="$cmd \"$rsync_dest\""
}

#
# print the actual commands that would be run (ssh, DBMS, rsync)
#
# must not be called until after needdblist() is defined
#
# "local" vars: do_something, dbms
# global vars: cmd, dbmslist, dbms_prefix, dbms_dodump, dbms_usetunnel,
#              dbms_dbmode, dbms_splitdbs, do_rsync, rsync_mode
#
printcmds () {
  # are we supposed to actually do anything?
  do_something="no"  # set this to yes later if we do something

  # DBMSes
  for dbms in $dbmslist; do
    switchdbms "$dbms"

    if [ "$dbms_dodump" = "yes" ]; then
      do_something="yes"

      # SSH tunnel
      if [ "$dbms_usetunnel" = "yes" ]; then
        switchtunnel "$dbms"
        setsshcmd
        printf "%s\n" "$dbms_prefix ssh command: $cmd"
      fi

      # DB list
      if needdblist; then
        setdblistcmd
        printf "%s\n" "$dbms_prefix get-DB-list command: $cmd"
      fi

      # dump DBs
      if [ "$dbms_splitdbs" = "no" ]; then
        case "$dbms_dbmode" in
          all)
            setdbdumpallcmd
            printf "%s\n" "$dbms_prefix dump-all-DBs command: $cmd"
            ;;
          include|exclude|includefile|excludefile)
            setdbdumpmultcmd ""
            printf "%s\n" "$dbms_prefix dump-multiple-DBs command: $cmd"
            ;;
        esac
      else  # dbms_splitdbs="yes"
        setdbdumponecmd ""
        printf "%s\n" "$dbms_prefix dump-one-DB command: $cmd"
      fi
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist

  # rsync
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    # SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync"
      setsshcmd
      printf "%s\n" "rsync ssh command: $cmd"
    fi

    # actual rsync
    setrsynccmd
    printf "%s\n" "rsync command: $cmd"
  fi

  # did we actually do anything?
  if [ "$do_something" = "no" ]; then  # everything was turned off
    echo "no commands would be run, because no actions are turned on"
  fi
}


#############################################
# core functions: rotation, pruning, zipping
#############################################

#
# rotate numbered files
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number (not in $1 because the most recent
#     file won't have a separator or a number)
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, filename, filenum, newnum, newname, D
#
rotatenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"

  # first pass
  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.lz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.gz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # the regexp could be a bit more concise, but it would be less portable
    D=$(getseddelim "^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$\\1")
    if [ "$D" = "" ]; then
      sendalert "can't find a delimiter for string '^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$\\1' in function rotatenumfiles(); exiting" log
      do_exit "$nodelim_exitval"
    fi
    filenum=$(printf "%s\n" "$filename" | \
              sed "s$D^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$$D\\1$D")

    # create the new filename
    D=$(getseddelim "^\\($(escregex "$prefix$sep")\\)[0-9][0-9]*\\1$(escsedrepl "$newnum")")
    if [ "$D" = "" ]; then
      sendalert "can't find a delimiter for string '^\\($(escregex "$prefix$sep")\\)[0-9][0-9]*\\1$(escsedrepl "$newnum")' in function rotatenumfiles(); exiting" log
      do_exit "$nodelim_exitval"
    fi
    # expr is more portable than $(())
    newnum=$(expr "$filenum" + 1)  # pulled out for readability (ha)
    newname=$(printf "%s\n" "$filename" | \
              sed "s$D^\\($(escregex "$prefix$sep")\\)[0-9][0-9]*$D\\1$(escsedrepl "$newnum")$D")

    # move the file
    #
    # if we renumber the files without going in descending order,
    # we'll overwrite some, but sorting on the $filenum is tricky;
    # instead, add .new, then rename all of them
    mv "$filename" "$newname.new"
  done  # first pass

  # remove .new extensions
  for filename in "$prefix$sep"[0-9]*"$suffix"*".new"; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*.new" ]; then
      break
    fi

    # check more precisely and move the file
    #
    # do some contortions to avoid needing egrep
    if printf "%s\n" "$filename" | grep "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.new$" > /dev/null 2>&1 \
       || \
       printf "%s\n" "$filename" | grep "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.lz\.new$" > /dev/null 2>&1 \
       || \
       printf "%s\n" "$filename" | grep "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.gz\.new$" > /dev/null 2>&1 \
       || \
       printf "%s\n" "$filename" | grep "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz\.new$" > /dev/null 2>&1 \
       || \
       printf "%s\n" "$filename" | grep "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz2\.new$" > /dev/null 2>&1; then
      mv "$filename" "$(printf "%s\n" "$filename" | sed 's|\.new$||')"
    else
      continue
    fi
  done

  # handle the most recent file
  for filename in "$prefix$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$suffix")$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$suffix")\.lz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$suffix")\.gz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$suffix")\.bz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$suffix")\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # move the file
    D=$(getseddelim "^$(escregex "$prefix$suffix")$(escsedrepl "$prefix${sep}1$suffix")")
    if [ "$D" = "" ]; then
      sendalert "can't find a delimiter for string '^$(escregex "$prefix$suffix")$(escsedrepl "$prefix${sep}1$suffix")' in function rotatenumfiles(); exiting" log
      do_exit "$nodelim_exitval"
    fi
    mv "$filename" "$(printf "%s\n" "$filename" | \
                      sed "s$D^$(escregex "$prefix$suffix")$D$(escsedrepl "$prefix${sep}1$suffix")$D")"
  done
}

#
# prune numbered files by number and date
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, numf, daysf, filename, filenum, D
#
prunenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

  # anything to do?
  if [ "$numf" = "0" ] && [ "$daysf" = "0" ]; then
    return
  fi

  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.lz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.gz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz$" > /dev/null 2>&1 \
       && \
       printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep")[0-9][0-9]*$(escregex "$suffix")\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # the regexp could be a bit more concise, but it would be less portable
    D=$(getseddelim "^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$\\1")
    if [ "$D" = "" ]; then
      sendalert "can't find a delimiter for string '^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$\\1' in function prunenumfiles(); exiting" log
      do_exit "$nodelim_exitval"
    fi
    filenum=$(printf "%s\n" "$filename" | \
              sed "s$D^$(escregex "$prefix$sep")\\([0-9][0-9]*\\)$(escregex "$suffix").*\$$D\\1$D")

    # check number and delete
    if [ "$numf" != "0" ] && [ "$filenum" -ge "$numf" ]; then
      # -r for dirs
      rm -rf "$filename"
      continue
    fi

    # delete by date
    if [ "$daysf" != "0" ]; then
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    fi
  done
}

#
# prune dated files by date
#
# _should_ also prune by number, but it's practically impossible to do
# it properly in pure shell
#
# $1: full path up to the date, not including any trailing separator
# $2: separator before the date
# $3: suffix after the date, including any leading separator
#
# $4: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# note: "current" file must exist before calling this function, so that
# it can be counted
#
# also, because we can't make any assumptions about the format of the date
# string, this function can be over-broad in the files it looks at;
# make sure there are no files that match $prefix$sep*$suffix* except for
# the desired ones
#
# "local" vars: prefix, sep, suffix, daysf, filename
#
prunedatefiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  daysf="$4"

  # prune by date
  if [ "$daysf" != "0" ]; then
    for filename in "$prefix$sep"*"$suffix"*; do
      # if nothing is found, the actual glob will be used for $filename
      if [ "$filename" = "$prefix$sep*$suffix*" ]; then
        break
      fi

      # check more precisely
      #
      # do some contortions to avoid needing egrep
      if printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep").*$(escregex "$suffix")$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep").*$(escregex "$suffix")\.lz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep").*$(escregex "$suffix")\.gz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep").*$(escregex "$suffix")\.bz$" > /dev/null 2>&1 \
         && \
         printf "%s\n" "$filename" | grep -v "^$(escregex "$prefix$sep").*$(escregex "$suffix")\.bz2$" > /dev/null 2>&1; then
        continue
      fi

      # delete
      #
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    done
  fi
}

#
# wrapper: prune numbered or dated files by number and date
#
# dated files are only pruned by date; _should_ also prune by number,
# but it's practically impossible to do it properly in pure shell
#
# $1: layout type
#
# $2: full path up to the number/date, not including any trailing separator
# $3: separator before the number/date
# $4: suffix after the number/date, including any leading separator
#     (cannot begin with a number if using a numbered layout)
#
# $5: number of files, 0=unlimited
# $6: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $4
#
# also works on directories
#
prunefiles () {
  case "$1" in
    # currently, the function is not actually called for "append",
    # but put it here for future use / FTR
    single|singledir|append)
      :  # nothing to do
      ;;
    number|numberdir)
      prunenumfiles "$2" "$3" "$4" "$5" "$6"
      ;;
    date|datedir)
      prunedatefiles "$2" "$3" "$4" "$6"
      ;;
  esac
}

#
# rotate and prune the output logs
#
# filenames can have an optional trailing .gz, .bz, .bz2, or .lz
#
# global vars: outputlog, outputlog_layout, outputlog_sep, numlogs, dayslogs
#
rotatepruneoutputlogs () {
  if [ "$outputlog" = "" ]; then
    logstatus "output logging is off; not rotating logs"
    return
  fi

  if [ "$outputlog_layout" = "append" ]; then
    logstatus "output logs are being appended to a single file; not rotating logs"
    return
  fi

  logstatus "rotating logs"

  # rotate
  if [ "$outputlog_layout" = "number" ]; then
    rotatenumfiles "$outputlog" "$outputlog_sep" ""
  fi

  # prune
  prunefiles "$outputlog_layout" "$outputlog" "$outputlog_sep" "" \
             "$numlogs" "$dayslogs"
}

#
# remove a file, including zipped versions of it
#
# $1 = file to remove
# $2 = type of zip to remove (same options as *_zipmode)
#
removefilezip () {
  rm -f "$1"
  case "$2" in
    none)
      :  # nothing else to remove
      ;;
    gzip|pigz)
      rm -f "$1.gz"
      ;;
    bzip2)
      rm -f "$1.bz"
      rm -f "$1.bz2"
      ;;
    lzip)
      rm -f "$1.lz"
      ;;
  esac
}


##############################
# core functions: SSH tunnels
##############################

#
# open an SSH tunnel
#
# one tunnel at a time; closesshtunnel() must be run before opening
# another tunnel
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# "local" vars: waited, sshexit
# global vars: cmd, sshpid, tun_prefix, tun_localport, tun_sshtimeout,
#              vars for setsshcmd()
# FDs: 3
#
opensshtunnel () {
  # set $cmd for ssh; see SECURITY NOTE, above, about this
  setsshcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running ssh command for $tun_prefix: $cmd" all
  printf "%s\n" "running ssh command for $tun_prefix: $cmd" >&3

  # run the command
  #
  # note & _in the quotes_, so $! contains the correct pid
  eval "$cmd >&3 2>&1 &"
  sshpid="$!"

  # make sure it's actually working;
  # see http://mywiki.wooledge.org/ProcessManagement#Starting_a_.22daemon.22_and_checking_whether_it_started_successfully
  waited="0"
  while sleep 1; do
    nc -z localhost "$tun_localport" && break
    if kill -0 "$sshpid"; then
      # expr is more portable than $(())
      waited=$(expr "$waited" + 1)
      if [ "$waited" -ge "$tun_sshtimeout" ]; then
        sendalert "could not establish SSH tunnel for $tun_prefix (timed out); exiting" log
        kill "$sshpid"
        wait "$sshpid"
        case "$on_ssherr" in
          exit)
            do_exit "$sshtunnel_exitval"
            ;;
          phase)
            return 1  # skip to the next phase
            ;;
        esac
      fi
    else
      wait "$sshpid"
      sshexit="$?"
      sendalert "could not establish SSH tunnel for $tun_prefix (error code $sshexit); exiting" log
      case "$on_ssherr" in
        exit)
          do_exit "$sshtunnel_exitval"
          ;;
        phase)
          return 1  # skip to the next phase
          ;;
      esac
    fi
  done

  logstatus "SSH tunnel for $tun_prefix established"

  return 0
}

#
# close an SSH tunnel
#
# global vars: sshpid, tun_prefix
#
closesshtunnel () {
  kill "$sshpid"
  wait "$sshpid"
  sshpid=""  # so we know if a tunnel is open
  logstatus "SSH tunnel for $tun_prefix closed"
}


###########################
# core functions: DB dumps
###########################

#
# are we going to need the list of all DBs?
#
# factored out in case this varies by DBMS
#
# global vars: dbms_prefix, *_dbmode, *_splitdbs
#
needdblist () {
  case "$dbms_prefix" in
    mysql)
      if { [ "$dbms_dbmode" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
         || \
         [ "$dbms_dbmode" = "exclude" ]; then
        return 0  # true
      else
        return 1  # false
      fi
      ;;
  esac
}

#
#
# get the list of all DBs if necessary
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# global vars: dbms_dbmode, dbms_splitdbs, lockfile, alldbs, alldbstmp, cmd,
#              newline, tab, vars for needdblist()
# tempfiles: alldbs, alldbstmp
# FDs: 3
#
getdblist () {
  # do we need the list?
  if needdblist; then
    :  # avoid non-portable 'if !'
  else
    return 0
  fi

  # set $cmd to get DB list; see SECURITY NOTE, above, about this
  setdblistcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running $dbms_prefix get-DB-list command: $cmd" all
  printf "%s\n" "running $dbms_prefix get-DB-list command: $cmd" >&3

  # run the command
  rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
  eval "$cmd" > "$lockfile/$alldbs" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    sendalert "could not get the list of $dbms_prefix databases; exiting" log
    case "$on_dblisterr" in
      exit)
        do_exit "$getdblist_exitval"
        ;;
      phase)
        return 1  # skip to the next phase
        ;;
    esac
  else
    logstatus "obtained the list of $dbms_prefix databases"
  fi

  # separate this by DBMS in case some have different output formats,
  # but most can probably be lumped together;
  # however, they all need to be massaged into the same format:
  # DB names separated by newlines, with these encodings:
  # newline -> \n
  # tab -> \t
  # \ -> \\

  case "$dbms_prefix" in
    mysql)
      # check for characters that could break out of a quoted string,
      # or drop things into one
      #
      # could be done more simply with egrep/grep -E, but this way is
      # probably more portable
      rm -f "$lockfile/$alldbstmp"  # to prevent noclobber-type issues
      tr -d "'\"\`$" < "$lockfile/$alldbs" \
                     > "$lockfile/$alldbstmp"
      if filecomp "$lockfile/$alldbs" "$lockfile/$alldbstmp"; then
        :  # avoid non-portable 'if !'
      else  # cover both mismatch and error
        sendalert "the list of $dbms_prefix databases contains a dangerous character; exiting" log
        case "$on_dbcharerr" in
          exit)
            do_exit "$dblistchar_exitval"
            ;;
          phase)
            return 1  # skip to the next phase
            ;;
        esac
      fi
      ;;
  esac

  return 0
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary
#
# this populates two sets of path variables: one for the dump, with a place
# for the DB name, and one for the rotation/pruning, with a place for the
# number/date (and the DB name, if $dbms_layout is not a "dir" option)
#
# note that for "number"/"numberdir" layouts, dumpprefix and dumpsuffix omit
# the number, because the most recent version is unnumbered
#
# mkdir -p isn't portable, so subdirectories must be directly under the
# dumpdir (until/unless we emulate it...)
#
# global vars: dumpprefix, dumpsuffix, rotateprefix, rotatesep,
#              rotatesuffix, dbms_splitdbs, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_datestring
#
getdumppaths () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
      else
        rotatesep="$dbms_filedirsep"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      rotateprefix="$dbms_dumpdir/$dbms_fileprefix"
      if [ "$dbms_fileprefix" = "" ] && [ "$dbms_splitdbs" = "no" ]; then
        rotatesep=""
        dumpsuffix="$dbms_datestring$dbms_filesuffix"
      else
        rotatesep="$dbms_filedirsep"
        dumpsuffix="$dbms_filedirsep$dbms_datestring$dbms_filesuffix"
      fi
      rotatesuffix="$dbms_filesuffix"
      ;;
    singledir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix=""
      rotatesep=""
      rotatesuffix=""
      ;;
    numberdir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
      rotatesep="$dbms_filedirsep"
      rotatesuffix=""
      ;;
    datedir)
      if [ "$dbms_subdirprefix" = "" ]; then
        [ ! -d "$dbms_dumpdir/$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/"
        rotatesep=""
      else
        [ ! -d "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep"
        dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
        rotateprefix="$dbms_dumpdir/$dbms_subdirprefix"
        rotatesep="$dbms_filedirsep"
      fi
      dumpsuffix="$dbms_filesuffix"
      rotatesuffix=""
      ;;
  esac
}

#
# run a single DB dump, including file rotation, etc.
#
# see getdumppaths() for info about dumpprefix/dumpsep/dumpsuffix
#
# $cmd must be pre-set, including, e.g., database names; however
# $1 must also be set to the database name, if dbms_splitdbs="yes"
#
# returns 1 to mean "skip to the next phase of the backup",
# 2 to mean "we have skipped this DB",
# else 0
#
# "local" vars: dbname, fileexists
# global vars: newline, dumptmp, dumpprefix, dumpsuffix, rotateprefix,
#              rotatesep, rotatesuffix, cmd, dbms_layout, dbms_numfiles,
#              dbms_daysfiles, dbms_zipmode, dbms_zipoptions, dbms_preserve
# FDs: 3
#
do_dbdump () {
  dbname="$1"

  # rotate if we need to, to make way for the new dump
  case "$dbms_layout" in
    number)
      rotatenumfiles "$rotateprefix$dbname" "$rotatesep" "$rotatesuffix"
      ;;
    numberdir)
      rotatenumfiles "$rotateprefix" "$rotatesep" "$rotatesuffix"
      ;;
  esac

  # are we (still) about to overwrite an existing dump?
  fileexists="no"
  if [ "$dbms_layout" != "single" ] \
     && \
     [ "$dbms_layout" != "singledir" ]; then
    #
    [ -f "$dumpprefix$dbname$dumpsuffix" ] && fileexists="yes"
    #
    { [ "$dbms_zipmode" = "gzip" ] || [ "$dbms_zipmode" = "pigz" ]; } && \
      [ -f "$dumpprefix$dbname$dumpsuffix.gz" ] && fileexists="yes"
    #
    [ "$dbms_zipmode" = "bzip2" ] && \
      { [ -f "$dumpprefix$dbname$dumpsuffix.bz" ] || [ -f "$dumpprefix$dbname$dumpsuffix.bz2" ]; } && \
      fileexists="yes"
    #
    [ "$dbms_zipmode" = "lzip" ] && \
      [ -f "$dumpprefix$dbname$dumpsuffix.lz" ] && fileexists="yes"
  fi

  if [ "$fileexists" = "yes" ]; then
    case "$on_dbduplerr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists; exiting" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; exiting" log
        fi
        do_exit "$dumpexists_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists;${newline}skipping to next phase of backup" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists;${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "dumpfile for $dbms_prefix database \"$dbname\" already exists; skipping" log
        else
          sendalert "dumpfile for $dbms_prefix database(s) already exists; skipping" log
        fi
        return 2  # skip to the next DB
        ;;
      warn)
        if [ "$dbname" != "" ]; then
          sendalert "warning: dumpfile for $dbms_prefix database \"$dbname\" already exists; overwriting" log
        else
          sendalert "warning: dumpfile for $dbms_prefix database(s) already exists; overwriting" log
        fi
        ;;
      ignore)
        :  # do nothing
        ;;
    esac
  fi

  # if we're dumping a single database, log the name
  if [ "$dbname" != "" ]; then
    logstatus "dumping $dbms_prefix database \"$dbname\""
  fi

  # $cmd must be pre-set for DB dump, including DB name(s);
  # see SECURITY NOTE, above, about this

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running $dbms_prefix dump command: $cmd" all
  printf "%s\n" "running $dbms_prefix dump command: $cmd" >&3

  # starting timestamp
  printf "%s\n" "$dbms_prefix dump started $(date)" >&3

  # clean up ("space" preservation mode; see below)
  if [ "$dbms_preserve" = "space" ]; then
    # prune old dumpfiles
    case "$dbms_layout" in
      single|number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      singledir|numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac

    # remove any current dumpfile that's in the way ("single"/"singledir",
    # or from, e.g., rerunning the backup)
    removefilezip "$dumpprefix$dbname$dumpsuffix"
  fi

  # run the command
  case "$dbms_preserve" in
    data)
      rm -f "$dumpprefix$dbname$dumpsuffix$dumptmp"  # safer for >
      eval "$cmd" > "$dumpprefix$dbname$dumpsuffix$dumptmp" 2>&3
      ;;
    space)
      eval "$cmd" > "$dumpprefix$dbname$dumpsuffix" 2>&3
      ;;
  esac

  # check status
  if [ "$?" != 0 ]; then
    case "$on_dumperr" in
      exit)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\"; exiting" log
        else
          sendalert "error dumping $dbms_prefix database(s); exiting" log
        fi
        do_exit "$dbdump_exitval"
        ;;
      phase)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\";${newline}skipping to next phase of backup" log
        else
          sendalert "error dumping $dbms_prefix database(s);${newline}skipping to next phase of backup" log
        fi
        return 1  # skip to the next phase
        ;;
      db)
        if [ "$dbname" != "" ]; then
          sendalert "error dumping $dbms_prefix database \"$dbname\"; skipping" log
        else
          sendalert "error dumping $dbms_prefix database(s); skipping" log
        fi
        return 2  # skip to the next DB
        ;;
    esac
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped $dbms_prefix database \"$dbname\""
    else
      logstatus "successfully dumped $dbms_prefix database(s)"
    fi
  fi

  # ending timestamp
  printf "%s\n" "$dbms_prefix dump finished $(date)" >&3

  # clean up ("data" preservation mode; see above)
  if [ "$dbms_preserve" = "data" ]; then
    # remove current dumpfile (including zips), and move the temp file into
    # place
    #
    # only really need the zip part of this, since we use mv -f
    removefilezip "$dumpprefix$dbname$dumpsuffix"
    mv -f "$dumpprefix$dbname$dumpsuffix$dumptmp" \
          "$dumpprefix$dbname$dumpsuffix"

    # prune old dumpfiles
    case "$dbms_layout" in
      single|number|date)
        prunefiles "$dbms_layout" "$rotateprefix$dbname" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
      singledir|numberdir|datedir)
        prunefiles "$dbms_layout" "$rotateprefix" "$rotatesep" \
                   "$rotatesuffix" "$dbms_numfiles" "$dbms_daysfiles"
        ;;
    esac
  fi

  # zip current dumpfile
  #
  # wait until after pruning; we use less total space during the backup
  # process, and don't sacrifice any data preservation gain
  if [ "$dbms_zipmode" != "none" ]; then
    # starting timestamp
    printf "%s\n" "$dbms_zipmode started $(date)" >&3

    # no " so we can specify multiple options
    "$dbms_zipmode" $dbms_zipoptions "$dumpprefix$dbname$dumpsuffix" >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      case "$on_ziperr" in
        exit)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\"; exiting" log
          else
            sendalert "error compressing $dbms_prefix database(s); exiting" log
          fi
          do_exit "$dbzip_exitval"
          ;;
        phase)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\";${newline}skipping to next phase of backup" log
          else
            sendalert "error compressing $dbms_prefix database(s);${newline}skipping to next phase of backup" log
          fi
          return 1  # skip to the next phase
          ;;
        db)
          if [ "$dbname" != "" ]; then
            sendalert "error compressing $dbms_prefix database \"$dbname\"; skipping" log
          else
            sendalert "error compressing $dbms_prefix database(s); skipping" log
          fi
          return 2  # skip to the next DB
          ;;
      esac
    else
      if [ "$dbname" != "" ]; then
        logstatus "successfully compressed $dbms_prefix database \"$dbname\""
      else
        logstatus "successfully compressed $dbms_prefix database(s)"
      fi
    fi
    # ending timestamp
    printf "%s\n" "$dbms_zipmode finished $(date)" >&3
  fi

  return 0
}

#
# convert DB name escape sequences to the real characters
#
# $1 = DB name to un-escape
#
# sequences to un-escape:
#   newline -> \n
#   tab -> \t
#   \ -> \\
#
# see also getdblist()
#
dbunescape () {
  # note: \\ must be last; \t isn't portable in sed
  printf "%s\n" "$1" | sed \
      -e 's/^\\n/\n/' -e 's/\([^\]\)\\n/\1\n/g' \
      -e "s/^\\\\t/$tab/" -e "s/\\([^\\]\)\\\\t/\\1$tab/g" \
      -e 's/\\\\/\\/g'
}

#
# wrapper around the different modes of DB dumps
# (split/unsplit, all/include/exclude/etc.)
#
# returns 1 to mean "skip to the next phase of the backup", else 0
#
# "local" vars: OLDIFS, dbnames, dbname_esc, dbname, exclude_esc, exclude
# global vars: IFS, tab, newline, dbms_dbmode, dbms_dbs, dbms_splitdbs,
#              lockfile, alldbs
# tempfiles: alldbs
#
do_dbdumploop () {
  OLDIFS="$IFS"

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbmode" in
      all)
        setdbdumpallcmd
        ;;
      include)
        dbnames=""
        IFS="$tab$newline"
        for dbname_esc in $(printf "%s" "$dbms_dbs"); do
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          dbnames="$dbnames \"$dbname\""
          IFS="$tab$newline"
        done
        IFS="$OLDIFS"
        setdbdumpmultcmd "$dbnames"
        ;;
      exclude)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS="$tab$newline"
          for exclude_esc in $(printf "%s" "$dbms_dbs"); do
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS="$tab$newline"
          done
          IFS="$OLDIFS"

          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        setdbdumpmultcmd "$dbnames"
        ;;
      includefile)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$dbms_dbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$dbms_dbs"
        IFS="$OLDIFS"
        setdbdumpmultcmd "$dbnames"
        ;;
      excludefile)
        dbnames=""
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS=""
          while read -r exclude_esc; do  # < "$dbms_dbs"
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS=""
          done < "$dbms_dbs"
          IFS="$OLDIFS"

          dbnames="$dbnames \"$dbname\""
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        setdbdumpmultcmd "$dbnames"
        ;;
    esac  # case "$dbms_dbmode"
    do_dbdump
    [ "$?" = "1" ] && return 1  # skip to the next phase
  else  # dbms_splitdbs="yes"
    case "$dbms_dbmode" in
      all)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        ;;
      include)
        IFS="$tab$newline"
        for dbname_esc in $(printf "%s" "$dbms_dbs"); do
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS="$tab$newline"
        done
        IFS="$OLDIFS"
        ;;
      exclude)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS="$tab$newline"
          for exclude_esc in $(printf "%s" "$dbms_dbs"); do
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS="$tab$newline"
          done
          IFS="$OLDIFS"

          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
       ;;
      includefile)
        IFS=""
        while read -r dbname_esc; do  # < "$dbms_dbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$dbms_dbs"
        IFS="$OLDIFS"
        ;;
      excludefile)
        IFS=""
        while read -r dbname_esc; do  # < "$lockfile/$alldbs"
          IFS="$OLDIFS"
          dbname=$(dbunescape "$dbname_esc")

          IFS=""
          while read -r exclude_esc; do  # < "$dbms_dbs"
            IFS="$OLDIFS"
            exclude=$(dbunescape "$exclude_esc")
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
            IFS=""
          done < "$dbms_dbs"
          IFS="$OLDIFS"

          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          [ "$?" = "1" ] && return 1  # skip to the next phase
          IFS=""
        done < "$lockfile/$alldbs"
        IFS="$OLDIFS"
        ;;
    esac  # case "$dbms_dbmode"
  fi  # if [ "$dbms_splitdbs" = "no" ]

  return 0
}


##########################################
# command line and configuration settings
##########################################

configfile=""
noconfigfile="no"
mode=""

while [ "$#" -gt 0 ]; do
  case "$1" in
    -f)
      shift
      if [ "$#" = "0" ]; then
        throwusageerr "Error: -f requires a config-file path; exiting."
      else
        configfile="$1"
        noconfigfile="no"
        shift
      fi
      ;;
    -n)
      noconfigfile="yes"
      configfile=""
      shift
      ;;
    *)
      mode="${1#--}"
      shift
      ;;
  esac
done

checklist "mode" "" "help" "usage" "license" "config" "settings" \
          "cmds" "commands" "status" "statusall" "silence" \
          "unsilence" "stop" "disable" "start" "enable" "clearlock" \
          "unlock" "create" "systemtest"

# first deal with the modes that don't require sourcing the config file
# or dealing with settings
case "$mode" in
  help|usage)
    # print the usage message
    usage
    do_exit "$no_error_exitval"
    ;;
  license)
    # print the license message
    license
    do_exit "$no_error_exitval"
    ;;
  create)
    # output a "blank" config file
    #
    # do this _before_ applying default config file
    if [ "$noconfigfile" = "no" ] && [ "$configfile" != "" ]; then
      if [ -f "$configfile" ]; then
        throwusageerr "Error: specified config file already exists; exiting."
      else
        exec 3>&1  # save for later
        exec 1>"$configfile"
      fi
    fi
    echo
    echo "# see CONFIG for details"
    echo
    configsettings | while read setting; do
      eval 'printf "%s\n" "#$setting=\"\""'
    done
    if [ "$noconfigfile" = "no" ] && [ "$configfile" != "" ]; then
      exec 1>&3  # put stdout back
    fi
    do_exit "$no_error_exitval"
    ;;
esac

# save variables set on the command line
savevars

# check and source config file
if [ "$noconfigfile" = "no" ]; then
  # apply default config file if applicable
  if [ "$configfile" = "" ]; then
    configfile="$defaultconfigfile"
  fi

  checkreadfile "configfile"

  # . won't work with no directory (unless ./ is in the PATH);
  # the cwd has to be specified explicitly
  if printf "%s\n" "$configfile" | grep -v '/' > /dev/null 2>&1; then
    . "./$configfile"
  else
    . "$configfile"
  fi
fi

# restore variables set on the command line, overriding the config file
restorevars

# apply default settings where applicable
applydefaults

# validate the config
checkconf

# debug mode?
# (in case it was turned on in the config file, but not on the command line;
# see above)
if [ "$debugme" = "yes" ]; then
  do_debug
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$mode" in
  config|settings)
    # print the current config settings
    echo
    printconfig
    echo
    do_exit "$no_error_exitval"
    ;;
  cmds|commands)
    # print the actual commands that would be run (ssh, DBMS, rsync)
    printcmds
    do_exit "$no_error_exitval"
    ;;
  status|statusall)
    # print the current status
    echo
    if [ "$mode" = "statusall" ]; then  # include temp files
      printstatus all
    else
      printstatus
    fi
    echo
    do_exit "$no_error_exitval"
    ;;
  silence)
    # silence lockfile-exists alerts
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory doesn't exist; nothing to silence"
      do_exit "$startup_exitval"
    fi
    if [ -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already silenced"
      do_exit "$startup_exitval"
    fi
    # using a file in the lockfile dir means that we automatically
    # get the silencing cleared when the lockfile is removed
    touch "$lockfile/$silencealerts"
    echo "lockfile alerts have been silenced"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile alerts have been silenced, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    if [ ! -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already unsilenced"
      do_exit "$startup_exitval"
    fi
    rm -f "$lockfile/$silencealerts"
    echo "lockfile alerts have been unsilenced"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile alerts have been unsilenced, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  stop|disable)
    # disable backups
    if [ -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already disabled"
      do_exit "$startup_exitval"
    fi
    if [ -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory exists; a backup is probably running"
      echo "disable command will take effect after the current backup finishes"
      echo
    fi
    mkdir "$lockfile" > /dev/null 2>&1  # ignore already-exists errors
    touch "$lockfile/$disable"
    echo "backups have been disabled; remember to re-enable them later!"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been disabled, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  start|enable)
    # re-enable backups
    if [ ! -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already enabled"
      do_exit "$startup_exitval"
    fi
    rm -f "$lockfile/$disable"
    echo "backups have been re-enabled"
    echo "if a backup is not currently running, you should now remove the lockfile"
    echo "with the unlock command"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been re-enabled, lockfile=\"$lockfile\""
    do_exit "$no_error_exitval"
    ;;
  clearlock|unlock)
    # remove lockfile dir
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile has already been removed"
      do_exit "$startup_exitval"
    fi
    echo
    echo "WARNING: the lockfile should only be removed if you're sure a backup is not"
    echo "currently running."
    echo "Type 'y' (without the quotes) to continue."
    # it would be nice to have this on the same line as the prompt,
    # but the portability issues aren't worth it for this
    read type_y
    if [ "$type_y" != "y" ]; then
      echo "Exiting."
      do_exit "$no_error_exitval"
    fi
    echo
    rm -rf "$lockfile"
    echo "lockfile has been removed"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile \"$lockfile\" has been manually removed"
    do_exit "$no_error_exitval"
    ;;
  systemtest)
    echo
    echo "checking for commands in the PATH..."
    echo "(note that missing commands may not matter, depending on the command"
    echo "and the settings used; on the other hand, commands may be present"
    echo "but not support required options)"
    echo
    externalcmds | while read cmd; do
      if command -v "$cmd" > /dev/null 2>&1; then
        printf "%-10s\n" "$cmd was found"
      else
        printf "%-10s\n" "$cmd was NOT found"
      fi
    done
    echo
    do_exit "$no_error_exitval"
    ;;
esac

# log config file, current working directory, and setting variables supplied
# on the command line
logconfig


################
# status checks
################

if [ "$runevery" != "0" ]; then
  # has it been long enough since the last backup started?
  #
  # if $startedfile exists and is newer than $runevery, exit
  # (-f instead of -e because it's more portable)
  if [ -f "$startedfile" ] && newerthan "$startedfile" "$runevery"; then
    logstatus "backup interval has not expired; exiting"
    do_exit "$no_error_exitval"
  else
    logstatus "backup interval has expired; continuing"
  fi
else
  logstatus "interval checking has been disabled; continuing"
fi

# did the previous backup finish?
#
# use an atomic command to check and create the lock
# (could also be ln -s, but we might not be able to set the metadata, and
#  it could cause issues with commands that don't manipulate links directly;
#  plus, now we have a tempdir)
if mkdir "$lockfile" > /dev/null 2>&1; then
  # got the lock, clear lock-alert status
  if [ -f "$alertfile" ]; then  # -f is more portable than -e
    rm "$alertfile"
    sendalert "lockfile created; cancelling previous alert status" log
  fi
  # set flag to remove the lockfile (etc.) on exit
  cleanup_on_exit="yes"
else
  # assume mkdir failed because it already existed;
  # but that could be because we manually disabled backups
  if [ -f "$lockfile/$disable" ]; then
    logalert "backups have been manually disabled; exiting"
  else
    logalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  # don't actually exit yet

  # send the initial alert email (no "log", we already logged it)
  #
  # (-f instead of -e because it's more portable)
  if [ ! -f "$alertfile" ]; then
    touch "$alertfile"
    if [ -f "$lockfile/$disable" ]; then
      sendalert "backups have been manually disabled; exiting"
    else
      sendalert "could not create lockfile (previous backup still running or failed?); exiting"
    fi
    do_exit "$lockfile_exitval"
  fi

  # but what about subsequent emails?

  # if ifrunning=0, log it but don't send email
  if [ "$ifrunning" = "0" ]; then
    logalert "ifrunning=0; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # if alerts have been silenced, log it but don't send email
  # (and don't bother checking $ifrunning)
  if [ -f "$lockfile/$silencealerts" ]; then
    logalert "alerts have been silenced; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # if $alertfile is newer than $ifrunning, log it but don't send email
  if newerthan "$alertfile" "$ifrunning"; then
    logalert "alert interval has not expired; no email sent"
    do_exit "$lockfile_exitval"
  fi

  # send an alert email (no "log", we already logged it)
  touch "$alertfile"
  if [ -f "$lockfile/$disable" ]; then
    sendalert "backups have been manually disabled; exiting"
  else
    sendalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  do_exit "$lockfile_exitval"
fi  # if mkdir "$lockfile"


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for the current output log; set the filename while we're at it
outputlog_filename="$outputlog"
if [ "$outputlog" != "" ] && [ "$outputlog_layout" = "date" ]; then
  if [ "$outputlog_date" != "" ]; then
    outputlog_datestring=$(date "$outputlog_date")
  else
    outputlog_datestring=$(date)
  fi
  outputlog_filename="$outputlog_filename$outputlog_sep$outputlog_datestring"
  touch "$outputlog_filename"  # needed for prunedayslogs()
fi

# for the current DB dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      dbms_datestring=$(date "$dbms_filedirdate")
    else
      dbms_datestring=$(date)
    fi
    eval "`printf '%s\n' $dbms`_datestring=\"$dbms_datestring\""
  fi
done


###################
# start output log
###################

# set up a fifo for logging; this has two benefits:
# 1) we can handle multiple output options in one place
# 2) we can run commands without needing pipelines, so we can get the
#    return values
mkfifo "$lockfile/$logfifo"

# rotate and prune output logs
# (also tests in case there is no output log, and prints status accordingly)
rotatepruneoutputlogs

if [ "$outputlog" != "" ]; then
  # append to the output log and possibly stdout
  # appending is always safe / the right thing to do, because either the
  # file won't exist, or it will have been moved out of the way by the
  # rotation - except in one case:
  # if we're using a date layout, and the script has been run more recently
  # than the datestring allows for, we should append so as not to lose
  # information
  if [ "$quiet" = "no" ]; then  # default to yes
    tee -a "$outputlog_filename" < "$lockfile/$logfifo" &
  else
    cat >> "$outputlog_filename" < "$lockfile/$logfifo" &
  fi
else  # no output log
  if [ "$quiet" = "no" ]; then
    cat < "$lockfile/$logfifo" &
  else
    cat > /dev/null < "$lockfile/$logfifo" &
  fi
fi

# create an fd to write to instead of the fifo,
# so it won't be closed after every line;
# see http://mywiki.wooledge.org/BashFAQ/085
exec 3> "$lockfile/$logfifo"


################
# begin working
################

# starting notifications/timestamps
logstatus "starting backup"
touch "$startedfile"
printf "%s\n" "backup started $(date)" >&3

# are we supposed to actually do anything?
do_something="no"  # set this to yes later if we do something


###########
# DB dumps
###########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_dbms () {
  if [ "$dbms_usetunnel" = "yes" ]; then
    closesshtunnel
  fi
}

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    do_something="yes"

    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms"
      opensshtunnel
      [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase
    fi

    # get the list of all DBs if necessary
    getdblist
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary
    getdumppaths

    # do the actual dump(s)
    do_dbdumploop
    [ "$?" = "1" ] && skip_dbms && continue  # skip to the next phase

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

# pull out cleanup for use when we skip to the next phase
# note: skip will have already been logged
skip_rsync () {
  # close the SSH tunnel
  if [ "$rsync_mode" = "tunnel" ]; then
    closesshtunnel
  fi
}

while true; do  # only here to allow us to easily skip to the next phase
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    logstatus "starting rsync backup sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync"
      opensshtunnel
      [ "$?" = "1" ] && skip_rsync && continue  # skip to the next phase
    fi

    # set $cmd for rsync; see SECURITY NOTE, above, about this
    setrsynccmd

    # log the command; only log to syslog if usesyslog="all"
    logstatusquiet "running rsync command: $cmd" all
    printf "%s\n" "running rsync command: $cmd" >&3

    # starting timestamp
    printf "%s\n" "rsync started $(date)" >&3

    # run the command
    eval "$cmd" >&3 2>&1

    # check status
    if [ "$?" != 0 ]; then
      sendalert "warning: rsync finished with errors; please check the log" log
      setexitval "$rsync_exitval"
    else
      logstatus "rsync completed without errors"
    fi

    # ending timestamp
    printf "%s\n" "rsync finished $(date)" >&3

    # close the SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      closesshtunnel
    fi

    logstatus "rsync backup sequence completed"
  fi

  break  # don't actually loop
done


###############
# done working
###############

# did we actually do anything?
if [ "$do_something" = "no" ]; then  # everything was turned off
  logstatus "nothing to do, because no actions are turned on"
fi

# finishing notifications
logstatus "backup finished"
printf "%s\n" "backup finished $(date)" >&3


##################
# stop output log
##################

# remove the fifo and kill the reader process;
# note that we don't have to worry about doing this if we exit abnormally,
# because exiting will close the fd, and the fifo is in the lockfile dir

exec 3>&-  # close the fd, this should kill the reader
rm -f "$lockfile/$logfifo"


###########
# clean up
###########

do_exit "$no_error_exitval"
