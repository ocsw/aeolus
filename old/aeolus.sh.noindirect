#!/bin/sh

###################################
# configurable rsync backup script
# by Daniel Malament
###################################

# see usage() and the backup.usage and config files for usage notes

# exit values (if there are multiple errors, the first one to occur is used):
# 0 = no error (e.g. runevery hasn't expired, or backup was completed
#     without errors)
# 1 = problem with the script invocation, the config file, or a setting
# 2 = previous lockfile still exists (possibly because backups were
#     manually disabled)
# 3 = problem opening SSH tunnel
# 4 = error getting DB list
# 5 = problem with DB list (e.g. unsafe characters or delimiter already
#     present)
# 6 = error dumping DB
# 7 = rsync error

# lockfile dir is used for the following files:
# disable, silencealerts, timetemp, logfifo, alldbs, alldbs.orig

# modification note: any change to the setting variables (additions,
# deletions, name changes, type changes, etc.) must be reflected
# in sendalert(), checkconf(), savevars(), logclvars(), restorevars(),
# and possibly some of switch*()


# TODO:
# do more to protect against leading - in settings?
# better handling of long errors?
# i18n?
#
# setup notes
# setup modes?
#
# name & refs, incl repl. $0
#
# git
# checker script
# self-updating? (2x md5, global lock)
#
# postgres
# adding a DBMS:
#   add vars to config file, modeling after MySQL (but split up
#     *_dump*options if necessary)
#   add vars to the relevant functions (see above)
#   add to adddbconncmd(), setdblistcmd(), setdbdump*cmd()
#   add to dbmslist
#
# if nothing to do
# problem with "`""`"
# quoting for sed, etc.
# prefix/suffix
# check* - var indirection

#http://mywiki.wooledge.org/BashFAQ/082
#http://www.gnu.org/s/hello/manual/autoconf/Shell-Substitutions.html#Shell-Substitutions


############
# debugging
############

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
if [ "$debugme" = "yes" ]; then
  set -x
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
dbmslist="mysql"


##############################################
# helper functions: housekeeping and wrappers
##############################################

#
# update an exit value for the script
#
# if the value has already been set, don't change it,
# so that we can return the value corresponding to
# the first error encountered
#
# global vars: exitval
#
exitval="-1"
setexitval () {
  if [ "$exitval" = "-1" ]; then
    exitval="$1"
  fi
}

#
# update exit value (see setexitval()) and exit, possibly doing some cleanup
#
# $1 = exit value (required)
# if $2 = "clean", remove the lockfile, unless the disable semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: lockfile, exitval
# tempfiles: $lockfile/disable
#
do_exit () {
  if [ "$2" = "clean" ]; then
    if [ ! -f "$lockfile/disable" ]; then
      rm -r "$lockfile"
    fi
    # otherwise, a disable command must have been run while we were
    # doing this backup; leave the lockfile dir alone, so future backups
    # will be disabled
  fi

  setexitval "$1"
  exit "$exitval"
}

#
# get the parent directory of a file or dir
#
# this is more portable and more correct than dirname;
# in particular, dirname returns . for any of . ./ .. ../
# which fits the documentation, but doesn't make sense, at least not here
#
# to get the "standard" behavior, make $2 non-null
#
# "local" vars: parentdir
#
getparentdir () {
  # remove trailing /'s
  parentdir=`echo "$1" | sed 's|/*$||'`

  # are there no /'s left?
  if echo "$parentdir" | grep -v '/' > /dev/null 2>&1; then
    if [ "$parentdir" = "" ]; then
      echo "/"  # it was /, and / is its own parent
      return
    fi
    if [ "$2" = "" ]; then
      if [ "$parentdir" = "." ]; then
        echo ".."
        return
      fi
      if [ "$parentdir" = ".." ]; then
        echo "../.."
        return
      fi
    fi
    echo "."
    return
  fi
  parentdir=`echo "$parentdir" | sed 's|/*[^/]*$||'`
  if [ "$parentdir" = "" ]; then
    echo "/"
    return
  fi
  echo "$parentdir"
}

# tests for getparentdir:
#getparentdir //                   # /
#getparentdir //foo                # /
#getparentdir //foo//              # /
#getparentdir //foo//bar           # //foo
#getparentdir //foo//bar//         # //foo
#getparentdir //foo//bar//baz      # //foo//bar
#getparentdir //foo//bar//baz//    # //foo//bar
#getparentdir .                    # ..
#getparentdir .//                  # ..
#getparentdir . x                  # .
#getparentdir .// x                # .
#getparentdir .//foo               # .
#getparentdir .//foo//             # .
#getparentdir .//foo//bar          # .//foo
#getparentdir .//foo//bar//        # .//foo
#getparentdir .//foo//bar//baz     # .//foo//bar
#getparentdir .//foo//bar//baz//   # .//foo//bar
#getparentdir ..                   # ../..
#getparentdir ..//                 # ../..
#getparentdir .. x                 # .
#getparentdir ..// x               # .
#getparentdir ..//foo              # ..
#getparentdir ..//foo//            # ..
#getparentdir ..//foo//bar         # ..//foo
#getparentdir ..//foo//bar//       # ..//foo
#getparentdir ..//foo//bar//baz    # ..//foo//bar
#getparentdir ..//foo//bar//baz//  # ..//foo//bar
#getparentdir foo                  # .
#getparentdir foo//                # .
#getparentdir foo//bar             # foo
#getparentdir foo//bar//           # foo
#getparentdir foo//bar//baz        # foo//bar
#getparentdir foo//bar//baz//      # foo//bar
#getparentdir foo//bar//baz// x    # foo//bar
#exit

#
# check if the file in $1 is less than $2 minutes old
#
# file must exist; check before calling
#
# factored out for simplicity, but it's also a wrapper to choose between
# different non-portable methods (some of which use $lockfile/timetemp)
#
# "local" vars: curtime, filetime, timediff, reftime
# global vars: timechecktype, lockfile
# tempfiles: $lockfile/timetemp
#
newerthan () {
  case "$timechecktype" in
    find)
      # find returns 0 even if no files are matched
      find "$1" \! -mmin +"$2" | grep "^$1$" > /dev/null 2>&1
      return "$?"
      ;;
    date-r)
      curtime=`date "+%s"`
      filetime=`date -r "$1" "+%s"`
      # expr is more portable than $(())
      timediff=`expr \( "$curtime" - "$filetime" \) / 60`
      if [ "$timediff" -lt "$2" ]; then
        return 0;  # true (newer)
      else
        return 1;  # false (older)
      fi
      ;;
    date-d)
      reftime=`date -d "$2 minutes ago" "+%Y%m%d%H%M.%S"`
      ;;  # continue after esac
    awk|gawk)
      reftime=`echo | "$timechecktype" \
          '{print strftime("%Y%m%d%H%M.%S", systime() - ('"$2"' * 60))}'`
      ;;  # continue after esac
  esac
  touch -t "$reftime" "$lockfile/timetemp"
  # find returns 0 even if no files are matched
  find "$1" -newer "$lockfile/timetemp" | grep "^$1$" > /dev/null 2>&1
}


#######################################
# helper functions: logging and alerts
#######################################

#
# log a message ($1) to the status log
# (depending on $statuslog)
#
# global vars: statuslog
#
logstatlog () {
  if [ "$statuslog" != "" ]; then
    # quotes preserve spacing in output of date
    echo "`date` [$$]: $1" >> "$statuslog"
  fi
}

#
# log a message ($1) to stdout and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprint () {
  # use "$1" to preserve spacing

  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    echo "$1"
  fi

  logstatlog "$1"
}

#
# log a message ($1) to stderr and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprinterr () {
  # use "$1" to preserve spacing

  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    echo "$1" 1>&2
  fi

  logstatlog "$1"
}

#
# actually send a syslog message; factored out here so logger
# is only called in one place, for maintainability
#
# $1 = message
# $2 = priority (facility.level or numeric)
#      (optional, use '.' if not passing priority but passing a tag)
# $3 = tag (optional)
#
# "local" vars: slcmd
#
do_syslog () {
  # see SECURITY NOTE, below, about this code
  slcmd="logger -i"
  [ "$2" != "" ] && [ "$2" != "." ] && slcmd="$slcmd -p \"$2\""
  [ "$3" != "" ] && slcmd="$slcmd -t \"$3\""
  slcmd="$slcmd \"$1\""
  eval "$slcmd"
}

#
# log a status message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogstat, syslogtag
#
logstatus () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogstat" "$syslogtag"
  fi

  logprint "$1"
}

#
# log an alert/error message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogerr, syslogtag
#
logalert () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogerr" "$syslogtag"
  fi

  logprint "$1"
}

#
# log a status message ($1) to syslog and/or the status log, (depending on
# $usesyslog and $statuslog), but not to stdout, regardless of the setting
# of $quiet
#
# used to avoid duplication when also logging to the backup log
#
# if $2 is "all", only log to syslog if usesyslog="all" (but status logging
# proceeds normally)
#
# "local" vars: savequiet
#
logstatusquiet () {
  savequiet="$quiet"
  quiet="yes"
  logstatus "$1" "$2"
  quiet="$savequiet"
}

#
# print the metadata of a file/dir if it exists,
# or "(none)" (used in alert emails)
#
# note: it would be nice to be able provide just timestamps,
# since the rest is much less useful here, and it would be easier
# to read, but it's more or less impossible to to that portably
#
getmetadata () {
  if [ -f "$1" ] || [ -d "$1" ]; then
    echo "`ls -ld "$1" 2>&1`"  # use echo "``" to preserve spacing
  else
    echo "(none)"
  fi
}

#
# send an alert email, including diagnostics,
# and log to syslog/terminal/status log that an email was sent
#
# * message begins with the contents of $1
# * if $2 is "log", also log $1 before the sent notice
#
# note: even if suppressemail="yes", $1 is still logged
# (if settings permit)
#
# global vars: suppressemail, mailto, subject, all other config settings
#
sendalert () {
  if [ "$suppressemail" != "yes" ]; then
    mailx -s "$subject" $mailto <<-EOF
	$1


	---------
	Settings:
	---------

	usepath="$usepath"
	timechecktype="$timechecktype"
	useumask="$useumask"
	debugme="$debugme"
	runevery="$runevery"
	startedfile="$startedfile"
	ifrunning="$ifrunning"
	lockfile="$lockfile"
	suppressemail="$suppressemail"
	mailto="$mailto"
	subject="$subject"
	alertfile="$alertfile"
	backuplog="$backuplog"
	backuplog_layout="$backuplog_layout"
	backuplog_sep="$backuplog_sep"
	backuplog_date="$backuplog_date"
	numlogs="$numlogs"
	dayslogs="$dayslogs"
	usesyslog="$usesyslog"
	syslogstat="$syslogstat"
	syslogerr="$syslogerr"
	syslogtag="$syslogtag"
	quiet="$quiet"
	statuslog="$statuslog"
	rsync_sshuser="$rsync_sshuser"
	rsync_sshhost="$rsync_sshhost"
	rsync_sshkey="$rsync_sshkey"
	rsync_sshport="$rsync_sshport"
	rsync_localport="$rsync_localport"
	rsync_remoteport="$rsync_remoteport"
	rsync_sshoptions="$rsync_sshoptions"
	rsync_sshtimeout="$rsync_sshtimeout"
	do_rsync="$do_rsync"
	rsyncmode="$rsyncmode"
	source="$source"
	dest="$dest"
	rsyncdport="$rsyncdport"
	passwordfile="$passwordfile"
	filterfile="$filterfile"
	rsyncoptions="$rsyncoptions"
	rsyncadd="$rsyncadd"
	mysql_dodump="$mysql_dodump"
	mysql_usetunnel="$mysql_usetunnel"
	mysql_sshuser="$mysql_sshuser"
	mysql_sshhost="$mysql_sshhost"
	mysql_sshkey="$mysql_sshkey"
	mysql_sshport="$mysql_sshport"
	mysql_localport="$mysql_localport"
	mysql_remoteport="$mysql_remoteport"
	mysql_sshoptions="$mysql_sshoptions"
	mysql_sshtimeout="$mysql_sshtimeout"
	mysql_user="$mysql_user"
	mysql_pwfile="$mysql_pwfile"
	mysql_protocol="$mysql_protocol"
	mysql_host="$mysql_host"
	mysql_port="$mysql_port"
	mysql_socket="$mysql_socket"
	mysql_dbs="$mysql_dbs"
	mysql_dblist="$mysql_dblist"
	mysql_dbdelim="$mysql_dbdelim"
	mysql_splitdbs="$mysql_splitdbs"
	mysql_clientoptions="$mysql_clientoptions"
	mysql_dumpoptions="$mysql_dumpoptions"
	mysql_dumpdir="$mysql_dumpdir"
	mysql_layout="$mysql_layout"
	mysql_fileprefix="$mysql_fileprefix"
	mysql_subdirprefix="$mysql_subdirprefix"
	mysql_filedirsep="$mysql_filedirsep"
	mysql_filedirdate="$mysql_filedirdate"
	mysql_numfiles="$mysql_numfiles"
	mysql_daysfiles="$mysql_daysfiles"
	mysql_zipmode="$mysql_zipmode"
	mysql_zipoptions="$mysql_zipoptions"


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	startedfile:
	`getmetadata "$startedfile"`

	lockfile:
	`getmetadata "$lockfile"`

	alertfile:
	`getmetadata "$alertfile"`
	EOF
  fi

  if [ "$2" = "log" ]; then
    logalert "$1"
  fi

  if [ "$suppressemail" != "yes" ]; then
    logalert "alert email sent to $mailto"
  fi
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# NOTE: when updating this, update backup.usage as well
#
# "local" vars: scriptname
#
usage () {
  scriptname=`echo "$0" | sed 's|^.*/||'`
  cat <<EOF 1>&2

Usage: [setting="value"] $scriptname /path/to/config/file [mode]

Multiple settings can be added to the command line, separated by spaces.

If the config file path is omitted, "./backup.conf" will be tried.

If the mode is "help" or "usage", this message is printed.

If the mode is "cmds", the ssh and rsync commands that would be run are
printed, but nothing else is done.

If the mode is "silence", then alerts about the lockfile existing will be
silenced until either they are unsilenced, or the lockfile is no longer
present.

If the mode is "unsilence", then alerts about the lockfile existing will be
re-enabled.

If the mode is "stop" or "disable", then backups will be disabled until
"start" or "enable" is used.

If the mode is "start" or "enable", then backups will be re-enabled.

If the mode is "clearlock" or "unlock", then the lockfile will be removed.
Only use this if you're sure a backup isn't currently running!

EOF
}

#
# print a startup error to stderr and exit
#
# $1 = message
#
throwerr () {
  cat <<-EOF 1>&2

	$1

	EOF
  do_exit 1
}

#
# print a bad-setting error to stderr and exit
#
# $1 = variable name
# $2 = variable value
#
settingerr () {
  throwerr "Error: invalid setting for $1 (\"$2\"); exiting."
}

#
# validate a setting that can't be blank
#
# $1 = variable name
# $2 = variable value
# "local" vars: vname, vval
#
checknoblank () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""
echo $vname $vval
  if [ "$vval" = "" ]; then
    throwerr "Error: $vname is not set; exiting."
  fi
}

#
# validate a setting that must be exactly one character
# (which can be anything except NUL)
#
# $1 = variable name
# $2 = variable value
#
checkonechar () {
  checknoblank "$1" "$2"

  if [ "`expr length "$2"`" != 1 ]; then
    throwerr "Error: $1 is longer than one character; exiting."
  fi
}

#
# validate a numeric setting (only 0-9 allowed)
#
# $1 = variable name
# $2 = variable value
# $3 = minimum (optional)
# $4 = maximum (optional)
#
checknum () {
  # use extra [0-9] to avoid having to use egrep
  if echo "$2" | grep '^[0-9][0-9]*$' > /dev/null 2>&1; then
    if [ "$3" != "" ] && [ "$2" -lt "$3" ]; then
      settingerr "$1" "$2"
    fi
    if [ "$4" != "" ] && [ "$2" -gt "$4" ]; then
      settingerr "$1" "$2"
    fi
  else
    settingerr "$1" "$2"
  fi
}

#
# validate a directory setting, for directories we're going to be creating
# and/or rotating files in:
# setting must not be blank, and directory must exist, be a directory or a
# symlink to a one, and be readable and writable
#
# $1 = variable name
# $2 = variable value
#
checkwritedir () {
  checknoblank "$1" "$2"

  # [ dereferences symlinks for us
  if [ ! -d "$2" ]; then
    throwerr "Error: $1 is not a directory or a symlink to one; exiting."
  fi
  if [ ! -r "$2" ]; then
    throwerr "Error: $1 is not readable; exiting."
  fi
  if [ ! -w "$2" ]; then
    throwerr "Error: $1 is not writable; exiting."
  fi
}

#
# validate a file setting, for files we're going to be touching,
# writing to, creating, and/or rotating:
# 1) it may not be blank
# 2) if the file exists, it must be a file or a directory
#    (or a link to one, since [ derefs links; dir is to allow for the
#    lockfile dir), and it must be writable
# 3) regardless, the parent directory must exist, be a directory,
#    and be readable and writable
#
# $1 = variable name
# $2 = variable value
#
# "local" vars: parentdir
#
checkcreatefile () {
  # condition 1
  checknoblank "$1" "$2"

  # condition 2
  #
  # note: [ -e ] isn't portable, so try ls, even though it's probably not
  # robust enough to be a general solution...
  if ls "$2" > /dev/null 2>&1; then
    if [ ! -f "$2" ] && [ ! -d "$2" ]; then
      throwerr "Error: $1 is not a file or directory; exiting."
    fi
    if [ ! -w "$2" ]; then
      throwerr "Error: $1 is not writable; exiting."
    fi
  fi

  # condition 3
  parentdir=`getparentdir "$2"`
  if [ ! -d "$parentdir" ]; then
    throwerr "Error: $1 is in a non-existent directory (\"$parentdir\"); exiting."
  fi
  if [ ! -r "$parentdir" ]; then
    throwerr "Error: $1 is in a non-readable directory; exiting."
  fi
  if [ ! -w "$parentdir" ]; then
    throwerr "Error: $1 is in a non-writable directory; exiting."
  fi
}

#
# validate a file setting, for files we just need to be able to read:
# setting must not be blank, and file must exist, be a file or a
# symlink to one, and be readable
#
# $1 = variable name
# $2 = variable value
#
checkreadfile () {
  # blank?
  checknoblank "$1" "$2"

  # not a file or symlink to one?
  # ([ dereferences symlinks for us)
  if [ ! -f "$2" ]; then
    throwerr "Error: $1 does not exist, or is not a file or a symlink to one; exiting."
  fi

  # not readable?
  if [ ! -r "$2" ]; then
    throwerr "Error: $1 is not readable; exiting."
  fi
}

#
# validate a file setting, for files we need to be able to read and write,
# but not create:
# setting must not be blank, and file must exist, be a file or a
# symlink to a file, and be readable and writable
#
# $1 = variable name
# $2 = variable value
#
checkrwfile () {
  checkreadfile "$1" "$2"

  # not writable?
  if [ ! -w "$2" ]; then
    throwerr "Error: $1 is not writable; exiting."
  fi
}

#
# validate a setting that can be one of a list of possiblities
#
# $1 = variable name (use "mode" for command-line mode setting)
# $2 = variable value
# other args = list of possiblities (can include "")
#
# "local" vars: vname, vval, poss
#
checklist () {
  vname="$1"
  vval="$2"
  shift
  shift  # shift 2 isn't portable

  # implied $@ isn't supported by ksh
  for poss in ${1+"$@"}; do
    if [ "$vval" = "$poss" ]; then
      return 0
    fi
  done

  if [ "$vname" = "mode" ]; then
    usage
    throwerr "Error: invalid mode supplied on the command line; exiting."
  else
    settingerr "$vname" "$vval"
  fi
}

#
# validate the configuration settings
#
# note: there are ways to get around having to supply both the name and
# the value of a variable, but they can be tricky and/or insecure
#
# global vars: all config settings except usepath, useumask, backuplog_sep,
#              backuplog_date, syslogtag, *_sshuser, *_sshoptions,
#              rsyncoptions, rsyncadd,
#              [DBMS]: *_user, *_clientoptions, *_dumpoptions,
#              *_dumponeoptions, *_dumpmultoptions, *_dumpalloptions,
#              *_filedirsep, *_filedirdate, *_zipoptions
#
checkconf () {
  # housekeeping
  #
  # note: umask could be symbolic in some shells, so we can't use checknum
  checklist "timechecktype" "$timechecktype" "find" "date-r" "date-d" \
            "awk" "gawk"
  checklist "debugme" "$debugme" "yes" "no"

  # checks and logging
  checknum "runevery" "$runevery"
  checkcreatefile "startedfile" "$startedfile"
  checknum "ifrunning" "$ifrunning"
  checkcreatefile "lockfile" "$lockfile"
  checklist "suppressemail" "$suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    checknoblank "mailto"
do_exit 0 clean
    [ "$subject" = "" ] && subject="backup alert on `hostname`"
  fi
  checkcreatefile "alertfile" "$alertfile"
  if [ "$backuplog" != "" ]; then
    checkcreatefile "backuplog" "$backuplog"
    checklist "backuplog_layout" "$backuplog_layout" "append" "number" "date"
  fi
  checknum "numlogs" "$numlogs"
  checknum "dayslogs" "$dayslogs"
  checklist "usesyslog" "$usesyslog" "all" "yes" "no"
  if [ "$usesyslog" != "no" ]; then
    [ "$syslogstat" = "" ] && syslogstat="."  # see do_syslog()
    [ "$syslogerr" = "" ] && syslogerr="."  # see do_syslog()
  fi
  checklist "quiet" "$quiet" "yes" "no"
  [ "$statuslog" != "" ] && checkcreatefile "statuslog" "$statuslog"

  # rsync, including SSH tunnel
  checklist "do_rsync" "$do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    checklist "rsyncmode" "$rsyncmode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsyncmode" = "tunnel" ]; then
      checknoblank "rsync_sshhost" "$rsync_sshhost"
      [ "$rsync_localport" = "" ] && rsync_localport="8873"
      [ "$rsync_remoteport" = "" ] && rsync_remoteport="873"
      [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="15"
      checknum "rsync_localport" "$rsync_localport" 1 65535
      checknum "rsync_remoteport" "$rsync_remoteport" 1 65535
      checknum "rsync_sshtimeout" "$rsync_sshtimeout" 1
    fi
    if [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "nodaemon" ]; then
      [ "$rsync_sshkey" != "" ] && checkreadfile "rsync_sshkey" "$rsync_sshkey"
      [ "$rsync_sshport" = "" ] && rsync_sshport="22"
      checknum "rsync_sshport" "$rsync_sshport" 1 65535
    fi
    checknoblank "source" "$source"
    checknoblank "dest" "$dest"
    if [ "$rsyncmode" = "direct" ]; then
      [ "$rsyncdport" = "" ] && rsyncdport="873"
      checknum "rsyncdport" "$rsyncdport" 1 65535
    fi
    { [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "direct" ]; } && \
        checkreadfile "passwordfile" "$passwordfile"
    [ "$filterfile" != "" ] && checkreadfile "filterfile" "$filterfile"
  fi

  # MySQL dump, including SSH tunnel
  checklist "mysql_dodump" "$mysql_dodump" "yes" "no"
  if [ "$mysql_dodump" = "yes" ]; then
    checklist "mysql_usetunnel" "$mysql_usetunnel" "yes" "no"
    if [ "$mysql_usetunnel" = "yes" ]; then
      checknoblank "mysql_sshhost" "$mysql_sshhost"
      [ "$mysql_sshkey" != "" ] && checkreadfile "mysql_sshkey" \
                                                 "$mysql_sshkey"
      [ "$mysql_sshport" = "" ] && mysql_sshport="22"
      [ "$mysql_localport" = "" ] && mysql_localport="4306"
      [ "$mysql_remoteport" = "" ] && mysql_remoteport="3306"
      [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="15"
      checknum "mysql_sshport" "$mysql_sshport" 1 65535
      checknum "mysql_localport" "$mysql_localport" 1 65535
      checknum "mysql_remoteport" "$mysql_remoteport" 1 65535
      checknum "mysql_sshtimeout" "$mysql_sshtimeout" 1
      # ignore these
      mysql_protocol=""; mysql_host=""; mysql_port=""; mysql_socket=""
    else
      if [ "$mysql_host" != "" ]; then  # nothing to check, but...
        # ignore this
        mysql_socket=""
      fi
      if [ "$mysql_port" != "" ]; then
        checknum "mysql_port" "$mysql_port" 1 65535
        # ignore this
        mysql_socket=""
      fi
      [ "$mysql_socket" != "" ] && checkrwfile "mysql_socket" \
                                               "$mysql_socket"
    fi
    [ "$mysql_pwfile" != "" ] && checkreadfile "mysql_pwfile" "$mysql_pwfile"
    checklist "mysql_dbs" "$mysql_dbs" "all" "include" "exclude"
    [ "$mysql_dbs" != "all" ] && checknoblank "mysql_dblist" "$mysql_dblist"
    checklist "mysql_splitdbs" "$mysql_splitdbs" "yes" "no"
    { [ "$mysql_dbs" != "all" ] || [ "$mysql_splitdbs" = "yes" ]; } && \
        checkonechar "mysql_dbdelim" "$mysql_dbdelim"
    checkwritedir "mysql_dumpdir" "$mysql_dumpdir"
    checklist "mysql_layout" "$mysql_layout" "single" "number" "date" \
              "singledir" "numberdir" "datedir"
    [ "$mysql_splitdbs" = "no" ] && checknoblank "mysql_fileprefix" \
                                                 "$mysql_fileprefix"
    { [ "$mysql_layout" = "singledir" ] || [ "$mysql_layout" = "numberdir" ]; } && \
        checknoblank "mysql_subdirprefix" "$mysql_subdirprefix"
    if [ "$mysql_layout" != "single" ] && [ "$mysql_layout" != "singledir" ]; then
      checknum "mysql_numfiles" "$mysql_numfiles"
      checknum "mysql_daysfiles" "$mysql_daysfiles"
    fi
    [ "$mysql_zipmode" = "" ] && mysql_zipmode="none"
    checklist "mysql_zipmode" "$mysql_zipmode" "none" "gzip" "bzip2"
  fi
}

#
# save variables set on the command line (even if they're set to null)
#
# global vars: varssaved, all config settings, cl_* for all config settings
#
savevars () {
  # so we know if anything was saved, when we want to use logclvars
  varssaved="no"

  [ "${usepath+X}" = "X" ] && cl_usepath="$usepath" && varssaved="yes"
  [ "${timechecktype+X}" = "X" ] && cl_timechecktype="$timechecktype" && varssaved="yes"
  [ "${useumask+X}" = "X" ] && cl_useumask="$useumask" && varssaved="yes"
  [ "${debugme+X}" = "X" ] && cl_debugme="$debugme" && varssaved="yes"
  [ "${runevery+X}" = "X" ] && cl_runevery="$runevery" && varssaved="yes"
  [ "${startedfile+X}" = "X" ] && cl_startedfile="$startedfile" && varssaved="yes"
  [ "${ifrunning+X}" = "X" ] && cl_ifrunning="$ifrunning" && varssaved="yes"
  [ "${lockfile+X}" = "X" ] && cl_lockfile="$lockfile" && varssaved="yes"
  [ "${suppressemail+X}" = "X" ] && cl_suppressemail="$suppressemail" && varssaved="yes"
  [ "${mailto+X}" = "X" ] && cl_mailto="$mailto" && varssaved="yes"
  [ "${subject+X}" = "X" ] && cl_subject="$subject" && varssaved="yes"
  [ "${alertfile+X}" = "X" ] && cl_alertfile="$alertfile" && varssaved="yes"
  [ "${backuplog+X}" = "X" ] && cl_backuplog="$backuplog" && varssaved="yes"
  [ "${backuplog_layout+X}" = "X" ] && cl_backuplog_layout="$backuplog_layout" && varssaved="yes"
  [ "${backuplog_sep+X}" = "X" ] && cl_backuplog_sep="$backuplog_sep" && varssaved="yes"
  [ "${backuplog_date+X}" = "X" ] && cl_backuplog_date="$backuplog_date" && varssaved="yes"
  [ "${numlogs+X}" = "X" ] && cl_numlogs="$numlogs" && varssaved="yes"
  [ "${dayslogs+X}" = "X" ] && cl_dayslogs="$dayslogs" && varssaved="yes"
  [ "${usesyslog+X}" = "X" ] && cl_usesyslog="$usesyslog" && varssaved="yes"
  [ "${syslogstat+X}" = "X" ] && cl_syslogstat="$syslogstat" && varssaved="yes"
  [ "${syslogerr+X}" = "X" ] && cl_syslogerr="$syslogerr" && varssaved="yes"
  [ "${syslogtag+X}" = "X" ] && cl_syslogtag="$syslogtag" && varssaved="yes"
  [ "${quiet+X}" = "X" ] && cl_quiet="$quiet" && varssaved="yes"
  [ "${statuslog+X}" = "X" ] && cl_statuslog="$statuslog" && varssaved="yes"
  [ "${rsync_sshuser+X}" = "X" ] && cl_rsync_sshuser="$rsync_sshuser" && varssaved="yes"
  [ "${rsync_sshhost+X}" = "X" ] && cl_rsync_sshhost="$rsync_sshhost" && varssaved="yes"
  [ "${rsync_sshkey+X}" = "X" ] && cl_rsync_sshkey="$rsync_sshkey" && varssaved="yes"
  [ "${rsync_sshport+X}" = "X" ] && cl_rsync_sshport="$rsync_sshport" && varssaved="yes"
  [ "${rsync_localport+X}" = "X" ] && cl_rsync_localport="$rsync_localport" && varssaved="yes"
  [ "${rsync_remoteport+X}" = "X" ] && cl_rsync_remoteport="$rsync_remoteport" && varssaved="yes"
  [ "${rsync_sshoptions+X}" = "X" ] && cl_rsync_sshoptions="$rsync_sshoptions" && varssaved="yes"
  [ "${rsync_sshtimeout+X}" = "X" ] && cl_rsync_sshtimeout="$rsync_sshtimeout" && varssaved="yes"
  [ "${do_rsync+X}" = "X" ] && cl_do_rsync="$do_rsync" && varssaved="yes"
  [ "${rsyncmode+X}" = "X" ] && cl_rsyncmode="$rsyncmode" && varssaved="yes"
  [ "${source+X}" = "X" ] && cl_source="$source" && varssaved="yes"
  [ "${dest+X}" = "X" ] && cl_dest="$dest" && varssaved="yes"
  [ "${rsyncdport+X}" = "X" ] && cl_rsyncdport="$rsyncdport" && varssaved="yes"
  [ "${passwordfile+X}" = "X" ] && cl_passwordfile="$passwordfile" && varssaved="yes"
  [ "${filterfile+X}" = "X" ] && cl_filterfile="$filterfile" && varssaved="yes"
  [ "${rsyncoptions+X}" = "X" ] && cl_rsyncoptions="$rsyncoptions" && varssaved="yes"
  [ "${rsyncadd+X}" = "X" ] && cl_rsyncadd="$rsyncadd" && varssaved="yes"
  [ "${mysql_dodump+X}" = "X" ] && cl_mysql_dodump="$mysql_dodump" && varssaved="yes"
  [ "${mysql_usetunnel+X}" = "X" ] && cl_mysql_usetunnel="$mysql_usetunnel" && varssaved="yes"
  [ "${mysql_sshuser+X}" = "X" ] && cl_mysql_sshuser="$mysql_sshuser" && varssaved="yes"
  [ "${mysql_sshhost+X}" = "X" ] && cl_mysql_sshhost="$mysql_sshhost" && varssaved="yes"
  [ "${mysql_sshkey+X}" = "X" ] && cl_mysql_sshkey="$mysql_sshkey" && varssaved="yes"
  [ "${mysql_sshport+X}" = "X" ] && cl_mysql_sshport="$mysql_sshport" && varssaved="yes"
  [ "${mysql_localport+X}" = "X" ] && cl_mysql_localport="$mysql_localport" && varssaved="yes"
  [ "${mysql_remoteport+X}" = "X" ] && cl_mysql_remoteport="$mysql_remoteport" && varssaved="yes"
  [ "${mysql_sshoptions+X}" = "X" ] && cl_mysql_sshoptions="$mysql_sshoptions" && varssaved="yes"
  [ "${mysql_sshtimeout+X}" = "X" ] && cl_mysql_sshtimeout="$mysql_sshtimeout" && varssaved="yes"
  [ "${mysql_user+X}" = "X" ] && cl_mysql_user="$mysql_user" && varssaved="yes"
  [ "${mysql_pwfile+X}" = "X" ] && cl_mysql_pwfile="$mysql_pwfile" && varssaved="yes"
  [ "${mysql_protocol+X}" = "X" ] && cl_mysql_protocol="$mysql_protocol" && varssaved="yes"
  [ "${mysql_host+X}" = "X" ] && cl_mysql_host="$mysql_host" && varssaved="yes"
  [ "${mysql_port+X}" = "X" ] && cl_mysql_port="$mysql_port" && varssaved="yes"
  [ "${mysql_socket+X}" = "X" ] && cl_mysql_socket="$mysql_socket" && varssaved="yes"
  [ "${mysql_dbs+X}" = "X" ] && cl_mysql_dbs="$mysql_dbs" && varssaved="yes"
  [ "${mysql_dblist+X}" = "X" ] && cl_mysql_dblist="$mysql_dblist" && varssaved="yes"
  [ "${mysql_dbdelim+X}" = "X" ] && cl_mysql_dbdelim="$mysql_dbdelim" && varssaved="yes"
  [ "${mysql_splitdbs+X}" = "X" ] && cl_mysql_splitdbs="$mysql_splitdbs" && varssaved="yes"
  [ "${mysql_clientoptions+X}" = "X" ] && cl_mysql_clientoptions="$mysql_clientoptions" && varssaved="yes"
  [ "${mysql_dumpoptions+X}" = "X" ] && cl_mysql_dumpoptions="$mysql_dumpoptions" && varssaved="yes"
  [ "${mysql_dumpdir+X}" = "X" ] && cl_mysql_dumpdir="$mysql_dumpdir" && varssaved="yes"
  [ "${mysql_layout+X}" = "X" ] && cl_mysql_layout="$mysql_layout" && varssaved="yes"
  [ "${mysql_fileprefix+X}" = "X" ] && cl_mysql_fileprefix="$mysql_fileprefix" && varssaved="yes"
  [ "${mysql_subdirprefix+X}" = "X" ] && cl_mysql_subdirprefix="$mysql_subdirprefix" && varssaved="yes"
  [ "${mysql_filedirsep+X}" = "X" ] && cl_mysql_filedirsep="$mysql_filedirsep" && varssaved="yes"
  [ "${mysql_filedirdate+X}" = "X" ] && cl_mysql_filedirdate="$mysql_filedirdate" && varssaved="yes"
  [ "${mysql_numfiles+X}" = "X" ] && cl_mysql_numfiles="$mysql_numfiles" && varssaved="yes"
  [ "${mysql_daysfiles+X}" = "X" ] && cl_mysql_daysfiles="$mysql_daysfiles" && varssaved="yes"
  [ "${mysql_zipmode+X}" = "X" ] && cl_mysql_zipmode="$mysql_zipmode" && varssaved="yes"
  [ "${mysql_zipoptions+X}" = "X" ] && cl_mysql_zipoptions="$mysql_zipoptions" && varssaved="yes"
}

#
# log the variables that were set on the command line
#
# must be run after savevars()
#
# (\" will be lost in syslog, but work elsewhere - see SECURITY NOTE, below)
#
# global vars: all config settings, cl_* for all config settings
#
logclvars () {
  [ "${cl_usepath+X}" = "X" ] && logstatus "usepath=\"$cl_usepath\""
  [ "${cl_timechecktype+X}" = "X" ] && logstatus "timechecktype=\"$cl_timechecktype\""
  [ "${cl_useumask+X}" = "X" ] && logstatus "useumask=\"$cl_useumask\""
  [ "${cl_debugme+X}" = "X" ] && logstatus "debugme=\"$cl_debugme\""
  [ "${cl_runevery+X}" = "X" ] && logstatus "runevery=\"$cl_runevery\""
  [ "${cl_startedfile+X}" = "X" ] && logstatus "startedfile=\"$cl_startedfile\""
  [ "${cl_ifrunning+X}" = "X" ] && logstatus "ifrunning=\"$cl_ifrunning\""
  [ "${cl_lockfile+X}" = "X" ] && logstatus "lockfile=\"$cl_lockfile\""
  [ "${cl_suppressemail+X}" = "X" ] && logstatus "suppressemail=\"$cl_suppressemail\""
  [ "${cl_mailto+X}" = "X" ] && logstatus "mailto=\"$cl_mailto\""
  [ "${cl_subject+X}" = "X" ] && logstatus "subject=\"$cl_subject\""
  [ "${cl_alertfile+X}" = "X" ] && logstatus "alertfile=\"$cl_alertfile\""
  [ "${cl_backuplog+X}" = "X" ] && logstatus "backuplog=\"$cl_backuplog\""
  [ "${cl_backuplog_layout+X}" = "X" ] && logstatus "backuplog_layout=\"$cl_backuplog_layout\""
  [ "${cl_backuplog_sep+X}" = "X" ] && logstatus "backuplog_sep=\"$cl_backuplog_sep\""
  [ "${cl_backuplog_date+X}" = "X" ] && logstatus "backuplog_date=\"$cl_backuplog_date\""
  [ "${cl_numlogs+X}" = "X" ] && logstatus "numlogs=\"$cl_numlogs\""
  [ "${cl_dayslogs+X}" = "X" ] && logstatus "dayslogs=\"$cl_dayslogs\""
  [ "${cl_usesyslog+X}" = "X" ] && logstatus "usesyslog=\"$cl_usesyslog\""
  [ "${cl_syslogstat+X}" = "X" ] && logstatus "syslogstat=\"$cl_syslogstat\""
  [ "${cl_syslogerr+X}" = "X" ] && logstatus "syslogerr=\"$cl_syslogerr\""
  [ "${cl_syslogtag+X}" = "X" ] && logstatus "syslogtag=\"$cl_syslogtag\""
  [ "${cl_quiet+X}" = "X" ] && logstatus "quiet=\"$cl_quiet\""
  [ "${cl_statuslog+X}" = "X" ] && logstatus "statuslog=\"$cl_statuslog\""
  [ "${cl_rsync_sshuser+X}" = "X" ] && logstatus "rsync_sshuser=\"$cl_rsync_sshuser\""
  [ "${cl_rsync_sshhost+X}" = "X" ] && logstatus "rsync_sshhost=\"$cl_rsync_sshhost\""
  [ "${cl_rsync_sshkey+X}" = "X" ] && logstatus "rsync_sshkey=\"$cl_rsync_sshkey\""
  [ "${cl_rsync_sshport+X}" = "X" ] && logstatus "rsync_sshport=\"$cl_rsync_sshport\""
  [ "${cl_rsync_localport+X}" = "X" ] && logstatus "rsync_localport=\"$cl_rsync_localport\""
  [ "${cl_rsync_remoteport+X}" = "X" ] && logstatus "rsync_remoteport=\"$cl_rsync_remoteport\""
  [ "${cl_rsync_sshoptions+X}" = "X" ] && logstatus "rsync_sshoptions=\"$cl_rsync_sshoptions\""
  [ "${cl_rsync_sshtimeout+X}" = "X" ] && logstatus "rsync_sshtimeout=\"$cl_rsync_sshtimeout\""
  [ "${cl_do_rsync+X}" = "X" ] && logstatus "do_rsync=\"$cl_do_rsync\""
  [ "${cl_rsyncmode+X}" = "X" ] && logstatus "rsyncmode=\"$cl_rsyncmode\""
  [ "${cl_source+X}" = "X" ] && logstatus "source=\"$cl_source\""
  [ "${cl_dest+X}" = "X" ] && logstatus "dest=\"$cl_dest\""
  [ "${cl_rsyncdport+X}" = "X" ] && logstatus "rsyncdport=\"$cl_rsyncdport\""
  [ "${cl_passwordfile+X}" = "X" ] && logstatus "passwordfile=\"$cl_passwordfile\""
  [ "${cl_filterfile+X}" = "X" ] && logstatus "filterfile=\"$cl_filterfile\""
  [ "${cl_rsyncoptions+X}" = "X" ] && logstatus "rsyncoptions=\"$cl_rsyncoptions\""
  [ "${cl_rsyncadd+X}" = "X" ] && logstatus "rsyncadd=\"$cl_rsyncadd\""
  [ "${cl_mysql_dodump+X}" = "X" ] && logstatus "mysql_dodump=\"$cl_mysql_dodump\""
  [ "${cl_mysql_usetunnel+X}" = "X" ] && logstatus "mysql_usetunnel=\"$cl_mysql_usetunnel\""
  [ "${cl_mysql_sshuser+X}" = "X" ] && logstatus "mysql_sshuser=\"$cl_mysql_sshuser\""
  [ "${cl_mysql_sshhost+X}" = "X" ] && logstatus "mysql_sshhost=\"$cl_mysql_sshhost\""
  [ "${cl_mysql_sshkey+X}" = "X" ] && logstatus "mysql_sshkey=\"$cl_mysql_sshkey\""
  [ "${cl_mysql_sshport+X}" = "X" ] && logstatus "mysql_sshport=\"$cl_mysql_sshport\""
  [ "${cl_mysql_localport+X}" = "X" ] && logstatus "mysql_localport=\"$cl_mysql_localport\""
  [ "${cl_mysql_remoteport+X}" = "X" ] && logstatus "mysql_remoteport=\"$cl_mysql_remoteport\""
  [ "${cl_mysql_sshoptions+X}" = "X" ] && logstatus "mysql_sshoptions=\"$cl_mysql_sshoptions\""
  [ "${cl_mysql_sshtimeout+X}" = "X" ] && logstatus "mysql_sshtimeout=\"$cl_mysql_sshtimeout\""
  [ "${cl_mysql_user+X}" = "X" ] && logstatus "mysql_user=\"$cl_mysql_user\""
  [ "${cl_mysql_pwfile+X}" = "X" ] && logstatus "mysql_pwfile=\"$cl_mysql_pwfile\""
  [ "${cl_mysql_protocol+X}" = "X" ] && logstatus "mysql_protocol=\"$cl_mysql_protocol\""
  [ "${cl_mysql_host+X}" = "X" ] && logstatus "mysql_host=\"$cl_mysql_host\""
  [ "${cl_mysql_port+X}" = "X" ] && logstatus "mysql_port=\"$cl_mysql_port\""
  [ "${cl_mysql_socket+X}" = "X" ] && logstatus "mysql_socket=\"$cl_mysql_socket\""
  [ "${cl_mysql_dbs+X}" = "X" ] && logstatus "mysql_dbs=\"$cl_mysql_dbs\""
  [ "${cl_mysql_dblist+X}" = "X" ] && logstatus "mysql_dblist=\"$cl_mysql_dblist\""
  [ "${cl_mysql_dbdelim+X}" = "X" ] && logstatus "mysql_dbdelim=\"$cl_mysql_dbdelim\""
  [ "${cl_mysql_splitdbs+X}" = "X" ] && logstatus "mysql_splitdbs=\"$cl_mysql_splitdbs\""
  [ "${cl_mysql_clientoptions+X}" = "X" ] && logstatus "mysql_clientoptions=\"$cl_mysql_clientoptions\""
  [ "${cl_mysql_dumpoptions+X}" = "X" ] && logstatus "mysql_dumpoptions=\"$cl_mysql_dumpoptions\""
  [ "${cl_mysql_dumpdir+X}" = "X" ] && logstatus "mysql_dumpdir=\"$cl_mysql_dumpdir\""
  [ "${cl_mysql_layout+X}" = "X" ] && logstatus "mysql_layout=\"$cl_mysql_layout\""
  [ "${cl_mysql_fileprefix+X}" = "X" ] && logstatus "mysql_fileprefix=\"$cl_mysql_fileprefix\""
  [ "${cl_mysql_subdirprefix+X}" = "X" ] && logstatus "mysql_subdirprefix=\"$cl_mysql_subdirprefix\""
  [ "${cl_mysql_filedirsep+X}" = "X" ] && logstatus "mysql_filedirsep=\"$cl_mysql_filedirsep\""
  [ "${cl_mysql_filedirdate+X}" = "X" ] && logstatus "mysql_filedirdate=\"$cl_mysql_filedirdate\""
  [ "${cl_mysql_numfiles+X}" = "X" ] && logstatus "mysql_numfiles=\"$cl_mysql_numfiles\""
  [ "${cl_mysql_daysfiles+X}" = "X" ] && logstatus "mysql_daysfiles=\"$cl_mysql_daysfiles\""
  [ "${cl_mysql_zipmode+X}" = "X" ] && logstatus "mysql_zipmode=\"$cl_mysql_zipmode\""
  [ "${cl_mysql_zipoptions+X}" = "X" ] && logstatus "mysql_zipoptions=\"$cl_mysql_zipoptions\""
}

#
# restore variables set on the command line, overriding the config file
#
# global vars: all config settings, cl_* for all config settings
#
restorevars () {
  [ "${cl_usepath+X}" = "X" ] && usepath="$cl_usepath"
  [ "${cl_timechecktype+X}" = "X" ] && timechecktype="$cl_timechecktype"
  [ "${cl_useumask+X}" = "X" ] && useumask="$cl_useumask"
  [ "${cl_debugme+X}" = "X" ] && debugme="$cl_debugme"
  [ "${cl_runevery+X}" = "X" ] && runevery="$cl_runevery"
  [ "${cl_startedfile+X}" = "X" ] && startedfile="$cl_startedfile"
  [ "${cl_ifrunning+X}" = "X" ] && ifrunning="$cl_ifrunning"
  [ "${cl_lockfile+X}" = "X" ] && lockfile="$cl_lockfile"
  [ "${cl_suppressemail+X}" = "X" ] && suppressemail="$cl_suppressemail"
  [ "${cl_mailto+X}" = "X" ] && mailto="$cl_mailto"
  [ "${cl_subject+X}" = "X" ] && subject="$cl_subject"
  [ "${cl_alertfile+X}" = "X" ] && alertfile="$cl_alertfile"
  [ "${cl_backuplog+X}" = "X" ] && backuplog="$cl_backuplog"
  [ "${cl_backuplog_layout+X}" = "X" ] && backuplog_layout="$cl_backuplog_layout"
  [ "${cl_backuplog_sep+X}" = "X" ] && backuplog_sep="$cl_backuplog_sep"
  [ "${cl_backuplog_date+X}" = "X" ] && backuplog_date="$cl_backuplog_date"
  [ "${cl_numlogs+X}" = "X" ] && numlogs="$cl_numlogs"
  [ "${cl_dayslogs+X}" = "X" ] && dayslogs="$cl_dayslogs"
  [ "${cl_usesyslog+X}" = "X" ] && usesyslog="$cl_usesyslog"
  [ "${cl_syslogstat+X}" = "X" ] && syslogstat="$cl_syslogstat"
  [ "${cl_syslogerr+X}" = "X" ] && syslogerr="$cl_syslogerr"
  [ "${cl_syslogtag+X}" = "X" ] && syslogtag="$cl_syslogtag"
  [ "${cl_quiet+X}" = "X" ] && quiet="$cl_quiet"
  [ "${cl_statuslog+X}" = "X" ] && statuslog="$cl_statuslog"
  [ "${cl_rsync_sshuser+X}" = "X" ] && rsync_sshuser="$cl_rsync_sshuser"
  [ "${cl_rsync_sshhost+X}" = "X" ] && rsync_sshhost="$cl_rsync_sshhost"
  [ "${cl_rsync_sshkey+X}" = "X" ] && rsync_sshkey="$cl_rsync_sshkey"
  [ "${cl_rsync_sshport+X}" = "X" ] && rsync_sshport="$cl_rsync_sshport"
  [ "${cl_rsync_localport+X}" = "X" ] && rsync_localport="$cl_rsync_localport"
  [ "${cl_rsync_remoteport+X}" = "X" ] && rsync_remoteport="$cl_rsync_remoteport"
  [ "${cl_rsync_sshoptions+X}" = "X" ] && rsync_sshoptions="$cl_rsync_sshoptions"
  [ "${cl_rsync_sshtimeout+X}" = "X" ] && rsync_sshtimeout="$cl_rsync_sshtimeout"
  [ "${cl_do_rsync+X}" = "X" ] && do_rsync="$cl_do_rsync"
  [ "${cl_rsyncmode+X}" = "X" ] && rsyncmode="$cl_rsyncmode"
  [ "${cl_source+X}" = "X" ] && source="$cl_source"
  [ "${cl_dest+X}" = "X" ] && dest="$cl_dest"
  [ "${cl_rsyncdport+X}" = "X" ] && rsyncdport="$cl_rsyncdport"
  [ "${cl_passwordfile+X}" = "X" ] && passwordfile="$cl_passwordfile"
  [ "${cl_filterfile+X}" = "X" ] && filterfile="$cl_filterfile"
  [ "${cl_rsyncoptions+X}" = "X" ] && rsyncoptions="$cl_rsyncoptions"
  [ "${cl_rsyncadd+X}" = "X" ] && rsyncadd="$cl_rsyncadd"
  [ "${cl_mysql_dodump+X}" = "X" ] && mysql_dodump="$cl_mysql_dodump"
  [ "${cl_mysql_usetunnel+X}" = "X" ] && mysql_usetunnel="$cl_mysql_usetunnel"
  [ "${cl_mysql_sshuser+X}" = "X" ] && mysql_sshuser="$cl_mysql_sshuser"
  [ "${cl_mysql_sshhost+X}" = "X" ] && mysql_sshhost="$cl_mysql_sshhost"
  [ "${cl_mysql_sshkey+X}" = "X" ] && mysql_sshkey="$cl_mysql_sshkey"
  [ "${cl_mysql_sshport+X}" = "X" ] && mysql_sshport="$cl_mysql_sshport"
  [ "${cl_mysql_localport+X}" = "X" ] && mysql_localport="$cl_mysql_localport"
  [ "${cl_mysql_remoteport+X}" = "X" ] && mysql_remoteport="$cl_mysql_remoteport"
  [ "${cl_mysql_sshoptions+X}" = "X" ] && mysql_sshoptions="$cl_mysql_sshoptions"
  [ "${cl_mysql_sshtimeout+X}" = "X" ] && mysql_sshtimeout="$cl_mysql_sshtimeout"
  [ "${cl_mysql_user+X}" = "X" ] && mysql_user="$cl_mysql_user"
  [ "${cl_mysql_pwfile+X}" = "X" ] && mysql_pwfile="$cl_mysql_pwfile"
  [ "${cl_mysql_protocol+X}" = "X" ] && mysql_protocol="$cl_mysql_protocol"
  [ "${cl_mysql_host+X}" = "X" ] && mysql_host="$cl_mysql_host"
  [ "${cl_mysql_port+X}" = "X" ] && mysql_port="$cl_mysql_port"
  [ "${cl_mysql_socket+X}" = "X" ] && mysql_socket="$cl_mysql_socket"
  [ "${cl_mysql_dbs+X}" = "X" ] && mysql_dbs="$cl_mysql_dbs"
  [ "${cl_mysql_dblist+X}" = "X" ] && mysql_dblist="$cl_mysql_dblist"
  [ "${cl_mysql_dbdelim+X}" = "X" ] && mysql_dbdelim="$cl_mysql_dbdelim"
  [ "${cl_mysql_splitdbs+X}" = "X" ] && mysql_splitdbs="$cl_mysql_splitdbs"
  [ "${cl_mysql_clientoptions+X}" = "X" ] && mysql_clientoptions="$cl_mysql_clientoptions"
  [ "${cl_mysql_dumpoptions+X}" = "X" ] && mysql_dumpoptions="$cl_mysql_dumpoptions"
  [ "${cl_mysql_dumpdir+X}" = "X" ] && mysql_dumpdir="$cl_mysql_dumpdir"
  [ "${cl_mysql_layout+X}" = "X" ] && mysql_layout="$cl_mysql_layout"
  [ "${cl_mysql_fileprefix+X}" = "X" ] && mysql_fileprefix="$cl_mysql_fileprefix"
  [ "${cl_mysql_subdirprefix+X}" = "X" ] && mysql_subdirprefix="$cl_mysql_subdirprefix"
  [ "${cl_mysql_filedirsep+X}" = "X" ] && mysql_filedirsep="$cl_mysql_filedirsep"
  [ "${cl_mysql_filedirdate+X}" = "X" ] && mysql_filedirdate="$cl_mysql_filedirdate"
  [ "${cl_mysql_numfiles+X}" = "X" ] && mysql_numfiles="$cl_mysql_numfiles"
  [ "${cl_mysql_daysfiles+X}" = "X" ] && mysql_daysfiles="$cl_mysql_daysfiles"
  [ "${cl_mysql_zipmode+X}" = "X" ] && mysql_zipmode="$cl_mysql_zipmode"
  [ "${cl_mysql_zipoptions+X}" = "X" ] && mysql_zipoptions="$cl_mysql_zipoptions"
}

#
# log config file, current working directory, and command-line settings
#
# global vars: configfile, varssaved
#
logconfig () {
  # `pwd` is more portable than $PWD
  logstatus "using config file: \"$configfile\", cwd: \"`pwd`\""
  if [ "$varssaved" = "yes" ]; then
    logstatus "settings passed on the command line:"
    logclvars
  else
    logstatus "no settings passed on the command line"
  fi
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g. "rsync" or part of
# $dbmslist)
#
# global vars: *_sshuser, *_sshhost, *_sshkey, *_sshport, *_localport,
#              *_remoteport, *_sshoptions, *_sshtimeout,
#              tun_prefix,
#              tun_sshuser, tun_sshhost, tun_sshkey, tun_sshport,
#              tun_localport, tun_remoteport, tun_sshoptions,
#              tun_sshtimeout
#
switchtunnel () {
  tun_prefix="$1"
  eval "tun_sshuser=\"$`echo $1`_sshuser\""
  eval "tun_sshhost=\"$`echo $1`_sshhost\""
  eval "tun_sshkey=\"$`echo $1`_sshkey\""
  eval "tun_sshport=\"$`echo $1`_sshport\""
  eval "tun_localport=\"$`echo $1`_localport\""
  eval "tun_remoteport=\"$`echo $1`_remoteport\""
  eval "tun_sshoptions=\"$`echo $1`_sshoptions\""
  eval "tun_sshtimeout=\"$`echo $1`_sshtimeout\""
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# global vars: *_dodump, *_usetunnel, *_user, *_pwfile, *_protocol, *_host
#              *_port, *_socket, *_dbs, *_dblist, *_dbdelim, *_splitdbs,
#              *_clientoptions, *_dumpoptions, *_dumponeoptions,
#              *_dumpmultoptions, *_dumpalloptions, *_dumpdir, *_layout,
#              *_fileprefix, *_subdirprefix, *_filedirsep, *_filedirdate,
#              *_numfiles, *_daysfiles, *_zipmode, *_zipoptions,
#              dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socket, dbms_dbs,
#              dbms_dblist, dbms_dbdelim, dbms_splitdbs, dbms_clientoptions,
#              dbms_dumpoptions, dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_subdirprefix, dbms_filedirsep,
#              dbms_filedirdate, dbms_numfiles, dbms_daysfiles,
#              dbms_zipmode, dbms_zipoptions,
#              dbms_datestring [internal]
#
switchdbms () {
  dbms_prefix="$1"
  eval "dbms_dodump=\"$`echo $1`_dodump\""
  eval "dbms_usetunnel=\"$`echo $1`_usetunnel\""
  eval "dbms_user=\"$`echo $1`_user\""
  eval "dbms_pwfile=\"$`echo $1`_pwfile\""
  eval "dbms_protocol=\"$`echo $1`_protocol\""
  eval "dbms_host=\"$`echo $1`_host\""
  eval "dbms_port=\"$`echo $1`_port\""
  eval "dbms_socket=\"$`echo $1`_socket\""
  eval "dbms_dbs=\"$`echo $1`_dbs\""
  eval "dbms_dblist=\"$`echo $1`_dblist\""
  eval "dbms_dbdelim=\"$`echo $1`_dbdelim\""
  eval "dbms_splitdbs=\"$`echo $1`_splitdbs\""
  eval "dbms_clientoptions=\"$`echo $1`_clientoptions\""
  eval "dbms_dumpoptions=\"$`echo $1`_dumpoptions\""
  eval "dbms_dumponeoptions=\"$`echo $1`_dumponeoptions\""
  eval "dbms_dumpmultoptions=\"$`echo $1`_dumpmultoptions\""
  eval "dbms_dumpalloptions=\"$`echo $1`_dumpalloptions\""
  eval "dbms_dumpdir=\"$`echo $1`_dumpdir\""
  eval "dbms_layout=\"$`echo $1`_layout\""
  eval "dbms_fileprefix=\"$`echo $1`_fileprefix\""
  eval "dbms_subdirprefix=\"$`echo $1`_subdirprefix\""
  eval "dbms_filedirsep=\"$`echo $1`_filedirsep\""
  eval "dbms_filedirdate=\"$`echo $1`_filedirdate\""
  eval "dbms_numfiles=\"$`echo $1`_numfiles\""
  eval "dbms_daysfiles=\"$`echo $1`_daysfiles\""
  eval "dbms_zipmode=\"$`echo $1`_zipmode\""
  eval "dbms_zipoptions=\"$`echo $1`_zipoptions\""
  # internal, not from config
  eval "dbms_datestring=\"$`echo $1`_datestring\""
}


####################################
# core functions: assemble commands
####################################

#
# these are factored out here so the "cmds" argument to the script
# doesn't make things complicated and unreadable;
# when running for real, they are used to set $cmd, which is then eval'ed
#

#
# SECURITY NOTE: this is the only portable way I've found to be able to
# pass optional arguments that can contain spaces, and get everything
# to work as expected; I've done some tests, and I'm pretty sure using
# eval like this, with early evaluation and as much quoting as possible,
# is at worst no more dangerous than passing user-supplied filenames
# and arguments is in the first place, but if anyone reading this has
# a better idea, I'm listening
#
# also, this approach doesn't handle some combinations of e.g. embedded
# quotes well, but it's probably good enough for this script, anyway
#

# see also do_syslog(), above

#
# set $cmd to the ssh command to run for a tunnel
#
# global vars: cmd, tun_localport, tun_remoteport, tun_sshport, tun_sshkey,
#              tun_sshoptions, tun_sshuser, tun_sshhost
#
setsshcmd () {
  cmd="ssh -L \"${tun_localport}:localhost:${tun_remoteport}\" -N"
  cmd="$cmd -p \"$tun_sshport\""
  [ "$tun_sshkey" != "" ] && cmd="$cmd -i \"$tun_sshkey\""
  # no \" so we can specify multiple options
  [ "$tun_sshoptions" != "" ] && cmd="$cmd $tun_sshoptions"
  [ "$tun_sshuser" != "" ] && cmd="$cmd -l \"$tun_sshuser\""
  cmd="$cmd \"$tun_sshhost\""
}

#
# add database connection options to $cmd
#
# global vars: cmd, dbms_prefix, *_user, *_pwfile, *_usetunnel, *_protocol,
#              *_host, *_port, *_socket
#
adddbconncmd () {
  case "$dbms_prefix" in
    mysql|mysql_)
      # --defaults-extra-file must be the first option
      [ "$mysql_pwfile" != "" ] && \
          cmd="$cmd \"--defaults-extra-file=$mysql_pwfile\""
      [ "$mysql_user" != "" ] && cmd="$cmd -u \"$mysql_user\""
      if [ "$mysql_usetunnel" = "yes" ]; then
        cmd="$cmd -h localhost"
        cmd="$cmd -P \"$mysql_localport\""
      else
        [ "$mysql_protocol" != "" ] && cmd="$cmd \"--protocol=$mysql_protocol\""
        [ "$mysql_host" != "" ] && cmd="$cmd -h \"$mysql_host\""
        [ "$mysql_port" != "" ] && cmd="$cmd -P \"$mysql_port\""
        [ "$mysql_socket" != "" ] && cmd="$cmd -S \"$mysql_socket\""
      fi
      ;;
  esac
}

#
# set $cmd to the command to run to get a list of databases
#
# global vars: cmd, dbms_prefix, *_clientoptions, vars for adddbconncmd()
#
setdblistcmd () {
  case "$dbms_prefix" in
    mysql|mysql_)
      cmd="mysql"
      adddbconncmd
      [ "$mysql_clientoptions" != "" ] && cmd="$cmd $mysql_clientoptions"
      cmd="$cmd -BN -e \"SHOW DATABASES;\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump a single database
#
# $1 is the name of the database to dump; if blank, it will be replaced
#    with "DBNAME", e.g. for running the script in cmds mode
#
# "local" vars: dbname
# global vars: cmd, dbms_prefix, *_dumponeoptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumponecmd () {
  if [ "$1" = "" ]; then
    dbname="DBNAME"
  else
    dbname="$1"
  fi

  case "$dbms_prefix" in
    mysql|mysql_)
      cmd="mysqldump"
      adddbconncmd
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd \"$dbname\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump multiple databases
#
# $1 is a string containing the names of the database to dump (each name
#    should be enclosed in \"); if blank, it will be replaced with
#    "DBNAMES", e.g. for running the script in cmds mode
#
# "local" vars: dbnames
# global vars: cmd, dbms_prefix, *_dumpmultoptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpmultcmd () {
  if [ "$1" = "" ]; then
    dbnames="DBNAMES"
  else
    dbnames="$1"
  fi

  case "$dbms_prefix" in
    mysql|mysql_)
      cmd="mysqldump"
      adddbconncmd
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -B \"$dbnames\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump all databases
#
# global vars: cmd, dbms_prefix, *_dumpalloptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpallcmd () {
  case "$dbms_prefix" in
    mysql|mysql_)
      cmd="mysqldump"
      adddbconncmd
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -A"
      ;;
  esac
}

#
# set $cmd to the rsync command to run for the backup
#
# global vars: cmd, rsyncmode, passwordfile, rsync_localport, rsyncdport,
#              rsync_sshport, rsync_sshkey, filterfile, rsyncoptions,
#              rsyncadd, source, dest
#
setrsynccmd () {
  cmd="rsync"
  { [ "$rsyncmode" = "tunnel" ] || [ "$rsyncmode" = "direct" ]; } && \
      cmd="$cmd --password-file=\"$passwordfile\""
  [ "$rsyncmode" = "tunnel" ] && \
      cmd="$cmd --port=\"$rsync_localport\""
  [ "$rsyncmode" = "direct" ] && \
      cmd="$cmd --port=\"$rsyncdport\""
  if [ "$rsyncmode" = "nodaemon" ]; then
    cmd="$cmd -e \"ssh -p \\\"$rsync_sshport\\\""
    [ "$rsync_sshkey" != "" ] && cmd="$cmd -i \\\"$rsync_sshkey\\\""
    cmd="$cmd\""
  fi
  [ "$filterfile" != "" ] && \
      cmd="$cmd -f \"merge $filterfile\""
  cmd="$cmd $rsyncoptions"  # no \" so we can specify multiple options
  cmd="$cmd $rsyncadd"  # no \" so we can specify multiple options
  cmd="$cmd $source"  # no \" so we can specify multiple paths
  cmd="$cmd \"$dest\""
}


#############################################
# core functions: rotation, pruning, zipping
#############################################

#
# rotate numbered files
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number (separated out because the most recent
#     file won't have a separator or a number)
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# filenames can have an optional .gz, .bz, or .bz2 after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, filename, filenum, newnum, newname
#
rotatenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"

  # first pass
  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # this regexp could be a bit more concise, but it would be less portable
    filenum=`echo "$filename" | \
             sed 's/^'"$prefix$sep"'\([0-9][0-9]*\)/\1/'`

    # create the new filename
    #
    # use temporary variables because we'd need quote nesting that
    # can't be done with `` and $() is less portable;
    # also, expr is more portable than $(())
    newnum=`expr "$filenum" + 1`
    newname=`echo "$filename" | \
             sed 's/^\('"$prefix$sep"'\)[0-9][0-9]*/\1'"$newnum"'/'`

    # move the file
    #
    # if we renumber the files without going in descending order,
    # we'll overwrite some, but sorting on the $filenum is tricky;
    # instead, add .new, then rename all of them
    mv "$filename" "$newname.new"
  done

  # remove .new extensions
  for filename in "$prefix$sep"[0-9]*"$suffix"*".new"; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*.new" ]; then
      break
    fi

    # check more precisely and move the file
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.gz\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.bz\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.bz2\.new$" > /dev/null 2>&1; then
      mv "$filename" "`echo "$filename" | sed 's/\.new$//'`"
    else
      continue
    fi
  done

  # handle the most recent file
  for filename in "$prefix$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # move the file
    mv "$filename" "`echo "$filename" | \
              sed 's/^'"$prefix$suffix"'/'"$prefix${sep}1$suffix"'/'`"
  done
}

#
# prune numbered files by number and date
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, or .bz2 after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, numf, daysf, filename, filenum, newnum,
#               newname
#
prunenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # this regexp could be a bit more concise, but it would be less portable
    filenum=`echo "$filename" | \
             sed 's/^'"$prefix$sep"'\([0-9][0-9]*\)/\1/'`

    # check number and delete
    #
    # expr is more portable than $(())
    if [ "$numf" != "0" ] && [ "$filenum" -ge "`expr "$numf" - 1`" ]; then
      # -r for dirs
      rm -rf "$filename"
      continue
    fi

    # delete by date
    if [ "$daysf" != "0" ]; then
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    fi
  done
}

#
# prune dated files by number and date
#
# $1: full path up to the date, not including any trailing separator
# $2: separator before the date
# $3: suffix after the date, including any leading separator
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, or .bz2 after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, numf, daysf, filename, filenum, newnum,
#               newname
#
prunedatefiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

#!!! prune by number

  for filename in "$prefix$sep"*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$sep.*$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep.*$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # delete by date
    if [ "$daysf" != "0" ]; then
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    fi
  done
}

#
# wrapper: prune numbered or dated files by number and date
#
# $1: layout type
#
# $2: full path up to the number/date, not including any trailing separator
# $3: separator before the number/date
# $4: suffix after the number/date, including any leading separator
#     (cannot begin with a number if using a numbered layout)
#
# $5: number of files, 0=unlimited
# $6: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, or .bz2 after $4
#
# also works on directories
#
prunefiles () {
  case "$1" in
    single|singledir|append)
      :  # nothing to do
      ;;
    number|numberdir)
      prunenumfiles "$2" "$3" "$4" "$5" "$6"
      ;;
    date|datedir)
      prunedatefiles "$2" "$3" "$4" "$5" "$6"
      ;;
  esac
}

#
# rotate and prune the backup logs
#
# filenames can have an optional trailing .gz, .bz, or .bz2
#
# global vars: backuplog, backuplog_layout, backuplog_sep, numlogs, dayslogs
#
rotateprunebackuplogs () {
  if [ "$backuplog" = "" ]; then
    logstatus "backup logging is off; not rotating logs"
    return
  fi

  if [ "$backuplog_layout" = "append" ]; then
    logstatus "backup logs are being appended to a single file; not rotating logs"
    return
  fi

  logstatus "rotating logs"

  # rotate
  if [ "$backuplog_layout" = "number" ]; then
    rotatenumfiles "$backuplog" "$backuplog_sep" ""
  fi

  #prune
  prunefiles "$backuplog_layout" "$backuplog" "$backuplog_sep" "" \
             "$numlogs" "$dayslogs"
}


##############################
# core functions: SSH tunnels
##############################

#
# open an SSH tunnel
#
# one tunnel at a time; closesshtunnel() must be run before opening
# another tunnel
#
# "local" vars: waited, sshexit
# global vars: cmd, sshpid, tun_localport, tun_sshtimeout, vars for
#              setsshcmd()
# FDs: 3
#
opensshtunnel () {
  # set $cmd for ssh; see SECURITY NOTE, above, about this
  setsshcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running ssh command: $cmd" all
  echo "running ssh command: $cmd" >&3

  # run the command
  #
  # note & _in the quotes_, so $! contains the correct pid
  eval "$cmd >&3 2>&1 &"
  sshpid="$!"

  # make sure it's actually working;
  # see http://mywiki.wooledge.org/ProcessManagement#Starting_a_.22daemon.22_and_checking_whether_it_started_successfully
  waited=0
  while sleep 1; do
    nc -z localhost "$tun_localport" && break
    if kill -0 "$sshpid"; then
      # expr is more portable than $(())
      waited=`expr "$waited" + 1`
      if [ "$waited" -gt "$tun_sshtimeout" ]; then
        sendalert "could not establish SSH tunnel (timed out); exiting" log
        kill "$sshpid"
        wait "$sshpid"
        do_exit 3 clean
      fi
    else
      wait "$sshpid"
      sshexit="$?"
      sendalert "could not establish SSH tunnel (error code $sshexit); exiting" log
      do_exit 3 clean
    fi
  done

  logstatus "SSH tunnel established"
}

#
# close an SSH tunnel
#
# global vars: sshpid
#
closesshtunnel () {
  kill "$sshpid"
  wait "$sshpid"
  logstatus "SSH tunnel closed"
}


###########################
# core functions: DB dumps
###########################

#
# get the list of all DBs if necessary
#
# global vars: dbms_dbs, dbms_dbdelim, dbms_splitdbs, lockfile, cmd
# tempfiles: $lockfile/alldbs, $lockfile/alldbs.orig
# FDs: 3
#
getdblisting () {
  if { [ "$dbms_dbs" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
     || \
     [ "$dbms_dbs" = "exclude" ]; then
    rm -f "$lockfile/alldbs"  # to prevent noclobber-type issues

    # set $cmd to get DB listing; see SECURITY NOTE, above, about this
    setdblistcmd

    # log the command; only log to syslog if usesyslog="all"
    logstatusquiet "running DB-listing command: $cmd" all
    echo "running DB-listing command: $cmd" >&3

    # run the command
    eval "$cmd" > "$lockfile/alldbs" 2>&3

    # check status
    if [ "$?" != 0 ]; then
      sendalert "could not get the list of databases; exiting" log
      do_exit 4 clean
    else
      logstatus "obtained the list of databases"
    fi

    mv "$lockfile/alldbs" "$lockfile/alldbs.orig"
    # this leaves a delimiter at the end, but it seems to be ignored
    tr '\n' "$dbms_dbdelim" < "$lockfile/alldbs.orig" > "$lockfile/alldbs"
#!!! dangerous chars in db names
  fi
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary
#
# note that for "number"/"numberdir" layouts, the prefix and suffix omit
# the number, because the most recent version is unnumbered
#
# global vars: dumpprefix, dumpsep, dumpsuffix, dbms_layout, dbms_dumpdir,
#              dbms_fileprefix, dbms_subdirprefix, dbms_filedirsep,
#              dbms_filedirdate, dbms_datestring
#
getdumppath () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix=".sql"
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix=".sql"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix="$dbms_filedirsep$dbms_datestring.sql"
      ;;
    singledir)
      mkdir -p "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix=".sql"
      ;;
    numberdir)
      mkdir -p "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix=".sql"
      ;;
    datedir)
      dumpprefix="$dbms_dumpdir/"
      if [ "$dbms_subdirprefix" != "" ]; then
        mkdir -p "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dumpprefix$dbms_subdirprefix$dbms_filedirsep"
        dumpsep="$dbms_filedirsep"
      else
        mkdir -p "$dbms_dumpdir/$dbms_datestring"
        dumpsep=""
      fi
      dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
      dumpsuffix=".sql"
      ;;
  esac
}

#
# run a single DB dump, including file rotation, etc.
#
# see getdumppath() for info about dumpprefix/dumpsep/dumpsuffix
#
# $cmd must be pre-set, including e.g. database names, however
# $1 must also be set to the database name, if dbms_splitdbs="yes"
#
# "local" vars: dbname
# global vars: dumpprefix, dumpsep, dumpsuffix, cmd, dbms_layout,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions
# FDs: 3
#
do_dbdump () {
  dbname="$1"

  # make way for the new dump
  case "$dbms_layout" in
    single|singledir)
      # so we don't have any noclobber-type issues
      rm -f "$dumpprefix$dbname$dumpsuffix"
      ;;
    number|numberdir)
      rotatenumfiles "$dumpprefix$dbname" "$dumpsep" "$dumpsuffix"
      ;;
  esac

  # $cmd must be pre-set for DB dump; see SECURITY NOTE, above, about this

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running dump command: $cmd" all
  echo "running dump command: $cmd" >&3

  # starting timestamp
  echo "dump started `date`" >&3

  # run the command
  eval "$cmd" > "$dumpprefix$dbname$dumpsuffix" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    if [ "$dbname" != "" ]; then
      sendalert "error dumping database \"$dbname\"; exiting" log
    else
      sendalert "error dumping database(s); exiting" log
    fi
    do_exit 6 clean
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped database \"$dbname\""
    else
      logstatus "successfully dumped database(s)"
    fi
  fi

  # ending timestamp
  echo "dump finished `date`" >&3

  # prune and zip
  #
  # prune after the dump to preserve old data as long as possible
  # in case anything goes wrong;
  # zip after pruning so we use less total space during the process
  prunefiles "$dbms_layout" "$dumpprefix$dbname" "$dumpsep" \
       "$dumpsuffix" "$dbms_numfiles" "$dbms_daysfiles"
  if [ "$dbms_zipmode" != "none" ]; then  # gzip or bzip2
    "$dbms_zipmode" $dbms_zipoptions "$dumpprefix$dbname$dumpsuffix"
  fi
}

#
# wrapper around the different modes of DB dumps, e.g. loop on each DB
#
# "local" vars: OLDIFS, dbnames, dbname, exclude
# global vars: dbms_dbs, dbms_dblist, dbms_dbdelim, dbms_splitdbs, lockfile
# tempfiles: $lockfile/alldbs
#
do_dbdumploop () {
  if [ "$dbms_dbs" != "all" ] || [ "$dbms_splitdbs" = "yes" ]; then
    OLDIFS="$IFS"
    IFS="$dbms_dbdelim"
  fi

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbs" in
      all)
        setdbdumpallcmd
        ;;
      include)
        dbnames=""
        for dbname in `echo "$dbms_dblist"`; do
          dbnames="$dbnames \"$dbname\""
        done
        setdbdumpmultcmd "$dbnames"
        ;;
      exclude)
        dbnames=""
        for dbname in `cat "$lockfile/alldbs"`; do
          for exclude in `echo "$dbms_dblist"`; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done
          dbnames="$dbnames \"$dbname\""
        done
        setdbdumpmultcmd "$dbnames"
        ;;
    esac
    do_dbdump
  else  # dbms_splitdbs="yes"
    case "$dbms_dbs" in
      all)
        for dbname in `cat "$lockfile/alldbs"`; do
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
        done
        ;;
      include)
        for dbname in `echo "$dbms_dblist"`; do
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
        done
        ;;
      exclude)
        for dbname in `cat "$lockfile/alldbs"`; do
          for exclude in `echo "$dbms_dblist"`; do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
        done
        ;;
    esac
  fi

  if [ "$dbms_dbs" != "all" ] || [ "$dbms_splitdbs" = "yes" ]; then
    IFS="$OLDIFS"
  fi
}


##########################################
# command line and configuration settings
##########################################

# make sure the script was called sensibly
if [ "$#" -gt 2 ]; then
  usage
  throwerr "Error: invalid number of command-line parameters; exiting."
fi
checklist "mode" "$2" "" "help" "usage" "cmds" "silence" "unsilence" \
          "stop" "disable" "start" "enable" "clearlock" "unlock"

# need the usage message?
if [ "$2" = "help" ] || [ "$2" = "usage" ]; then
  usage
  do_exit 0
fi

# save variables set on the command line
savevars

if [ "$1" = "-" ]; then  # - means no config file
  configfile="-"  # save for later
  # nothing to source
else
  # get config file path
  if [ "$1" = "" ]; then
    configfile="./backup.conf"
  else
    configfile="$1"
  fi

  # . won't work with no directory (unless ./ is in the PATH),
  # the cwd has to be specified explicitly
  if echo "$configfile" | grep -v '/' > /dev/null 2>&1; then
    configfile="./$configfile"
  fi

  # source config file
  checkreadfile "config file \"$configfile\"" "$configfile"
  . "$configfile"
fi

# restore variables set on the command line, overriding the config file
restorevars

# validate the config
checkconf

# debug mode?
if [ "$debugme" = "yes" ]; then
  set -x
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$2" in
  cmds)
    # print the actual tunnel- and backup-related commands that would be run
    for dbms in $dbmslist; do
      switchdbms "$dbms"
      if [ "$dbms_dodump" = "yes" ]; then
        if [ "$dbms_usetunnel" = "yes" ]; then
          switchtunnel "$dbms"
          setsshcmd
          echo "$dbms_prefix ssh command: $cmd"
        fi
        if { [ "$dbms_dbs" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
           || \
           [ "$dbms_dbs" = "exclude" ]; then
          setdblistcmd
          echo "$dbms_prefix DB-listing command: $cmd"
        fi
        if [ "$dbms_splitdbs" = "no" ]; then
          case "$dbms_dbs" in
            all)
              setdbdumpallcmd
              echo "$dbms_prefix dump-all-DBs command: $cmd"
              ;;
            include|exclude)
              setdbdumpmultcmd ""
              echo "$dbms_prefix dump-multiple-DBs command: $cmd"
              ;;
          esac
        else  # dbms_splitdbs="yes"
          setdbdumponecmd ""
          echo "$dbms_prefix dump-one-DB command: $cmd"
        fi
      fi
    done
    if [ "$do_rsync" = "yes" ]; then
      if [ "$rsyncmode" = "tunnel" ]; then
        switchtunnel "rsync"
        setsshcmd
        echo "rsync ssh command: $cmd"
      fi
      setrsynccmd
      echo "rsync command: $cmd"
    fi
    do_exit 0
    ;;
  silence)
    # silence lockfile-exists alerts
    if [ ! -d "$lockfile" ]; then
      echo "lockfile directory doesn't exist, nothing to silence"
      do_exit 1
    else
      # using a file in the lockfile dir means that we automatically
      # get the silencing cleared when the lockfile is removed
      touch "$lockfile/silencealerts"
      echo "lockfile alerts have been silenced"
      quiet="yes"  # don't print to the terminal again
      logconfig  # so we know what the status message means
      logstatus "lockfile alerts have been silenced, lockfile=\"$lockfile\""
      do_exit 0
    fi
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    if [ ! -f "$lockfile/silencealerts" ]; then
      echo "alerts were already unsilenced"
      do_exit 1
    else
      rm -f "$lockfile/silencealerts"
      echo "lockfile alerts have been unsilenced"
      quiet="yes"  # don't print to the terminal again
      logconfig  # so we know what the status message means
      logstatus "lockfile alerts have been unsilenced, lockfile=\"$lockfile\""
      do_exit 0
    fi
    ;;
  stop|disable)
    # disable backups
    if [ -d "$lockfile" ]; then
      echo "lockfile directory exists; backup is probably running"
      echo "disable command will take effect after the current backup finishes"
      echo
    fi
    mkdir "$lockfile" > /dev/null 2>&1  # ignore already-exists errors
    touch "$lockfile/disable"
    echo "backups have been disabled; remember to re-enable them later!"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been disabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  start|enable)
    # re-enable backups
    if [ ! -f "$lockfile/disable" ]; then
      echo "backups are already enabled"
      do_exit 1
    fi
    rm -f "$lockfile/disable"
    echo "backups have been re-enabled"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been re-enabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  clearlock|unlock)
    # remove lockfile dir
    #
    # -e isn't portable; we could check further, but this should suffice
    if [ ! -d "$lockfile" ] && [ ! -f "$lockfile" ]; then
      echo "lockfile appears to have already been removed"
      do_exit 1
    fi
    echo
    echo "WARNING: the lockfile should only be removed if you're sure a backup is not"
    echo "currently running."
    echo "Type 'y' (without the quotes) to continue."
    # it would be nice to have this on the same line as the prompt,
    # but the portability issues aren't worth it for this
    read type_y
    if [ "$type_y" != "y" ]; then
      echo "Exiting."
      do_exit 0
    fi
    echo
    rm -rf "$lockfile"
    echo "lockfile has been removed"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile \"$lockfile\" has been manually removed"
    do_exit 0
    ;;
esac

# log config file, current working directory, and command-line settings
logconfig


################
# status checks
################

if [ "$runevery" != "0" ]; then
  # has it been long enough since the last backup started?
  #
  # if $startedfile exists and is newer than $runevery, exit
  # (-f instead of -e because it's more portable)
  if [ -f "$startedfile" ] && newerthan "$startedfile" "$runevery"; then
    logstatus "backup interval has not expired; exiting"
    do_exit 0
  else
    logstatus "backup interval has expired; continuing"
  fi
else
  logstatus "interval checking has been disabled; continuing"
fi

# did the previous backup finish?
#
# use an atomic command to check and create the lock
# (could also be ln -s, but we might not be able to set the metadata, and
#  it could cause issues with commands that don't manipulate links directly;
#  plus, now we have a tempdir)
if mkdir "$lockfile" > /dev/null 2>&1; then
  # got the lock, clear lock-alert status
  if [ -f "$alertfile" ]; then  # -f is more portable than -e
    sendalert "lockfile created; cancelling previous alert status" log
  fi
  rm -f "$alertfile"  # -f because it usually won't exist
else
  # assume mkdir failed because it already existed;
  # but that could be because we manually disabled backups
  if [ -f "$lockfile/disable" ]; then
    logalert "backups have been manually disabled; exiting"
  else
    logalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi

  # send the initial alert email (no "log", we already logged it)
  #
  # (-f instead of -e because it's more portable)
  if [ ! -f "$alertfile" ]; then
    touch "$alertfile"
    if [ -f "$lockfile/disable" ]; then
      sendalert "backups have been manually disabled; exiting"
    else
      sendalert "could not create lockfile (previous backup still running or failed?); exiting"
    fi
    do_exit 2
  fi

  # but what about subsequent emails?

  # if ifrunning=0, log it but don't send email
  if [ "$ifrunning" = "0" ]; then
    logalert "ifrunning=0; no email sent"
    do_exit 2
  fi

  # if alerts have been silenced, log it but don't send email
  # (and don't bother checking $ifrunning)
  if [ -f "$lockfile/silencealerts" ]; then
    logalert "alerts have been silenced; no email sent"
    do_exit 2
  fi

  # if $alertfile is newer than $ifrunning, log it but don't send email
  if newerthan "$alertfile" "$ifrunning"; then
    logalert "alert interval has not expired; no email sent"
    do_exit 2
  fi

  # send an alert email (no "log", we already logged it)
  touch "$alertfile"
  if [ -f "$lockfile/disable" ]; then
    sendalert "backups have been manually disabled; exiting"
  else
    sendalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  do_exit 2
fi


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for backup log filenames
backuplog_filename="$backuplog"
if [ "$backuplog" != "" ] && [ "$backuplog_layout" = "date" ]; then
  if [ "$backuplog_date" != "" ]; then
    backuplog_datestring=`date "$backuplog_date"`
  else
    backuplog_datestring=`date`
  fi
  backuplog_filename="$backuplog_filename$backuplog_sep$backuplog_datestring"
fi

# for DB dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      datestring=`date "$dbms_filedirdate"`
    else
      datestring=`date`
    fi
    eval "`echo $dbms`_datestring=\"$datestring\""
  fi
done


###################
# start backup log
###################

# set up a fifo for logging; this has two benefits:
# 1) we can handle multiple output options in one place
# 2) we can run commands without needing pipelines, so we can get the
#    return values
mkfifo "$lockfile/logfifo"
if [ "$backuplog" != "" ]; then
  # rotate and prune backup logs
  rotateprunebackuplogs

  # note that the most recent backup log should already have been (re)moved
  # by the log rotation, unless backuplog_layout="append", so appending
  # is safe
  #
  # =no vs !=yes because of how we want to default if the setting is bogus
  if [ "$quiet" = "no" ]; then
    tee -a "$backuplog_filename" < "$lockfile/logfifo" &
  else
    cat >> "$backuplog_filename" < "$lockfile/logfifo" &
  fi
else  # no backup log
  if [ "$quiet" = "no" ]; then
    cat < "$lockfile/logfifo" &
  else
    cat >> /dev/null < "$lockfile/logfifo" &
  fi
fi

# create an fd to write to instead of the fifo,
# so it won't be closed after every line;
# see http://mywiki.wooledge.org/BashFAQ/085
exec 3> "$lockfile/logfifo"


################
# begin working
################

# starting notifications/timestamps
logstatus "starting backup"
touch "$startedfile"
echo "backup started `date`" >&3


###########
# DB dumps
###########

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms"
      opensshtunnel
    fi

    # get the list of all DBs if necessary
    getdblisting

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary
    getdumppath

    # do the actual dump(s)
    do_dbdumploop

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

if [ "$do_rsync" = "yes" ]; then
  logstatus "starting rsync backup sequence"

  # open the SSH tunnel if we're going to use one
  if [ "$rsyncmode" = "tunnel" ]; then
    switchtunnel "rsync"
    opensshtunnel
  fi

  # set $cmd for rsync; see SECURITY NOTE, above, about this
  setrsynccmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running rsync command: $cmd" all
  echo "running rsync command: $cmd" >&3

  # starting timestamp
  echo "rsync started `date`" >&3

  # run the command
  eval "$cmd" >&3 2>&1

  # check status
  if [ "$?" != 0 ]; then
    sendalert "warning: rsync finished with errors; please check the log" log
    setexitval 7
  else
    logstatus "rsync completed without errors"
  fi

  # ending timestamp
  echo "rsync finished `date`" >&3

  # close the SSH tunnel
  if [ "$rsyncmode" = "tunnel" ]; then
    closesshtunnel
  fi

  logstatus "rsync backup sequence completed"
fi


###############
# done working
###############

# finishing notifications
logstatus "backup finished"
echo "backup finished `date`" >&3


##################
# stop backup log
##################

# remove the fifo and kill the reader process;
# note that we don't have to worry about doing this if we exit abnormally,
# because exiting will close the fd, and the fifo is in the lockfile dir

exec 3>&-  # close the fd, this should kill the reader
rm -f "$lockfile/logfifo"


###########
# clean up
###########

do_exit 0 clean
