#!/bin/sh

#######################################################################
# Aeolus
# a portable, super-configurable database dump and rsync backup script
# by Daniel Malament
# see license() for license info
#######################################################################

# see usage() and the usage and sample config files for usage notes

# exit values (if there are multiple errors, the first one to occur is
# used):
# 0 = no error (e.g. runevery hasn't expired, or backup was completed
#     without errors)
# 1 = problem with the script invocation, the config file, or a setting
#     (also used in command modes like 'disable' as a generic error value)
# 2 = previous lockfile still exists (possibly because backups were
#     manually disabled)
# 3 = error opening SSH tunnel
# 4 = error getting DB list
# 5 = problem with contents of DB list (e.g. unsafe characters, or delimiter
#     already present)
# 6 = error dumping DB
# 7 = rsync error

# lockfile dir is used for the following files:
# $disable, $silencealerts, $timetemp, $logfifo, $alldbs, $alldbsorig

# modification note: any change to the setting variables (additions,
# deletions, name changes, type changes, etc.) must be reflected in:
# some of switch*() [possibly], applydefaults() [probably], checkconf(),
# the configsettings variable, and the default settings section

# adding a DBMS:
#   add vars to the sample config file, modeling after MySQL (but split up
#     *_dump*options if necessary)
#   add vars to the relevant functions/variables (see above)
#   add to adddbconncmd(), setdblistcmd(), setdbdump*cmd(), needdblist()
#   add to dbmslist
#   add to usage note on portability

# TODO:
# better handling of long errors?
# i18n?
# setup modes?
# emulate mkdir -p?
# pathological cases in getparentdir()?
# squeeze // in parentdir() output?
# strange test problems in checkcreate()?
#
# globbing in dblist?
#
# file locs, install script incl. util checker
# setup notes
#
# better command-line option handling, e.g. wrt "-" for no config file
# do more to protect against leading - in settings?
# quoting for sed, etc.? (incl. eg s||| bcs of /...)
#   tr sed grep find expr awk
# check for file/dir prefix ending in /?
#
# skip lock tables for information_schema
# what if re-run?
# if change from ol to no ol
# stop on errors?
# dblist in file
# create clean conf


############
# debugging
############

#
# turn on debugging
#
do_debug () {
  set -vx
}

# unlike the other settings, we use the value of debugme even before we
# check the config file or validate anything, so we can debug those bits
# (also, none of the other settings would do anything before then, anyway)
#
# however, this only applies if debugging is turned on on the command line;
# see also below
if [ "$debugme" = "yes" ]; then
  do_debug
fi


######################
# hardcoded variables
######################

# for all invocations, regardless of config settings

# name of the script, as reported by usage()
# change this if you rename the script file
scriptname="aeolus"

# default path to the config file, if one isn't specified
# change aeolus.usage if you change this
defaultconfigfile="/etc/aeolus/aeolus.conf"

# names of all config file settings
configsettings="
  usepath
  useumask
  timecomptype
  filecomptype
  debugme
  runevery
  startedfile
  ifrunning
  lockfile
  suppressemail
  mailto
  subject
  alertfile
  outputlog
  outputlog_layout
  outputlog_sep
  outputlog_date
  numlogs
  dayslogs
  usesyslog
  syslogstat
  syslogerr
  syslogtag
  quiet
  statuslog
  rsync_sshuser
  rsync_sshhost
  rsync_sshkey
  rsync_sshport
  rsync_localport
  rsync_remoteport
  rsync_sshoptions
  rsync_sshtimeout
  do_rsync
  rsync_mode
  rsync_source
  rsync_dest
  rsync_port
  rsync_pwfile
  rsync_filterfile
  rsync_options
  rsync_add
  mysql_dodump
  mysql_usetunnel
  mysql_sshuser
  mysql_sshhost
  mysql_sshkey
  mysql_sshport
  mysql_localport
  mysql_remoteport
  mysql_sshoptions
  mysql_sshtimeout
  mysql_user
  mysql_pwfile
  mysql_protocol
  mysql_host
  mysql_port
  mysql_socket
  mysql_dbs
  mysql_dblist
  mysql_dbdelim
  mysql_splitdbs
  mysql_clientoptions
  mysql_dumpoptions
  mysql_dumpdir
  mysql_layout
  mysql_fileprefix
  mysql_filesuffix
  mysql_subdirprefix
  mysql_filedirsep
  mysql_filedirdate
  mysql_numfiles
  mysql_daysfiles
  mysql_zipmode
  mysql_zipoptions
"

#
# default settings
#
# change comments in sample config file if you change these
#

# default settings: housekeeping
timecomptype_default="find"
filecomptype_default="cmp"
debugme_default="no"

# default settings: checks and logging
runevery_default="1440"  # 24 hours
startedfile_default="/var/run/aeolus/started"
ifrunning_default="120"  # 2 hours
lockfile_default="/var/run/aeolus/lock"
suppressemail_default="no"
if command -v hostname > /dev/null 2>&1; then
  mailto_default="root@$(hostname)"
  subject_default="Aeolus alert on $(hostname)"
else
  mailto_default="root@localhost"
  subject_default="Aeolus alert"
fi
#alertfile_default="$lockfile.alert"  # set it later, after lockfile
outputlog_default="/var/log/aeolus-output.log"  # only if unset
outputlog_layout_default="number"
outputlog_sep_default="."  # only if unset
outputlog_date_default="+%Y%m%d"  # only if unset
numlogs_default="7"
dayslogs_default="0"
usesyslog_default="yes"
quiet_default="no"
statuslog_default="/var/log/aeolus.log"  # only if unset

# default settings: SSH tunnels (all)
rsync_localport_default="8873"
rsync_remoteport_default="873"
mysql_localport_default="4306"
mysql_remoteport_default="3306"
sshtimeout_default="15"  # applies to all SSH tunnels

# default settings: rsync
do_rsync_default="no"
rsync_mode_default="tunnel"
rsync_pwfile_default="/etc/aeolus/rsync.pw"  # only if unset

# default settings: DBMSes (all; see also below)
dbms_dodump_default="no"
dbms_usetunnel_default="no"
dbms_dumpdir_default="."
dbms_layout_default="date"
dbms_filesuffix_default=".sql"  # only if unset
dbms_filedirsep_default="-"  # only if unset
dbms_filedirdate_default="+%Y%m%d"  # only if unset
dbms_numfiles_default="7"
dbms_daysfiles_default="0"
dbms_zipmode_default="gzip"

# default settings: MySQL (see also above)
mysql_pwfile_default="/etc/aeolus/mysql.pw"  # only if unset
mysql_dbs_default="all"
mysql_dbdelim_default="."
mysql_splitdbs_default="no"
mysql_dumpoptions_default="--opt -Q -R -c"  # only if unset
mysql_fileprefix_default="mysqldump"  # only if unset
mysql_subdirprefix_default="mysqldump"  # only if unset

# settings that have no default, and can't be blank
# (but may be ignored, depending on other settings)
#
# *_sshhost
# rsync_source
# rsync_dest
# *_dblist

# supported DBMSes, separated by spaces
# must correspond to the relevant variable prefixes
#
# removing a DBMS from this list will effectively disable it
dbmslist="mysql"

# names of tempfiles stored in the lockfile directory
disable="disable"
silencealerts="silencealerts"
timetemp="timetemp"
logfifo="logfifo"
alldbs="alldbs"
alldbsorig="alldbs.orig"

# a newline character
# see section 8 of http://www.dwheeler.com/essays/filenames-in-shell.html
newline=$(printf '\nX')
newline="${newline%X}"

# a tab character
tab='	'


##############################################
# helper functions: housekeeping and wrappers
##############################################

#
# update an exit value for the script
#
# if the value has already been set, don't change it,
# so that we can return the value corresponding to
# the first error encountered
#
# global vars: exitval
#
exitval="-1"
setexitval () {
  if [ "$exitval" = "-1" ]; then
    exitval="$1"
  fi
}

#
# update exit value (see setexitval()) and exit, possibly doing some cleanup
#
# $1 = exit value (required)
# if $2 = "clean", remove the lockfile, unless the disable semaphore exists
#
# note: we could use a trap to automatically remove the lockfile,
# but we explicitly remove it instead so that its unexpected presence
# serves as notice that something went wrong previously;
# this is also the reason for not using -f
#
# global vars: lockfile, disable, exitval
# tempfiles: disable
#
do_exit () {
  if [ "$2" = "clean" ]; then
    if [ "$sshpid" != "" ]; then
      closesshtunnel
    fi

    if [ ! -f "$lockfile/$disable" ]; then
      rm -r "$lockfile"
    fi
    # otherwise, a disable command must have been run while we were
    # doing this backup; leave the lockfile dir alone, so future backups
    # will be disabled
  fi

  setexitval "$1"
  exit "$exitval"
}

#
# wrapper: compare files
#
# $1, $2: file paths
#
# commands return 0/1/2, so test for success, not failure
#
# global vars: filecomptype
#
filecomp () {
  # don't redirect stderr, so we can see any actual errors
  case "$filecomptype" in
    cmp)
      cmp "$1" "$2" > /dev/null
      ;;
    diff)
      diff "$1" "$2" > /dev/null
      ;;
  esac
}

#
# get the parent directory of a file or dir
#
# this is more portable and more correct than dirname;
# in particular, dirname returns . for any of . ./ .. ../
# which fits the documentation, but doesn't make sense, at least not here
#
# to get the "standard" behavior, make $2 non-null
#
# note: still doesn't always correctly handle paths starting with /
# and containing . or .., e.g. getparentdir /foo/..
#
# "local" vars: parentdir
#
getparentdir () {
  # remove trailing /'s
  parentdir=$(echo "$1" | sed 's|/*$||')

  # are there no /'s left?
  if echo "$parentdir" | grep -v '/' > /dev/null 2>&1; then
    if [ "$parentdir" = "" ]; then
      echo "/"  # it was /, and / is its own parent
      return
    fi
    if [ "$2" = "" ]; then
      if [ "$parentdir" = "." ]; then
        echo ".."
        return
      fi
      if [ "$parentdir" = ".." ]; then
        echo "../.."
        return
      fi
    fi
    echo "."
    return
  fi
  parentdir=$(echo "$parentdir" | sed 's|/*[^/]*$||')
  if [ "$parentdir" = "" ]; then
    echo "/"
    return
  fi
  echo "$parentdir"
}

# tests for getparentdir:
#getparentdir //                   # /
#getparentdir //foo                # /
#getparentdir //foo//              # /
#getparentdir //foo//bar           # //foo
#getparentdir //foo//bar//         # //foo
#getparentdir //foo//bar//baz      # //foo//bar
#getparentdir //foo//bar//baz//    # //foo//bar
#getparentdir .                    # ..
#getparentdir .//                  # ..
#getparentdir . x                  # .
#getparentdir .// x                # .
#getparentdir .//foo               # .
#getparentdir .//foo//             # .
#getparentdir .//foo//bar          # .//foo
#getparentdir .//foo//bar//        # .//foo
#getparentdir .//foo//bar//baz     # .//foo//bar
#getparentdir .//foo//bar//baz//   # .//foo//bar
#getparentdir ..                   # ../..
#getparentdir ..//                 # ../..
#getparentdir .. x                 # .
#getparentdir ..// x               # .
#getparentdir ..//foo              # ..
#getparentdir ..//foo//            # ..
#getparentdir ..//foo//bar         # ..//foo
#getparentdir ..//foo//bar//       # ..//foo
#getparentdir ..//foo//bar//baz    # ..//foo//bar
#getparentdir ..//foo//bar//baz//  # ..//foo//bar
#getparentdir foo                  # .
#getparentdir foo//                # .
#getparentdir foo//bar             # foo
#getparentdir foo//bar//           # foo
#getparentdir foo//bar//baz        # foo//bar
#getparentdir foo//bar//baz//      # foo//bar
#getparentdir foo//bar//baz// x    # foo//bar
#exit

#
# check if the file in $1 is less than $2 minutes old
#
# file must exist; check before calling
#
# factored out for simplicity, but it's also a wrapper to choose between
# different non-portable methods (some of which use $lockfile/$timetemp)
#
# "local" vars: curtime, filetime, timediff, reftime
# global vars: timecomptype, lockfile, timetemp
# tempfiles: timetemp
#
newerthan () {
  case "$timecomptype" in
    find)
      # find returns 0 even if no files are matched
      find "$1" \! -mmin +"$2" | grep "^$1$" > /dev/null 2>&1
      return
      ;;
    date-r)
      curtime=$(date "+%s")
      filetime=$(date -r "$1" "+%s")
      # expr is more portable than $(())
      timediff=$(expr \( "$curtime" - "$filetime" \) / 60)
      [ "$timediff" -lt "$2" ]
      return
      ;;
    date-d)
      reftime=$(date -d "$2 minutes ago" "+%Y%m%d%H%M.%S")
      ;;  # continue after esac
    awk|gawk)
      reftime=$(echo | "$timecomptype" \
          '{print strftime("%Y%m%d%H%M.%S", systime() - ('"$2"' * 60))}')
      ;;  # continue after esac
  esac
  touch -t "$reftime" "$lockfile/$timetemp"
  # find returns 0 even if no files are matched
  find "$1" -newer "$lockfile/$timetemp" | grep "^$1$" > /dev/null 2>&1
}


#######################################
# helper functions: logging and alerts
#######################################

#
# log a message ($1) to the status log
# (depending on $statuslog)
#
# message is preceded by the date and the script's PID
#
# global vars: statuslog
#
logstatlog () {
  if [ "$statuslog" != "" ]; then
    # note: use quotes to preserve spacing, including in the output of date
    echo "$(date) [$$]: $1" >> "$statuslog"
  fi
}

#
# log a message ($1) to stdout and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprint () {
  # use "$1" to preserve spacing

  if [ "$quiet" = "no" ]; then  # default to yes
    echo "$1"
  fi

  logstatlog "$1"
}

#
# log a message ($1) to stderr and/or the status log
# (depending on $quiet and $statuslog)
#
# global vars: quiet
#
logprinterr () {
  # use "$1" to preserve spacing

  if [ "$quiet" = "no" ]; then  # default to yes
    echo "$1" 1>&2
  fi

  logstatlog "$1"
}

#
# actually send a syslog message; factored out here so logger
# is only called in one place, for maintainability
#
# $1 = message
# $2 = priority (facility.level or numeric)
#      (optional, use '.' if not passing priority but passing a tag)
# $3 = tag (optional)
#
# "local" vars: slcmd, message
#
do_syslog () {
  # see SECURITY NOTE, below, about this code
  slcmd="logger -i"
  [ "$2" != "" ] && [ "$2" != "." ] && slcmd="$slcmd -p \"$2\""
  [ "$3" != "" ] && slcmd="$slcmd -t \"$3\""
  # when we pass in the text of commands, they will probably contain
  # sub-quoted parts, which will cause errors in the eval unless we
  # protect them (because this function contains another evaluation,
  # relative to our other uses of the string)
  message=$(echo $1 | sed 's/\([^\]\)"/\1\\"/g')
  slcmd="$slcmd \"$message\""
  eval "$slcmd"
}

#
# log a status message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogstat, syslogtag
#
logstatus () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogstat" "$syslogtag"
  fi

  logprint "$1"
}

#
# log an alert/error message ($1) to syslog, stdout, and/or the status log
# (depending on $usesyslog, $quiet, and $statuslog)
#
# if $2 is "all", only log to syslog if usesyslog="all" (but printing
# and status logging proceed normally)
#
# global vars: usesyslog, syslogerr, syslogtag
#
logalert () {
  # use "$1" to preserve spacing

  if { [ "$2" != "all" ] && [ "$usesyslog" != "no" ]; } \
     || \
     { [ "$2" = "all" ] && [ "$usesyslog" = "all" ]; }; then
    do_syslog "$1" "$syslogerr" "$syslogtag"
  fi

  logprint "$1"
}

#
# log a status message ($1) to syslog and/or the status log, (depending on
# $usesyslog and $statuslog), but not to stdout, regardless of the setting
# of $quiet
#
# used to avoid duplication when also logging to the output log
#
# if $2 is "all", only log to syslog if usesyslog="all" (but status logging
# proceeds normally)
#
# "local" vars: savequiet
# global vars: quiet
#
logstatusquiet () {
  savequiet="$quiet"
  quiet="yes"
  logstatus "$1" "$2"
  quiet="$savequiet"
}

#
# print the metadata of a file/dir if it exists,
# or "(none)" (used in alert emails)
#
# note: it would be nice to be able provide just timestamps,
# since the rest is much less useful here, and it would be easier
# to read, but it's more or less impossible to to that portably
#
getmetadata () {
  # -e isn't portable, and we're really only dealing with files and dirs
  # (or links to them, which [ handles for us)
  if [ -f "$1" ] || [ -d "$1" ]; then
    ls -ld "$1" 2>&1
  else
    echo "(none)"
  fi
}

#
# send an alert email, including diagnostics,
# and log to syslog/stdout/status log that an email was sent
#
# * message begins with the contents of $1
# * if $2 is "log", also log $1 before the sent notice
#
# note: even if suppressemail="yes", $1 is still logged
# (if settings permit)
#
# must not be called until after printsettings() is defined
#
# "local" vars: cfgfilestring
# global vars: configfile, suppressemail, mailto, subject, lockfile,
#              alertfile, startedfile, (all other config settings via
#              printsettings)
#
sendalert () {
  if [ "$suppressemail" != "yes" ]; then
    if [ "$configfile" = "-" ]; then
      cfgfilestring="(none)"
    else
      cfgfilestring="$configfile"
    fi

    # $(pwd) is more portable than $PWD
    mailx -s "$subject" $mailto <<-EOF
	$1


	-----------------
	Current Settings:
	-----------------

	Config file: $cfgfilestring
	CWD: $(pwd)

	$(printsettings)


	--------------------------------
	Timestamps (and other metadata):
	--------------------------------

	lockfile:
	$(getmetadata "$lockfile")

	alertfile:
	$(getmetadata "$alertfile")

	startedfile:
	$(getmetadata "$startedfile")
	EOF
  fi

  if [ "$2" = "log" ]; then
    logalert "$1"
  fi

  if [ "$suppressemail" != "yes" ]; then
    logalert "alert email sent to $mailto"
  fi
}


####################################################
# helper functions: switch between sets of settings
####################################################

#
# switch SSH tunnel settings
#
# $1 is the prefix for the settings to use (e.g. "rsync" or a member of
# $dbmslist)
#
# global vars: *_sshuser, *_sshhost, *_sshkey, *_sshport, *_localport,
#              *_remoteport, *_sshoptions, *_sshtimeout,
#              tun_prefix,
#              tun_sshuser, tun_sshhost, tun_sshkey, tun_sshport,
#              tun_localport, tun_remoteport, tun_sshoptions,
#              tun_sshtimeout
#
switchtunnel () {
  tun_prefix="$1"
  eval "tun_sshuser=\"$`echo $1`_sshuser\""
  eval "tun_sshhost=\"$`echo $1`_sshhost\""
  eval "tun_sshkey=\"$`echo $1`_sshkey\""
  eval "tun_sshport=\"$`echo $1`_sshport\""
  eval "tun_localport=\"$`echo $1`_localport\""
  eval "tun_remoteport=\"$`echo $1`_remoteport\""
  eval "tun_sshoptions=\"$`echo $1`_sshoptions\""
  eval "tun_sshtimeout=\"$`echo $1`_sshtimeout\""
}

#
# switch DBMS settings
#
# $1 is the prefix for the settings to use (which must be in $dbmslist)
#
# global vars: *_dodump, *_usetunnel, *_user, *_pwfile, *_protocol, *_host
#              *_port, *_socket, *_dbs, *_dblist, *_dbdelim, *_splitdbs,
#              *_clientoptions, *_dumpoptions, *_dumponeoptions,
#              *_dumpmultoptions, *_dumpalloptions, *_dumpdir, *_layout,
#              *_fileprefix, *_subdirprefix, *_filedirsep, *_filedirdate,
#              *_numfiles, *_daysfiles, *_zipmode, *_zipoptions,
#              *_datestring [internal],
#              dbms_prefix,
#              dbms_dodump, dbms_usetunnel, dbms_user, dbms_pwfile,
#              dbms_protocol, dbms_host, dbms_port, dbms_socket, dbms_dbs,
#              dbms_dblist, dbms_dbdelim, dbms_splitdbs, dbms_clientoptions,
#              dbms_dumpoptions, dbms_dumponeoptions, dbms_dumpmultoptions,
#              dbms_dumpalloptions, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_filedirdate, dbms_numfiles,
#              dbms_daysfiles, dbms_zipmode, dbms_zipoptions,
#              dbms_datestring [internal]
#
switchdbms () {
  dbms_prefix="$1"
  eval "dbms_dodump=\"$`echo $1`_dodump\""
  eval "dbms_usetunnel=\"$`echo $1`_usetunnel\""
  eval "dbms_user=\"$`echo $1`_user\""
  eval "dbms_pwfile=\"$`echo $1`_pwfile\""
  eval "dbms_protocol=\"$`echo $1`_protocol\""
  eval "dbms_host=\"$`echo $1`_host\""
  eval "dbms_port=\"$`echo $1`_port\""
  eval "dbms_socket=\"$`echo $1`_socket\""
  eval "dbms_dbs=\"$`echo $1`_dbs\""
  eval "dbms_dblist=\"$`echo $1`_dblist\""
  eval "dbms_dbdelim=\"$`echo $1`_dbdelim\""
  eval "dbms_splitdbs=\"$`echo $1`_splitdbs\""
  eval "dbms_clientoptions=\"$`echo $1`_clientoptions\""
  eval "dbms_dumpoptions=\"$`echo $1`_dumpoptions\""
  eval "dbms_dumponeoptions=\"$`echo $1`_dumponeoptions\""
  eval "dbms_dumpmultoptions=\"$`echo $1`_dumpmultoptions\""
  eval "dbms_dumpalloptions=\"$`echo $1`_dumpalloptions\""
  eval "dbms_dumpdir=\"$`echo $1`_dumpdir\""
  eval "dbms_layout=\"$`echo $1`_layout\""
  eval "dbms_fileprefix=\"$`echo $1`_fileprefix\""
  eval "dbms_filesuffix=\"$`echo $1`_filesuffix\""
  eval "dbms_subdirprefix=\"$`echo $1`_subdirprefix\""
  eval "dbms_filedirsep=\"$`echo $1`_filedirsep\""
  eval "dbms_filedirdate=\"$`echo $1`_filedirdate\""
  eval "dbms_numfiles=\"$`echo $1`_numfiles\""
  eval "dbms_daysfiles=\"$`echo $1`_daysfiles\""
  eval "dbms_zipmode=\"$`echo $1`_zipmode\""
  eval "dbms_zipoptions=\"$`echo $1`_zipoptions\""
  # internal, not from config
  eval "dbms_datestring=\"$`echo $1`_datestring\""
}


################################################
# helper functions: startup and config settings
################################################

#
# print a usage message to stderr
#
# NOTE: when updating this, update the note in the usage file as well
#
# global vars: scriptname, defaultconfigfile
#
usage () {
  # not necessarily reliable/consistent, switched to static global
  # (see hardcoded vars)
  #scriptname=$(echo "$0" | sed 's|^.*/||')

  cat <<EOF 1>&2

Usage: [setting="value"] $scriptname /path/to/config/file [mode]

Multiple settings can be added to the command line, separated by spaces.

If the config file path is omitted, "$defaultconfigfile" will be tried.

If the mode is "help" or "usage", this message is printed.

If the mode is "license", a license message is printed.

If the mode is "cmds", the ssh, DBMS, and rsync commands that would be run
are printed, but nothing else is done.

If the mode is "silence", then alerts about the lockfile existing will be
silenced until either they are unsilenced, or the lockfile is no longer
present.

If the mode is "unsilence", then alerts about the lockfile existing will be
re-enabled.

If the mode is "stop" or "disable", then backups will be disabled until
"start" or "enable" is used.

If the mode is "start" or "enable", then backups will be re-enabled.

If the mode is "clearlock" or "unlock", then the lockfile will be removed.
Only use this if you're sure a backup isn't currently running!

EOF
}


#
# print a license message to stderr
#
license () {
  cat <<EOF 1>&2

Copyright 2011 Daniel Malament.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

  1. Redistributions of source code must retain the above copyright
     notice, this list of conditions and the following disclaimer.

  2. Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.

EOF
}

#
# save setting variables supplied on the command line (even if they're set
# to null)
#
# "local" vars: setting, cmdtemp
# global vars: varssaved, configsettings, all config settings, cl_* for all
#              config settings
#
savevars () {
  # so we know if anything was saved, when we want to use logconfig
  varssaved="no"

  for setting in $configsettings; do
    cmdtemp="[ \"\${$setting+X}\" = \"X\" ] &&"
    cmdtemp="$cmdtemp cl_$setting=\"\$$setting\" && varssaved=\"yes\""
    eval "$cmdtemp"  # doesn't work if combined into one line
  done
}

#
# log config file, current working directory, and setting variables supplied
# on the command line
#
# must be run after savevars()
#
# "local" vars: setting, cmdtemp
# global vars: configfile, varssaved, configsettings, all config settings,
#              cl_* for all config settings
#
logconfig () {
  # $(pwd) is more portable than $PWD
  if [ "$configfile" = "-" ]; then
    logstatus "no config file, cwd: \"$(pwd)\""
  else
    logstatus "using config file: \"$configfile\", cwd: \"$(pwd)\""
  fi

  if [ "$varssaved" = "yes" ]; then
    logstatus "settings passed on the command line:"
    for setting in $configsettings; do
      cmdtemp="[ \"\${cl_$setting+X}\" = \"X\" ] &&"
      cmdtemp="$cmdtemp logstatus \"$setting='\$cl_$setting'\""
      eval "$cmdtemp"  # doesn't work if combined into one line
    done
  else
    logstatus "no settings passed on the command line"
  fi
}

#
# restore setting variables supplied on the command line, overriding the
# config file
#
# "local" vars: setting, cmdtemp
# global vars: configsettings, all config settings, cl_* for all config
#              settings
#
restorevars () {
  for setting in $configsettings; do
    cmdtemp="[ \"\${cl_$setting+X}\" = \"X\" ] &&"
    cmdtemp="$cmdtemp $setting=\"\$cl_$setting\""
    eval "$cmdtemp"  # doesn't work if combined into one line
  done
}

#
# print all of the current config settings (used in alert emails)
#
# will print settings with '""' and "\"\"" sub-quoting correctly,
# but not "''" (prints as '''')
#
# "local" vars: setting
# global vars: configsettings, all config settings
#
printsettings () {
  for setting in $configsettings; do
    eval echo "$setting=\"'$`echo $setting`'\""
  done
}

#
# print a startup error to stderr and exit
#
# $1 = message
#
throwerr () {
  cat <<-EOF 1>&2

	$1

	EOF
  do_exit 1
}

#
# print a bad-setting error to stderr and exit
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
settingerr () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  throwerr "Error: invalid setting for $vname (\"$vval\"); exiting."
}

#
# validate a setting that can't be blank
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checknoblank () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  if [ "$vval" = "" ]; then
    throwerr "Error: $vname is unset or blank; exiting."
  fi
}

#
# validate two settings that can't both be blank
#
# $1 = first variable name
# $2 = second variable name
#
# "local" vars: vname1, vval1, vname2, vval2
# global vars: contents of $1, contents of $2
#
checknotbothblank () {
  vname1="$1"
  eval "vval1=\"$`echo $vname1`\""
  vname2="$2"
  eval "vval2=\"$`echo $vname2`\""

  if [ "$vval1" = "" ] && [ "$vval2" = "" ]; then
    throwerr "Error: $vname1 and $vname2 cannot both be blank; exiting."
  fi
}

#
# validate a setting that must be exactly one character
# (which can be anything except NUL)
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkonechar () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  checknoblank "$vname"

  if [ "$(expr length "$vval")" != 1 ]; then  # not portable
#!!!
  #if [ "$(echo | awk '{print length("'"$vval"'")}')" != 1 ]; then
    throwerr "Error: $vname is longer than one character; exiting."
  fi
}

#
# validate a numeric setting (only digits 0-9 allowed, no - or .)
#
# $1 = variable name
# $2 = minimum (optional, use "" if using $3 but not $2)
# $3 = maximum (optional)
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checknum () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  # use extra [0-9] to avoid having to use egrep
  if echo "$vval" | grep '^[0-9][0-9]*$' > /dev/null 2>&1; then
    if [ "$2" != "" ] && [ "$vval" -lt "$2" ]; then
      settingerr "$vname"
    fi
    if [ "$3" != "" ] && [ "$vval" -gt "$3" ]; then
      settingerr "$vname"
    fi
  else
    settingerr "$vname"
  fi
}

#
# validate a directory setting, for directories in which we need to create
# and/or rotate files:
# setting must not be blank, and directory must exist, be a directory or a
# symlink to a one, and have full permissions (r/w/x; r for rotation,
# wx for creating files)
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkrwxdir () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  checknoblank "$vname"

  # [ dereferences symlinks for us
  if [ ! -d "$vval" ]; then
    throwerr "Error: $vname is not a directory or a symlink to one; exiting."
  fi
  if [ ! -r "$vval" ]; then
    throwerr "Error: $vname is not readable; exiting."
  fi
  if [ ! -w "$vval" ]; then
    throwerr "Error: $vname is not writable; exiting."
  fi
  if [ ! -x "$vval" ]; then
    throwerr "Error: $vname is not searchable; exiting."
  fi
}

#
# validate a file/dir setting, for files/directories we're going to be
# touching, writing to, creating, and/or rotating (but not reading):
# 1) the setting may not be blank
# 2) if the file/dir exists, then:
#    2a) if $2="file", it must be a file or a symlink to one,
#        and it must be writable
#    2b) if $2="dir", it must be a directory or a symlink to one,
#        and it must be writable and searchable (wx; for creating files)
# 3) regardless, the parent directory must exist, be a directory or a
#    symlink to one, and be writable and searchable (wx); if $3 is not
#    null, it must also be readable (for rotation)
#
# $1 = variable name
# $2 = "file" or "dir"
# $3 = if not null (e.g. "rotate"), parent directory must be readable
#
# note: some tests (e.g. -x) seem to silently succeed in some cases in
# which the file/dir isn't readable, even if they should fail, but I'm
# not going to add extra restrictions just for that
#
# "local" vars: vname, vval, parentdir
# global vars: contents of $1
#
checkcreate () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  # condition 1
  checknoblank "$vname"

  # condition 2
  #
  # note: [ -e ] isn't portable, so try ls, even though it's probably not
  # robust enough to be a general solution...
  if ls "$vval" > /dev/null 2>&1; then
    case "$2" in
      file)
        # [ dereferences symlinks for us
        if [ ! -f "$vval" ]; then
          throwerr "Error: $vname is not a file or a symlink to one; exiting."
        fi
        if [ ! -w "$vval" ]; then
          throwerr "Error: $vname is not writable; exiting."
        fi
        ;;
      dir)
        # [ dereferences symlinks for us
        if [ ! -d "$vval" ]; then
          throwerr "Error: $vname is not a directory or a symlink to one; exiting."
        fi
        if [ ! -w "$vval" ]; then
          throwerr "Error: $vname is not writable; exiting."
        fi
        if [ ! -x "$vval" ]; then
          throwerr "Error: $vname is not searchable; exiting."
        fi
        ;;
      *)
        throwerr "Internal Error: illegal file-type value (\"$2\") in checkcreate(); exiting."
        ;;
    esac
  fi

  # condition 3
  parentdir=$(getparentdir "$vval")
  # [ dereferences symlinks for us
  if [ ! -d "$parentdir" ]; then
    # ... or a non-directory, but this is more concise
    throwerr "Error: $vname is in a non-existent directory (\"$parentdir\"); exiting."
  fi
  if [ ! -w "$parentdir" ]; then
    throwerr "Error: $vname is in a non-writable directory; exiting."
  fi
  if [ ! -x "$parentdir" ]; then
    throwerr "Error: $vname is in a non-searchable directory; exiting."
  fi
  if [ "$3" != "" ] && [ ! -r "$parentdir" ]; then
    throwerr "Error: $vname is in a non-readable directory; exiting."
  fi
}

#
# validate a file setting, for files we just need to be able to read:
# setting must not be blank, and file must exist, be a file or a symlink
# to one, and be readable
#
# $1 = variable name ("configfile" treated specially)
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkreadfile () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  # blank?
  checknoblank "$vname"

  # from here on, we will only be using $vname for printing purposes,
  # so we can doctor it
  if [ "$vname" = "configfile" ]; then
    vname="config file \"$vval\""
  fi

  # not a file or symlink to one?
  # ([ dereferences symlinks for us)
  if [ ! -f "$vval" ]; then
    throwerr "Error: $vname does not exist, or is not a file or a symlink to one; exiting."
  fi

  # not readable?
  if [ ! -r "$vval" ]; then
    throwerr "Error: $vname is not readable; exiting."
  fi
}

#
# validate a file setting, for files we need to be able to read and write,
# but not create or rotate:
# setting must not be blank, and file must exist, be a file or a
# symlink to a file, and be readable and writable
#
# $1 = variable name
#
# "local" vars: vname, vval
# global vars: contents of $1
#
checkrwfile () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""

  checkreadfile "$vname"

  # not writable?
  if [ ! -w "$vval" ]; then
    throwerr "Error: $vname is not writable; exiting."
  fi
}

#
# validate a setting that can be one of a list of possiblities
#
# $1 = variable name ("mode" treated specially)
# other args = list of possiblities (can include "")
#
# "local" vars: vname, vval, poss
# global vars: contents of $1
#
checklist () {
  vname="$1"
  eval "vval=\"$`echo $vname`\""
  shift

  # implied $@ isn't supported by ksh
  for poss in ${1+"$@"}; do
    if [ "$vval" = "$poss" ]; then
      return 0
    fi
  done

  if [ "$vname" = "mode" ]; then
    usage
    throwerr "Error: invalid mode supplied on the command line; exiting."
  else
    settingerr "$vname"
  fi
}

#
# apply default settings where applicable
#
# global vars: most config settings, and their _defaults
#
applydefaults () {
  # housekeeping
  [ "$timecomptype" = "" ] && timecomptype="$timecomptype_default"
  [ "$filecomptype" = "" ] && filecomptype="$filecomptype_default"
  [ "$debugme" = "" ] && debugme="$debugme_default"

  # checks and logging
  [ "$runevery" = "" ] && runevery="$runevery_default"
  [ "$startedfile" = "" ] && startedfile="$startedfile_default"
  [ "$ifrunning" = "" ] && ifrunning="$ifrunning_default"
  [ "$lockfile" = "" ] && lockfile="$lockfile_default"
  [ "$suppressemail" = "" ] && suppressemail="$suppressemail_default"
  [ "$mailto" = "" ] && mailto="$mailto_default"
  [ "$subject" = "" ] && subject="$subject_default"
  [ "$alertfile" = "" ] && alertfile="$lockfile.alert"  # late-binding default
  [ "${outputlog+X}" = "" ] && outputlog="$outputlog_default"
  [ "$outputlog_layout" = "" ] && outputlog_layout="$outputlog_layout_default"
  [ "${outputlog_sep+X}" = "" ] && outputlog_sep="$outputlog_sep_default"
  [ "${outputlog_date+X}" = "" ] && outputlog_date="$outputlog_date_default"
  [ "$numlogs" = "" ] && numlogs="$numlogs_default"
  [ "$dayslogs" = "" ] && dayslogs="$dayslogs_default"
  [ "$usesyslog" = "" ] && usesyslog="$usesyslog_default"
  [ "$quiet" = "" ] && quiet="$quiet_default"
  [ "${statuslog+X}" = "" ] && statuslog="$statuslog_default"

  # SSH tunnels (individual and global defaults)
  [ "$rsync_localport" = "" ] && rsync_localport="$rsync_localport_default"
  [ "$rsync_remoteport" = "" ] && rsync_remoteport="$rsync_remoteport_default"
  [ "$mysql_localport" = "" ] && mysql_localport="$mysql_localport_default"
  [ "$mysql_remoteport" = "" ] && mysql_remoteport="$mysql_remoteport_default"
  # global
  [ "$rsync_sshtimeout" = "" ] && rsync_sshtimeout="$sshtimeout_default"
  [ "$mysql_sshtimeout" = "" ] && mysql_sshtimeout="$sshtimeout_default"

  # rsync
  [ "$do_rsync" = "" ] && do_rsync="$do_rsync_default"
  [ "$rsync_mode" = "" ] && rsync_mode="$rsync_mode_default"
  [ "${rsync_pwfile+X}" = "" ] && rsync_pwfile="$rsync_pwfile_default"

  # DBMSes (global defaults; see also below)
  [ "$mysql_dodump" = "" ] && mysql_dodump="$dbms_dodump_default"
  [ "$mysql_usetunnel" = "" ] && mysql_usetunnel="$dbms_usetunnel_default"
  [ "$mysql_dumpdir" = "" ] && mysql_dumpdir="$dbms_dumpdir_default"
  [ "$mysql_layout" = "" ] && mysql_layout="$dbms_layout_default"
  [ "${mysql_filesuffix+X}" = "" ] && mysql_filesuffix="$dbms_filesuffix_default"
  [ "${mysql_filedirsep+X}" = "" ] && mysql_filedirsep="$dbms_filedirsep_default"
  [ "${mysql_filedirdate+X}" = "" ] && mysql_filedirdate="$dbms_filedirdate_default"
  [ "$mysql_numfiles" = "" ] && mysql_numfiles="$dbms_numfiles_default"
  [ "$mysql_daysfiles" = "" ] && mysql_daysfiles="$dbms_daysfiles_default"
  [ "$mysql_zipmode" = "" ] && mysql_zipmode="$dbms_zipmode_default"

  # DBMSes (individual defaults; see also above)
  [ "${mysql_pwfile+X}" = "" ] && mysql_pwfile="$mysql_pwfile_default"
  [ "$mysql_dbs" = "" ] && mysql_dbs="$mysql_dbs_default"
  [ "$mysql_dbdelim" = "" ] && mysql_dbdelim="$mysql_dbdelim_default"
  [ "$mysql_splitdbs" = "" ] && mysql_splitdbs="$mysql_splitdbs_default"
  [ "${mysql_dumpoptions+X}" = "" ] && mysql_dumpoptions="$mysql_dumpoptions_default"
  [ "${mysql_fileprefix+X}" = "" ] && mysql_fileprefix="$mysql_fileprefix_default"
  [ "${mysql_subdirprefix+X}" = "" ] && mysql_subdirprefix="$mysql_subdirprefix_default"
}

#
# validate the configuration settings
#
# global vars: all config settings except usepath, useumask, outputlog_sep,
#              outputlog_date, syslogtag, *_sshuser, *_sshoptions,
#              rsync_options, rsync_add,
#              [DBMS]: *_user, *_protocol, *_clientoptions, *_dumpoptions,
#              *_dumponeoptions, *_dumpmultoptions, *_dumpalloptions,
#              *_filedirsep, *_filedirdate, *_zipoptions
#
checkconf () {
  # housekeeping
  #
  # note: umask could be symbolic in some shells, not going to try to
  # parse it
  checklist "timecomptype" "find" "date-r" "date-d" "awk" "gawk"
  checklist "filecomptype" "cmp" "diff"
  checklist "debugme" "yes" "no"

  # checks and logging
  checknum "runevery"
  checkcreate "startedfile" "file"
  checknum "ifrunning"
  checkcreate "lockfile" "dir"
  checklist "suppressemail" "yes" "no"
  if [ "$suppressemail" = "no" ]; then
    checknoblank "mailto"
    checknoblank "subject"
  fi
  checkcreate "alertfile" "file"
  if [ "$outputlog" != "" ]; then
    checkcreate "outputlog" "file" "rotate"
    checklist "outputlog_layout" "append" "number" "date"
    if [ "$outputlog_layout" != "append" ]; then
      checknum "numlogs"
      checknum "dayslogs"
    fi
  fi
  checklist "usesyslog" "all" "yes" "no"
  if [ "$usesyslog" != "no" ]; then
    [ "$syslogstat" = "" ] && syslogstat="."  # see do_syslog()
    [ "$syslogerr" = "" ] && syslogerr="."  # see do_syslog()
  fi
  checklist "quiet" "yes" "no"
  [ "$statuslog" != "" ] && checkcreate "statuslog" "file"

  # rsync, including SSH tunnel
  checklist "do_rsync" "yes" "no"
  if [ "$do_rsync" = "yes" ]; then
    checklist "rsync_mode" "tunnel" "direct" "nodaemon" "local"
    if [ "$rsync_mode" = "tunnel" ]; then
      checknoblank "rsync_sshhost"
      checknum "rsync_localport" 1 65535
      checknum "rsync_remoteport" 1 65535
      checknum "rsync_sshtimeout" 1
    fi
    if [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "nodaemon" ]; then
      [ "$rsync_sshkey" != "" ] && checkreadfile "rsync_sshkey"
      [ "$rsync_sshport" != "" ] && checknum "rsync_sshport" 1 65535
    fi
    checknoblank "rsync_source"
    checknoblank "rsync_dest"
    if [ "$rsync_mode" = "direct" ]; then
      [ "$rsync_port" != "" ] && checknum "rsync_port" 1 65535
    fi
    { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
        [ "$rsync_pwfile" != "" ] && checkreadfile "rsync_pwfile"
    [ "$rsync_filterfile" != "" ] && checkreadfile "rsync_filterfile"
  fi

  # DBMS dumps, including SSH tunnels
  for dbms in $dbmslist; do
    switchdbms "$dbms"
    switchtunnel "$dbms"

    # note: lines like
    #   checklist "${dbms}_dodump" "yes" "no"
    # are passing, e.g., "mysql_dodump",
    # but lines like
    #   if [ "$dbms_dodump" = "yes" ]; then
    # are referencing the dbms_dodump variable...

    checklist "${dbms}_dodump" "yes" "no"
    if [ "$dbms_dodump" = "yes" ]; then
      checklist "${dbms}_usetunnel" "yes" "no"
      if [ "$dbms_usetunnel" = "yes" ]; then
        checknoblank "${dbms}_sshhost"
        [ "$tun_sshkey" != "" ] && checkreadfile "${dbms}_sshkey"
        [ "$tun_sshport" != "" ] && checknum "${dbms}_sshport" 1 65535
        checknum "${dbms}_localport" 1 65535
        checknum "${dbms}_remoteport" 1 65535
        checknum "${dbms}_sshtimeout" 1
        # ignore these
        eval "`echo $dbms`_host=\"\""
        eval "`echo $dbms`_port=\"\""
        eval "`echo $dbms`_socket=\"\""
        # also change the dbms_* variables, for later tests
        dbms_host=""
        dbms_port=""
        dbms_socket=""
       else
        if [ "$dbms_host" != "" ]; then  # nothing to check, but...
          # ignore socket
          eval "`echo $dbms`_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        if [ "$dbms_port" != "" ]; then
          checknum "${dbms}_port" 1 65535
          # ignore socket
          eval "`echo $dbms`_socket=\"\""
          dbms_socket=""  # for later tests
        fi
        [ "$dbms_socket" != "" ] && checkrwfile "${dbms}_socket"
      fi  # if [ "$dbms_usetunnel" = "yes" ]
      [ "$dbms_pwfile" != "" ] && checkreadfile "${dbms}_pwfile"
      checklist "${dbms}_dbs" "all" "include" "exclude"
      [ "$dbms_dbs" != "all" ] && checknoblank "${dbms}_dblist"
      checkonechar "${dbms}_dbdelim"
      checklist "${dbms}_splitdbs" "yes" "no"
      checkrwxdir "${dbms}_dumpdir"
      checklist "${dbms}_layout" "single" "number" "date" "singledir" \
                "numberdir" "datedir"
      [ "$dbms_splitdbs" = "no" ] && [ "$dbms_layout" != "date" ] && \
          checknotbothblank "${dbms}_fileprefix" "${dbms}_filesuffix"
      { [ "$dbms_layout" = "singledir" ] || [ "$dbms_layout" = "numberdir" ]; } && \
          checknoblank "${dbms}_subdirprefix"
      if [ "$dbms_layout" != "single" ] && [ "$dbms_layout" != "singledir" ]; then
        checknum "${dbms}_numfiles"
        checknum "${dbms}_daysfiles"
      fi
      checklist "${dbms}_zipmode" "none" "gzip" "bzip2" "lzip"
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist
}


####################################
# core functions: assemble commands
####################################

#
# these are factored out here so the "cmds" argument to the script
# doesn't make things complicated and unreadable;
# when running for real, they are used to set $cmd, which is then eval'ed
#

#
# SECURITY NOTE: this is the only portable way I've found to be able to
# pass optional arguments that can contain spaces, and get everything
# to work as expected; I've done some tests, and I'm pretty sure using
# eval like this, with early evaluation and as much quoting as possible,
# is at worst no more dangerous than passing user-supplied filenames
# and arguments is in the first place, but if anyone reading this has
# a better idea, I'm listening
#
# also, this approach doesn't handle some combinations of e.g. embedded
# quotes well, but it's probably good enough for this script, anyway
#

# see also do_syslog(), above

#
# set $cmd to the ssh command to run for a tunnel
#
# global vars: cmd, tun_localport, tun_remoteport, tun_sshport, tun_sshkey,
#              tun_sshoptions, tun_sshuser, tun_sshhost
#
setsshcmd () {
  cmd="ssh -L \"${tun_localport}:localhost:${tun_remoteport}\" -N"
  [ "$tun_sshport" != "" ] && cmd="$cmd -p \"$tun_sshport\""
  [ "$tun_sshkey" != "" ] && cmd="$cmd -i \"$tun_sshkey\""
  # no \" so we can specify multiple options
  [ "$tun_sshoptions" != "" ] && cmd="$cmd $tun_sshoptions"
  [ "$tun_sshuser" != "" ] && cmd="$cmd -l \"$tun_sshuser\""
  cmd="$cmd \"$tun_sshhost\""
}

#
# add database connection options to $cmd
#
# global vars: cmd, dbms_prefix, *_user, *_pwfile, *_usetunnel, *_localport,
#              *_protocol, *_host, *_port, *_socket
#
adddbconncmd () {
  case "$dbms_prefix" in
    mysql)
      # --defaults-extra-file must be the first option
      [ "$mysql_pwfile" != "" ] && \
          cmd="$cmd \"--defaults-extra-file=$mysql_pwfile\""
      [ "$mysql_user" != "" ] && cmd="$cmd -u \"$mysql_user\""
      if [ "$mysql_usetunnel" = "yes" ]; then
        cmd="$cmd -h localhost"
        cmd="$cmd -P \"$mysql_localport\""
      else
        [ "$mysql_protocol" != "" ] && cmd="$cmd \"--protocol=$mysql_protocol\""
        [ "$mysql_host" != "" ] && cmd="$cmd -h \"$mysql_host\""
        [ "$mysql_port" != "" ] && cmd="$cmd -P \"$mysql_port\""
        [ "$mysql_socket" != "" ] && cmd="$cmd -S \"$mysql_socket\""
      fi
      ;;
  esac
}

#
# set $cmd to the command to run to get a list of databases
#
# global vars: cmd, dbms_prefix, *_clientoptions, vars for adddbconncmd()
#
setdblistcmd () {
  case "$dbms_prefix" in
    mysql)
      cmd="mysql"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_clientoptions" != "" ] && cmd="$cmd $mysql_clientoptions"
      cmd="$cmd -BN -e \"SHOW DATABASES;\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump a single database
#
# $1 is the name of the database to dump; if blank, it will be replaced
#    with "DBNAME", e.g. for running the script in cmds mode
#
# "local" vars: dbname
# global vars: cmd, dbms_prefix, *_dumponeoptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumponecmd () {
  if [ "$1" = "" ]; then
    dbname="DBNAME"
  else
    dbname="$1"
  fi

  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd \"$dbname\""
      ;;
  esac
}

#
# set $cmd to the command to run to dump multiple databases
#
# $1 is a string containing the names of the databases to dump (names
#    containing spaces must be sub-quoted (e.g. '... "foo bar" ...' or
#    "... \"foo bar\" ...")); if blank, it will be replaced with
#    "DBNAMES", e.g. for running the script in cmds mode
#
# "local" vars: dbnames
# global vars: cmd, dbms_prefix, *_dumpmultoptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpmultcmd () {
  if [ "$1" = "" ]; then
    dbnames="DBNAMES"
  else
    dbnames="$1"
  fi

  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -B $dbnames"
      ;;
  esac
}

#
# set $cmd to the command to run to dump all databases
#
# global vars: cmd, dbms_prefix, *_dumpalloptions (or e.g. *_dumpoptions
#              for DBMSes that only need one set of options), vars for
#              adddbconncmd()
#
setdbdumpallcmd () {
  case "$dbms_prefix" in
    mysql)
      cmd="mysqldump"
      adddbconncmd
      # no \" so we can specify multiple options
      [ "$mysql_dumpoptions" != "" ] && cmd="$cmd $mysql_dumpoptions"
      cmd="$cmd -A"
      ;;
  esac
}

#
# set $cmd to the rsync command to run for the backup
#
# global vars: cmd, rsync_mode, rsync_pwfile, rsync_localport, rsync_port,
#              rsync_sshport, rsync_sshkey, rsync_sshoptions,
#              rsync_filterfile, rsync_options, rsync_add, rsync_source,
#              rsync_dest
#
setrsynccmd () {
  cmd="rsync"
  { [ "$rsync_mode" = "tunnel" ] || [ "$rsync_mode" = "direct" ]; } && \
      [ "$rsync_pwfile" != "" ] && \
      cmd="$cmd \"--password-file=$rsync_pwfile\""
  [ "$rsync_mode" = "tunnel" ] && \
      cmd="$cmd \"--port=$rsync_localport\""
  [ "$rsync_mode" = "direct" ] && \
      [ "$rsync_port" != "" ] && cmd="$cmd \"--port=$rsync_port\""
  if [ "$rsync_mode" = "nodaemon" ]; then
    cmd="$cmd -e \"ssh"
    [ "$rsync_sshport" != "" ] && cmd="$cmd -p \\\"$rsync_sshport\\\""
    [ "$rsync_sshkey" != "" ] && cmd="$cmd -i \\\"$rsync_sshkey\\\""
    # no \" so we can specify multiple options
    [ "$rsync_sshoptions" != "" ] && cmd="$cmd $rsync_sshoptions"
    cmd="$cmd\""
  fi
  [ "$rsync_filterfile" != "" ] && cmd="$cmd -f \"merge $rsync_filterfile\""
  # no \" so we can specify multiple options
  [ "$rsync_options" != "" ] && cmd="$cmd $rsync_options"
  # no \" so we can specify multiple options
  [ "$rsync_add" != "" ] && cmd="$cmd $rsync_add"
  cmd="$cmd $rsync_source"  # no \" so we can specify multiple paths
  cmd="$cmd \"$rsync_dest\""
}

#
# print the actual commands that would be run (ssh, DBMS, rsync)
#
# must not be called until after needdblist() is defined
#
# "local" vars: do_something, dbms
# global vars: cmd, dbmslist, dbms_prefix, dbms_dodump, dbms_usetunnel,
#              dbms_dbs, dbms_splitdbs, do_rsync, rsync_mode
#
printcmds () {
  # are we supposed to actually do anything?
  do_something="no"  # set this to yes later if we do something

  # DBMSes
  for dbms in $dbmslist; do
    switchdbms "$dbms"

    if [ "$dbms_dodump" = "yes" ]; then
      do_something="yes"

      # SSH tunnel
      if [ "$dbms_usetunnel" = "yes" ]; then
        switchtunnel "$dbms"
        setsshcmd
        echo "$dbms_prefix ssh command: $cmd"
      fi

      # DB list
      if needdblist; then
        setdblistcmd
        echo "$dbms_prefix get-DB-list command: $cmd"
      fi

      # dump DBs
      if [ "$dbms_splitdbs" = "no" ]; then
        case "$dbms_dbs" in
          all)
            setdbdumpallcmd
            echo "$dbms_prefix dump-all-DBs command: $cmd"
            ;;
          include|exclude)
            setdbdumpmultcmd ""
            echo "$dbms_prefix dump-multiple-DBs command: $cmd"
            ;;
        esac
      else  # dbms_splitdbs="yes"
        setdbdumponecmd ""
        echo "$dbms_prefix dump-one-DB command: $cmd"
      fi
    fi  # if [ "$dbms_dodump" = "yes" ]
  done  # for dbms in $dbmslist

  # rsync
  if [ "$do_rsync" = "yes" ]; then
    do_something="yes"

    # SSH tunnel
    if [ "$rsync_mode" = "tunnel" ]; then
      switchtunnel "rsync"
      setsshcmd
      echo "rsync ssh command: $cmd"
    fi

    # actual rsync
    setrsynccmd
    echo "rsync command: $cmd"
  fi

  # did we actually do anything?
  if [ "$do_something" = "no" ]; then  # everything was turned off
    echo "no commands would be run, because no actions are turned on"
  fi
}


#############################################
# core functions: rotation, pruning, zipping
#############################################

#
# rotate numbered files
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number (not in $1 because the most recent
#     file won't have a separator or a number)
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, filename, filenum, newnum, newname
#
rotatenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"

  # first pass
  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.lz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # this regexp could be a bit more concise, but it would be less portable
    filenum=$(echo "$filename" | \
              sed 's|^'"$prefix$sep"'\([0-9][0-9]*\)'"$suffix"'.*$|\1|')

    # create the new filename
    #
    # use temporary variables to make this clearer
    # also, expr is more portable than $(())
    newnum=$(expr "$filenum" + 1)
    newname=$(echo "$filename" | \
              sed 's|^\('"$prefix$sep"'\)[0-9][0-9]*|\1'"$newnum"'|')

    # move the file
    #
    # if we renumber the files without going in descending order,
    # we'll overwrite some, but sorting on the $filenum is tricky;
    # instead, add .new, then rename all of them
    mv "$filename" "$newname.new"
  done  # first pass

  # remove .new extensions
  for filename in "$prefix$sep"[0-9]*"$suffix"*".new"; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*.new" ]; then
      break
    fi

    # check more precisely and move the file
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.lz\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.gz\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.bz\.new$" > /dev/null 2>&1 \
       || \
       echo "$filename" | grep "^$prefix$sep[0-9][0-9]*$suffix\.bz2\.new$" > /dev/null 2>&1; then
      mv "$filename" "$(echo "$filename" | sed 's|\.new$||')"
    else
      continue
    fi
  done

  # handle the most recent file
  for filename in "$prefix$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.lz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # move the file
    mv "$filename" "$(echo "$filename" | \
        sed 's|^'"$prefix$suffix"'|'"$prefix${sep}1$suffix"'|')"
  done
}

#
# prune numbered files by number and date
#
# $1: full path up to the number, not including any trailing separator
# $2: separator before the number
# $3: suffix after the number, including any leading separator
#     (cannot begin with a number)
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# "local" vars: prefix, sep, suffix, numf, daysf, filename, filenum
#
prunenumfiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

  # anything to do?
  if [ "$numf" = "0" ] && [ "$daysf" = "0" ]; then
    return
  fi

  for filename in "$prefix$sep"[0-9]*"$suffix"*; do
    # if nothing is found, the actual glob will be used for $filename
    if [ "$filename" = "$prefix$sep[0-9]*$suffix*" ]; then
      break
    fi

    # check more precisely
    #
    # do some contortions to avoid needing egrep
    if echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.lz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.gz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz$" > /dev/null 2>&1 \
       && \
       echo "$filename" | grep -v "^$prefix$sep[0-9][0-9]*$suffix\.bz2$" > /dev/null 2>&1; then
      continue
    fi

    # get the file number
    #
    # this regexp could be a bit more concise, but it would be less portable
    filenum=$(echo "$filename" | \
              sed 's|^'"$prefix$sep"'\([0-9][0-9]*\)'"$suffix"'.*$|\1|')

    # check number and delete
    if [ "$numf" != "0" ] && [ "$filenum" -ge "$numf" ]; then
      # -r for dirs
      rm -rf "$filename"
      continue
    fi

    # delete by date
    if [ "$daysf" != "0" ]; then
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    fi
  done
}

#
# prune dated files by number and date
#
# $1: full path up to the date, not including any trailing separator
# $2: separator before the date
# $3: suffix after the date, including any leading separator
#
# $4: number of files, 0=unlimited
# $5: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $3
#
# also works on directories
#
# note: "current" file must exist before calling this function, so that
# it can be counted
#
# also, because we can't make any assumptions about the format of the date
# string, this function can be over-broad in the files it looks at;
# make sure there are no files that match $prefix$sep*$suffix* except for
# the desired ones
#
# "local" vars: prefix, sep, suffix, numf, daysf, kept, OLDIFS, filename
# global vars: IFS, newline
#
prunedatefiles () {
  prefix="$1"
  sep="$2"
  suffix="$3"
  numf="$4"
  daysf="$5"

  # prune by number
  if [ "$numf" != "0" ]; then
    kept="0";

    OLDIFS="$IFS"
    IFS="$newline"

    # parsing ls isn't terribly safe, but if we restrict the values of the
    # settings and change IFS, it might be ok, and it's pretty much the
    # only way to sort by date without using something like Perl...
    ls -t "$prefix$sep"*"$suffix"* 2>/dev/null \
    | while read filename; do
      # check more precisely
      #
      # do some contortions to avoid needing egrep
      if echo "$filename" | grep -v "^$prefix$sep.*$suffix$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.lz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.gz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz2$" > /dev/null 2>&1; then
        continue
      fi

      # skip, then delete
      if [ "$kept" -lt "$numf" ]; then
        # expr is more portable than $(())
        kept=$(expr "$kept" + 1)
      else
        # -r for dirs
        rm -rf "$filename"
      fi
    done

    IFS="$OLDIFS"
  fi  # if [ "$numf" != "0" ]

  # prune by date
  if [ "$daysf" != "0" ]; then
    for filename in "$prefix$sep"*"$suffix"*; do
      # if nothing is found, the actual glob will be used for $filename
      if [ "$filename" = "$prefix$sep*$suffix*" ]; then
        break
      fi

      # check more precisely
      #
      # do some contortions to avoid needing egrep
      if echo "$filename" | grep -v "^$prefix$sep.*$suffix$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.lz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.gz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz$" > /dev/null 2>&1 \
         && \
         echo "$filename" | grep -v "^$prefix$sep.*$suffix\.bz2$" > /dev/null 2>&1; then
        continue
      fi

      # delete
      #
      # -r for dirs
      find "$filename" -mtime +"$daysf" -exec rm -rf {} \;
    done
  fi
}

#
# wrapper: prune numbered or dated files by number and date
#
# $1: layout type
#
# $2: full path up to the number/date, not including any trailing separator
# $3: separator before the number/date
# $4: suffix after the number/date, including any leading separator
#     (cannot begin with a number if using a numbered layout)
#
# $5: number of files, 0=unlimited
# $6: days worth of files, 0=unlimited
#
# filenames can have an optional .gz, .bz, .bz2, or .lz after $4
#
# also works on directories
#
prunefiles () {
  case "$1" in
    # currently, the function is not actually called for "append",
    # but put it here for future use / FTR
    single|singledir|append)
      :  # nothing to do
      ;;
    number|numberdir)
      prunenumfiles "$2" "$3" "$4" "$5" "$6"
      ;;
    date|datedir)
      prunedatefiles "$2" "$3" "$4" "$5" "$6"
      ;;
  esac
}

#
# rotate and prune the output logs
#
# filenames can have an optional trailing .gz, .bz, .bz2, or .lz
#
# global vars: outputlog, outputlog_layout, outputlog_sep, numlogs, dayslogs
#
rotatepruneoutputlogs () {
  if [ "$outputlog" = "" ]; then
    logstatus "output logging is off; not rotating logs"
    return
  fi

  if [ "$outputlog_layout" = "append" ]; then
    logstatus "output logs are being appended to a single file; not rotating logs"
    return
  fi

  logstatus "rotating logs"

  # rotate
  if [ "$outputlog_layout" = "number" ]; then
    rotatenumfiles "$outputlog" "$outputlog_sep" ""
  fi

  # prune
  prunefiles "$outputlog_layout" "$outputlog" "$outputlog_sep" "" \
             "$numlogs" "$dayslogs"
}


##############################
# core functions: SSH tunnels
##############################

#
# open an SSH tunnel
#
# one tunnel at a time; closesshtunnel() must be run before opening
# another tunnel
#
# "local" vars: waited, sshexit
# global vars: cmd, sshpid, tun_prefix, tun_localport, tun_sshtimeout,
#              vars for setsshcmd()
# FDs: 3
#
opensshtunnel () {
  # set $cmd for ssh; see SECURITY NOTE, above, about this
  setsshcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running ssh command for $tun_prefix: $cmd" all
  echo "running ssh command for $tun_prefix: $cmd" >&3

  # run the command
  #
  # note & _in the quotes_, so $! contains the correct pid
  eval "$cmd >&3 2>&1 &"
  sshpid="$!"

  # make sure it's actually working;
  # see http://mywiki.wooledge.org/ProcessManagement#Starting_a_.22daemon.22_and_checking_whether_it_started_successfully
  waited="0"
  while sleep 1; do
    nc -z localhost "$tun_localport" && break
    if kill -0 "$sshpid"; then
      # expr is more portable than $(())
      waited=$(expr "$waited" + 1)
      if [ "$waited" -ge "$tun_sshtimeout" ]; then
        sendalert "could not establish SSH tunnel for $tun_prefix (timed out); exiting" log
        kill "$sshpid"
        wait "$sshpid"
        do_exit 3 clean
      fi
    else
      wait "$sshpid"
      sshexit="$?"
      sendalert "could not establish SSH tunnel for $tun_prefix (error code $sshexit); exiting" log
      do_exit 3 clean
    fi
  done

  logstatus "SSH tunnel for $tun_prefix established"
}

#
# close an SSH tunnel
#
# global vars: sshpid, tun_prefix
#
closesshtunnel () {
  kill "$sshpid"
  wait "$sshpid"
  sshpid=""  # so we know if a tunnel is open
  logstatus "SSH tunnel for $tun_prefix closed"
}


###########################
# core functions: DB dumps
###########################

#
# are we going to need the list of all DBs?
#
# factored out in case this varies by DBMS
#
# global vars: dbms_prefix, *_dbs, *_splitdbs
#
needdblist () {
  case "$dbms_prefix" in
    mysql)
      if { [ "$dbms_dbs" = "all" ] && [ "$dbms_splitdbs" = "yes" ]; } \
         || \
         [ "$dbms_dbs" = "exclude" ]; then
        return 0  # true
      else
        return 1  # false
      fi
      ;;
  esac
}

#
#
# get the list of all DBs if necessary
#
# "local" vars: tr_in, tr_out
# global vars: dbms_dbs, dbms_dbdelim, dbms_splitdbs, lockfile, alldbs,
#              alldbsorig, cmd, newline, tab, vars for needdblist()
# tempfiles: alldbs, alldbsorig
# FDs: 3
#
getdblist () {
  # do we need the list?
  if needdblist; then
    :  # avoid non-portable 'if !'
  else
    return
  fi

  # set $cmd to get DB list; see SECURITY NOTE, above, about this
  setdblistcmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running $dbms_prefix get-DB-list command: $cmd" all
  echo "running $dbms_prefix get-DB-list command: $cmd" >&3

  # run the command
  rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
  eval "$cmd" > "$lockfile/$alldbs" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    sendalert "could not get the list of $dbms_prefix databases; exiting" log
    do_exit 4 clean
  else
    logstatus "obtained the list of $dbms_prefix databases"
  fi

  # separate by dbms in case some have different output formats,
  # but most can probably be lumped together
  case "$dbms_prefix" in
    mysql)
      #
      # db names separated by newlines
      #

      mv -f "$lockfile/$alldbs" "$lockfile/$alldbsorig"

      # check for the delimiter
      if [ "$dbms_dbdelim" != "$newline" ]; then
        tr -d "$dbms_dbdelim" < "$lockfile/$alldbsorig" \
                              > "$lockfile/$alldbs"
        if filecomp "$lockfile/$alldbsorig" "$lockfile/$alldbs"; then
          :  # avoid non-portable 'if !'
        else  # cover both mismatch and error
          sendalert "the list of $dbms_prefix databases already contains the delimiter; exiting" log
          do_exit 5 clean
        fi
      fi

      # if the delimiter is a newline or tab, check for MySQL escape
      # sequences
      if [ "$dbms_prefix" = "mysql" ]; then
        if [ "$dbms_dbdelim" = "$newline" ]; then
          rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
          sed -e 's/\\n/\n/' < "$lockfile/$alldbsorig" \
                             > "$lockfile/$alldbs"
          if filecomp "$lockfile/$alldbsorig" "$lockfile/$alldbs"; then
            :  # avoid non-portable 'if !'
          else  # cover both mismatch and error
            sendalert "the list of $dbms_prefix databases already contains the delimiter; exiting" log
            do_exit 5 clean
          fi
        fi
        if [ "$dbms_dbdelim" = "$tab" ]; then
          rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
          sed -e 's/\\t/\t/' < "$lockfile/$alldbsorig" \
                             > "$lockfile/$alldbs"
          if filecomp "$lockfile/$alldbsorig" "$lockfile/$alldbs"; then
            :  # avoid non-portable 'if !'
          else  # cover both mismatch and error
            sendalert "the list of $dbms_prefix databases already contains the delimiter; exiting" log
            do_exit 5 clean
          fi
        fi
      fi

      # check for characters that could break out of a quoted string,
      # or drop things into one
      rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
      tr -d "'\"\`$" < "$lockfile/$alldbsorig" \
                     > "$lockfile/$alldbs"
      if filecomp "$lockfile/$alldbsorig" "$lockfile/$alldbs"; then
        :  # avoid non-portable 'if !'
      else  # cover both mismatch and error
        sendalert "the list of $dbms_prefix databases contains a dangerous character; exiting" log
        do_exit 5 clean
      fi

      # reformat the list
      rm -f "$lockfile/$alldbs"  # to prevent noclobber-type issues
      # this leaves a delimiter at the end, but it seems to be ignored
      tr "$newline" "$dbms_dbdelim" < "$lockfile/$alldbsorig" \
                                    > "$lockfile/$alldbs"

      # apply MySQL escape sequences
      if [ "$dbms_prefix" = "mysql" ]; then
        mv -f "$lockfile/$alldbs" "$lockfile/$alldbsorig"
        sed -e 's/\\n/\n/' -e 's/\\t/\t/' < "$lockfile/$alldbsorig" \
                                          > "$lockfile/$alldbs"
      fi
      ;;
  esac  # case "$dbms_prefix"
}

#
# get the path information for a set of DB dumps (without the DB name),
# and create the subdirectory if necessary
#
# note that for "number"/"numberdir" layouts, the prefix and suffix omit
# the number, because the most recent version is unnumbered
#
# mkdir -p isn't portable, so subdirectories must be directly under the
# dumpdir (until/unless we emulate it...)
#
# global vars: dumpprefix, dumpsep, dumpsuffix, dbms_dumpdir, dbms_layout,
#              dbms_fileprefix, dbms_filesuffix, dbms_subdirprefix,
#              dbms_filedirsep, dbms_datestring
#
getdumppath () {
  case "$dbms_layout" in
    single)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      ;;
    number)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix="$dbms_filesuffix"
      ;;
    date)
      dumpprefix="$dbms_dumpdir/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix="$dbms_filedirsep$dbms_datestring$dbms_filesuffix"
      ;;
    singledir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      ;;
    numberdir)
      [ ! -d "$dbms_dumpdir/$dbms_subdirprefix" ] && \
          mkdir "$dbms_dumpdir/$dbms_subdirprefix"
      dumpprefix="$dbms_dumpdir/$dbms_subdirprefix/$dbms_fileprefix"
      dumpsep="$dbms_filedirsep"
      dumpsuffix="$dbms_filesuffix"
      ;;
    datedir)
      dumpprefix="$dbms_dumpdir/"
      if [ "$dbms_subdirprefix" != "" ]; then
        [ ! -d "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_subdirprefix$dbms_filedirsep$dbms_datestring"
        dumpprefix="$dumpprefix$dbms_subdirprefix$dbms_filedirsep"
        dumpsep="$dbms_filedirsep"
      else
        [ ! -d "$dbms_dumpdir/$dbms_datestring" ] && \
            mkdir "$dbms_dumpdir/$dbms_datestring"
        dumpsep=""
      fi
      dumpprefix="$dumpprefix$dbms_datestring/$dbms_fileprefix"
      dumpsuffix="$dbms_filesuffix"
      ;;
  esac
}

#
# run a single DB dump, including file rotation, etc.
#
# see getdumppath() for info about dumpprefix/dumpsep/dumpsuffix
#
# $cmd must be pre-set, including e.g. database names, however
# $1 must also be set to the database name, if dbms_splitdbs="yes"
#
# "local" vars: dbname
# global vars: dumpprefix, dumpsep, dumpsuffix, cmd, dbms_layout,
#              dbms_numfiles, dbms_daysfiles, dbms_zipmode, dbms_zipoptions
# FDs: 3
#
do_dbdump () {
  dbname="$1"

  # make way for the new dump
  case "$dbms_layout" in
    single|singledir)
      # so we don't have any noclobber-type issues
      rm -f "$dumpprefix$dbname$dumpsuffix"
      ;;
    number|numberdir)
      rotatenumfiles "$dumpprefix$dbname" "$dumpsep" "$dumpsuffix"
      ;;
  esac

  # $cmd must be pre-set for DB dump; see SECURITY NOTE, above, about this

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running $dbms_prefix dump command: $cmd" all
  echo "running $dbms_prefix dump command: $cmd" >&3

  # starting timestamp
  echo "$dbms_prefix dump started $(date)" >&3

  # run the command
  #
  # > is safe from noclobber-type issues because we've already
  # rotated/removed the old file(s)
  eval "$cmd" > "$dumpprefix$dbname$dumpsuffix" 2>&3

  # check status
  if [ "$?" != 0 ]; then
    if [ "$dbname" != "" ]; then
      sendalert "error dumping $dbms_prefix database \"$dbname\"; exiting" log
    else
      sendalert "error dumping $dbms_prefix database(s); exiting" log
    fi
    do_exit 6 clean
  else
    if [ "$dbname" != "" ]; then
      logstatus "successfully dumped $dbms_prefix database \"$dbname\""
    else
      logstatus "successfully dumped $dbms_prefix database(s)"
    fi
  fi

  # ending timestamp
  echo "$dbms_prefix dump finished $(date)" >&3

  # prune and zip
  #
  # prune after the dump to preserve old data as long as possible
  # in case anything goes wrong;
  # zip after pruning so we use less total space during the process
  prunefiles "$dbms_layout" "$dumpprefix$dbname" "$dumpsep" \
       "$dumpsuffix" "$dbms_numfiles" "$dbms_daysfiles"
  if [ "$dbms_zipmode" != "none" ]; then
    # no " so we can specify multiple options
    "$dbms_zipmode" $dbms_zipoptions "$dumpprefix$dbname$dumpsuffix"
  fi
}

#
# wrapper around the different modes of DB dumps, e.g. loop on each DB
#
# "local" vars: OLDIFS, dbnames, dbname, exclude
# global vars: IFS, dbms_dbs, dbms_dblist, dbms_dbdelim, dbms_splitdbs,
#              lockfile, alldbs
# tempfiles: alldbs
#
do_dbdumploop () {
  if [ "$dbms_dbs" != "all" ] || [ "$dbms_splitdbs" = "yes" ]; then
    OLDIFS="$IFS"
  fi

  if [ "$dbms_splitdbs" = "no" ]; then
    case "$dbms_dbs" in
      all)
        setdbdumpallcmd
        ;;
      include)
        dbnames=""
        for dbname in $(echo "$dbms_dblist"); do
          dbnames="$dbnames \"$dbname\""
        done
        setdbdumpmultcmd "$dbnames"
        ;;
      exclude)
        dbnames=""
        while read dbname; do  # < "$lockfile/$alldbs"
          for exclude in $(echo "$dbms_dblist"); do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done
          dbnames="$dbnames \"$dbname\""
        done < "$lockfile/$alldbs"
        setdbdumpmultcmd "$dbnames"
        ;;
    esac
    do_dbdump
  else  # dbms_splitdbs="yes"
    case "$dbms_dbs" in
      all)
#        IFS="$dbms_dbdelim"
IFS="$tab$newline"
echo "foo bar	baz
" | \
        while read dbname; do  # < "$lockfile/$alldbs"
echo "$dbname"
          IFS="$OLDIFS"
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
          IFS="$dbms_dbdelim"
        done #< "$lockfile/$alldbs"
        IFS="$OLDIFS"
        ;;
      include)
        for dbname in $(echo "$dbms_dblist"); do
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
        done
        ;;
      exclude)
        while read dbname; do  # < "$lockfile/$alldbs"
          for exclude in $(echo "$dbms_dblist"); do
            if [ "$dbname" = "$exclude" ]; then
              continue 2
            fi
          done
          setdbdumponecmd "$dbname"
          do_dbdump "$dbname"
        done < "$lockfile/$alldbs"
        ;;
    esac
  fi

  if [ "$dbms_dbs" != "all" ] || [ "$dbms_splitdbs" = "yes" ]; then
    IFS="$OLDIFS"
  fi
}


##########################################
# command line and configuration settings
##########################################

# make sure the script was called sensibly
if [ "$#" -gt 2 ]; then
  usage
  throwerr "Error: invalid number of command-line parameters; exiting."
fi
mode="$2"
checklist "mode" "" "help" "usage" "license" "cmds" "silence" "unsilence" \
          "stop" "disable" "start" "enable" "clearlock" "unlock"

# need the usage message?
if [ "$2" = "help" ] || [ "$2" = "usage" ]; then
  usage
  do_exit 0
fi

# need the license message?
if [ "$2" = "license" ]; then
  license
  do_exit 0
fi

# save variables set on the command line
savevars

if [ "$1" = "-" ]; then  # - means no config file
  configfile="-"  # save for later
  # nothing to source
else
  # get config file path
  if [ "$1" = "" ]; then
    configfile="$defaultconfigfile"
  else
    configfile="$1"
  fi

  # . won't work with no directory (unless ./ is in the PATH),
  # the cwd has to be specified explicitly
  if echo "$configfile" | grep -v '/' > /dev/null 2>&1; then
    configfile="./$configfile"
  fi

  # source config file
  checkreadfile "configfile"
  . "$configfile"
fi

# restore variables set on the command line, overriding the config file
restorevars

# apply default settings where applicable
applydefaults

# validate the config
checkconf

# debug mode?
# (in case it was turned on in the config file, but not on the command line;
# see above)
if [ "$debugme" = "yes" ]; then
  do_debug
fi

# set PATH
if [ "$usepath" != "" ]; then
  PATH="$usepath"
  # separate line is more portable
  export PATH
fi

# set umask
if [ "$useumask" != "" ]; then
  umask "$useumask"
fi

# handle remaining command-line mode options
# these are meant to be run manually from the command line, so only
# log actual status changes
case "$2" in
  cmds)
    # print the actual commands that would be run (ssh, DBMS, rsync)
    printcmds
    do_exit 0
    ;;
  silence)
    # silence lockfile-exists alerts
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory doesn't exist; nothing to silence"
      do_exit 1
    fi
    if [ -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already silenced"
      do_exit 1
    fi
    # using a file in the lockfile dir means that we automatically
    # get the silencing cleared when the lockfile is removed
    touch "$lockfile/$silencealerts"
    echo "lockfile alerts have been silenced"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile alerts have been silenced, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  unsilence)
    # unsilence lockfile-exists alerts
    if [ ! -f "$lockfile/$silencealerts" ]; then  # -e isn't portable
      echo "lockfile alerts were already unsilenced"
      do_exit 1
    fi
    rm -f "$lockfile/$silencealerts"
    echo "lockfile alerts have been unsilenced"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile alerts have been unsilenced, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  stop|disable)
    # disable backups
    if [ -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already disabled"
      do_exit 1
    fi
    if [ -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile directory exists; a backup is probably running"
      echo "disable command will take effect after the current backup finishes"
      echo
    fi
    mkdir "$lockfile" > /dev/null 2>&1  # ignore already-exists errors
    touch "$lockfile/$disable"
    echo "backups have been disabled; remember to re-enable them later!"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been disabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  start|enable)
    # re-enable backups
    if [ ! -f "$lockfile/$disable" ]; then  # -e isn't portable
      echo "backups were already enabled"
      do_exit 1
    fi
    rm -f "$lockfile/$disable"
    echo "backups have been re-enabled"
    echo "if a backup is not currently running, you should now remove the lockfile"
    echo "with the unlock command"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "backups have been re-enabled, lockfile=\"$lockfile\""
    do_exit 0
    ;;
  clearlock|unlock)
    # remove lockfile dir
    if [ ! -d "$lockfile" ]; then  # -e isn't portable
      echo "lockfile has already been removed"
      do_exit 1
    fi
    echo
    echo "WARNING: the lockfile should only be removed if you're sure a backup is not"
    echo "currently running."
    echo "Type 'y' (without the quotes) to continue."
    # it would be nice to have this on the same line as the prompt,
    # but the portability issues aren't worth it for this
    read type_y
    if [ "$type_y" != "y" ]; then
      echo "Exiting."
      do_exit 0
    fi
    echo
    rm -rf "$lockfile"
    echo "lockfile has been removed"
    quiet="yes"  # don't print to the terminal again
    logconfig  # so we know what the status message means
    logstatus "lockfile \"$lockfile\" has been manually removed"
    do_exit 0
    ;;
esac

# log config file, current working directory, and setting variables supplied
# on the command line
logconfig


################
# status checks
################

if [ "$runevery" != "0" ]; then
  # has it been long enough since the last backup started?
  #
  # if $startedfile exists and is newer than $runevery, exit
  # (-f instead of -e because it's more portable)
  if [ -f "$startedfile" ] && newerthan "$startedfile" "$runevery"; then
    logstatus "backup interval has not expired; exiting"
    do_exit 0
  else
    logstatus "backup interval has expired; continuing"
  fi
else
  logstatus "interval checking has been disabled; continuing"
fi

# did the previous backup finish?
#
# use an atomic command to check and create the lock
# (could also be ln -s, but we might not be able to set the metadata, and
#  it could cause issues with commands that don't manipulate links directly;
#  plus, now we have a tempdir)
if mkdir "$lockfile" > /dev/null 2>&1; then
  # got the lock, clear lock-alert status
  if [ -f "$alertfile" ]; then  # -f is more portable than -e
    rm "$alertfile"
    sendalert "lockfile created; cancelling previous alert status" log
  fi
else
  # assume mkdir failed because it already existed;
  # but that could be because we manually disabled backups
  if [ -f "$lockfile/$disable" ]; then
    logalert "backups have been manually disabled; exiting"
  else
    logalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  # don't actually exit yet

  # send the initial alert email (no "log", we already logged it)
  #
  # (-f instead of -e because it's more portable)
  if [ ! -f "$alertfile" ]; then
    touch "$alertfile"
    if [ -f "$lockfile/$disable" ]; then
      sendalert "backups have been manually disabled; exiting"
    else
      sendalert "could not create lockfile (previous backup still running or failed?); exiting"
    fi
    do_exit 2
  fi

  # but what about subsequent emails?

  # if ifrunning=0, log it but don't send email
  if [ "$ifrunning" = "0" ]; then
    logalert "ifrunning=0; no email sent"
    do_exit 2
  fi

  # if alerts have been silenced, log it but don't send email
  # (and don't bother checking $ifrunning)
  if [ -f "$lockfile/$silencealerts" ]; then
    logalert "alerts have been silenced; no email sent"
    do_exit 2
  fi

  # if $alertfile is newer than $ifrunning, log it but don't send email
  if newerthan "$alertfile" "$ifrunning"; then
    logalert "alert interval has not expired; no email sent"
    do_exit 2
  fi

  # send an alert email (no "log", we already logged it)
  touch "$alertfile"
  if [ -f "$lockfile/$disable" ]; then
    sendalert "backups have been manually disabled; exiting"
  else
    sendalert "could not create lockfile (previous backup still running or failed?); exiting"
  fi
  do_exit 2
fi  # if mkdir "$lockfile"


###################
# get date strings
###################

# get them all now, so they're as close together as possible

# for the current output log; set the filename while we're at it
outputlog_filename="$outputlog"
if [ "$outputlog" != "" ] && [ "$outputlog_layout" = "date" ]; then
  if [ "$outputlog_date" != "" ]; then
    outputlog_datestring=$(date "$outputlog_date")
  else
    outputlog_datestring=$(date)
  fi
  outputlog_filename="$outputlog_filename$outputlog_sep$outputlog_datestring"
  touch "$outputlog_filename"  # needed for prunedayslogs()
fi

# for the current DB dump filenames
for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ] \
     && \
     { [ "$dbms_layout" = "date" ] || [ "$dbms_layout" = "datedir" ]; }; then
    if [ "$dbms_filedirdate" != "" ]; then
      dbms_datestring=$(date "$dbms_filedirdate")
    else
      dbms_datestring=$(date)
    fi
    eval "`echo $dbms`_datestring=\"$dbms_datestring\""
  fi
done


###################
# start output log
###################

# set up a fifo for logging; this has two benefits:
# 1) we can handle multiple output options in one place
# 2) we can run commands without needing pipelines, so we can get the
#    return values
mkfifo "$lockfile/$logfifo"

# rotate and prune output logs
# (also tests in case there is no output log, and prints status accordingly)
rotatepruneoutputlogs

if [ "$outputlog" != "" ]; then
  # append to the output log and possibly stdout
  # appending is always safe / the right thing to do, because either the
  # file won't exist, or it will have been moved out of the way by the
  # rotation - except in one case:
  # if we're using a date layout, and the script has been run more recently
  # than the datestring allows for, we should append so as not to lose
  # information
  if [ "$quiet" = "no" ]; then  # default to yes
    tee -a "$outputlog_filename" < "$lockfile/$logfifo" &
  else
    cat >> "$outputlog_filename" < "$lockfile/$logfifo" &
  fi
else  # no output log
  if [ "$quiet" = "no" ]; then
    cat < "$lockfile/$logfifo" &
  else
    cat > /dev/null < "$lockfile/$logfifo" &
  fi
fi

# create an fd to write to instead of the fifo,
# so it won't be closed after every line;
# see http://mywiki.wooledge.org/BashFAQ/085
exec 3> "$lockfile/$logfifo"


################
# begin working
################

# starting notifications/timestamps
logstatus "starting backup"
touch "$startedfile"
echo "backup started $(date)" >&3

# are we supposed to actually do anything?
do_something="no"  # set this to yes later if we do something


###########
# DB dumps
###########

for dbms in $dbmslist; do
  switchdbms "$dbms"

  if [ "$dbms_dodump" = "yes" ]; then
    do_something="yes"

    logstatus "starting $dbms_prefix dump sequence"

    # open the SSH tunnel if we're going to use one
    if [ "$dbms_usetunnel" = "yes" ]; then
      switchtunnel "$dbms"
      opensshtunnel
    fi

    # get the list of all DBs if necessary
    getdblist

    # get the path information for the DB dump(s), and create the
    # subdirectory if necessary
    getdumppath

    # do the actual dump(s)
    do_dbdumploop

    # close the SSH tunnel if we had one
    if [ "$dbms_usetunnel" = "yes" ]; then
      closesshtunnel
    fi

    logstatus "$dbms_prefix dump sequence completed"
  fi
done


########
# rsync
########

if [ "$do_rsync" = "yes" ]; then
  do_something="yes"

  logstatus "starting rsync backup sequence"

  # open the SSH tunnel if we're going to use one
  if [ "$rsync_mode" = "tunnel" ]; then
    switchtunnel "rsync"
    opensshtunnel
  fi

  # set $cmd for rsync; see SECURITY NOTE, above, about this
  setrsynccmd

  # log the command; only log to syslog if usesyslog="all"
  logstatusquiet "running rsync command: $cmd" all
  echo "running rsync command: $cmd" >&3

  # starting timestamp
  echo "rsync started $(date)" >&3

  # run the command
  eval "$cmd" >&3 2>&1

  # check status
  if [ "$?" != 0 ]; then
    sendalert "warning: rsync finished with errors; please check the log" log
    setexitval 7
  else
    logstatus "rsync completed without errors"
  fi

  # ending timestamp
  echo "rsync finished $(date)" >&3

  # close the SSH tunnel
  if [ "$rsync_mode" = "tunnel" ]; then
    closesshtunnel
  fi

  logstatus "rsync backup sequence completed"
fi


###############
# done working
###############

# did we actually do anything?
if [ "$do_something" = "no" ]; then  # everything was turned off
  logstatus "nothing to do, because no actions are turned on"
fi

# finishing notifications
logstatus "backup finished"
echo "backup finished $(date)" >&3


##################
# stop output log
##################

# remove the fifo and kill the reader process;
# note that we don't have to worry about doing this if we exit abnormally,
# because exiting will close the fd, and the fifo is in the lockfile dir

exec 3>&-  # close the fd, this should kill the reader
rm -f "$lockfile/$logfifo"


###########
# clean up
###########

do_exit 0 clean
